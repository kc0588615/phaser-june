This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
common/
  assets/
    fonts/
      __init__.py
    sounds/
      combo_sounds/
        __init__.py
      glass_clinks/
        __init__.py
      rock_clacks/
        __init__.py
  managers/
    audio_manager.py
    font_manager.py
    managers.py
  match3/
    backend_puzzle.py
    events.py
    frontend_puzzle_particle_system.py
    frontend_puzzle.py
    gem_assets.py
    gem_types.py
    gem.py
    helpers.py
    player_actions.py
  constants.py
  file_helpers.py
  helpers.py
examples/
  1_cards/
    example.py
  2_match_three/
    example.py
.gitignore
.pre-commit-config.yaml
pyproject.toml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="common/assets/fonts/__init__.py">
import os

current_dir = os.path.dirname(__file__)

# https://managore.itch.io/m5x7
M5X7 = os.path.join(current_dir, "m5x7.ttf")
</file>

<file path="common/assets/sounds/combo_sounds/__init__.py">
import os

COMBO_SOUNDS = list(
    os.path.join(os.path.dirname(os.path.abspath(__file__)), f"combo_sound_{i:02d}.wav")
    for i in range(16)
)
</file>

<file path="common/assets/sounds/glass_clinks/__init__.py">
import os

NUM_GLASS_CLINKS = 3
GLASS_CLINKS = list(
    os.path.join(os.path.dirname(os.path.abspath(__file__)), f"glass_clink_{i}.wav")
    for i in range(NUM_GLASS_CLINKS)
)
</file>

<file path="common/assets/sounds/rock_clacks/__init__.py">
import os

NUM_ROCK_CLACKS_SOUNDS = 25
ROCK_CLACKS = list(
    os.path.join(
        os.path.dirname(os.path.abspath(__file__)), f"rocks_clacking_{i:02d}.wav"
    )
    for i in range(NUM_ROCK_CLACKS_SOUNDS)
)
</file>

<file path="common/managers/audio_manager.py">
import pygame


class AudioManager:
    def __init__(self):
        pygame.mixer.init()
        pygame.mixer.set_num_channels(100)
        self.sounds = {}
        self.sfx_muted = False
        self.sfx_volume = 1.0

    def load_sound(self, name, filepath):
        sound = pygame.mixer.Sound(filepath)
        self.sounds[name] = sound

    def play_sound(self, name):
        channel = pygame.mixer.find_channel()
        if channel is None:
            raise Exception(
                "We have ran out of channels. Are you playing too many sounds at the same time?"
            )
        channel.set_volume(self.sfx_volume)
        if not self.sfx_muted:
            self.sounds[name].play()

    def assert_sound_exists(self, name: str) -> None:
        """Checks that a sound exists in the audio manager."""
        assert name in self.sounds

    def set_sound_volume(self, name, volume):
        self.sounds[name].set_volume(volume)

    def get_sound_volume(self, name) -> float:
        return self.sounds[name].get_volume()

    def set_sfx_volume(self, volume: float) -> None:
        self.sfx_volume = volume

    def mute_sfx(self) -> None:
        self.set_sfx_volume(0.0)
        self.sfx_muted = True

    def unmute_sfx(self) -> None:
        self.sfx_muted = False
        self.set_sfx_volume(self.sfx_volume)

    def toggle_sfx_mute(self) -> None:
        if self.sfx_muted:
            self.unmute_sfx()
        else:
            self.mute_sfx()

    def stop_sound(self, name):
        self.sounds[name].stop()

    def load_music(self, filepath):
        pygame.mixer.music.load(filepath)
        self.music_loaded = True

    def play_music(self, loops=-1):
        if self.music_loaded:
            pygame.mixer.music.play(loops)
        else:
            raise Exception("No music loaded!")

    def pause_music(self):
        pygame.mixer.music.pause()

    def unpause_music(self):
        pygame.mixer.music.unpause()

    def stop_music(self):
        pygame.mixer.music.stop()

    def set_music_volume(self, volume: float):
        pygame.mixer.music.set_volume(volume)

    def get_music_volume(self) -> float:
        return pygame.mixer.music.get_volume()
</file>

<file path="common/managers/font_manager.py">
import pygame


class FontManager:
    def __init__(self):
        pygame.font.init()
        self.fonts = {}

    def load_font(self, name, filepath, size):
        """Load a font and store it in the fonts dictionary."""
        try:
            font = pygame.font.Font(filepath, size)
            self.fonts[name] = font
        except pygame.error as e:
            print(f"Failed to load font {filepath}: {e}")

    def get_font(self, name):
        """Retrieve a font by name."""
        if name in self.fonts:
            return self.fonts[name]
        else:
            print(f"Font {name} not found!")
            return None
</file>

<file path="common/managers/managers.py">
from common.managers.audio_manager import AudioManager
from common.managers.font_manager import FontManager

audio_manager = AudioManager()
font_manager = FontManager()
</file>

<file path="common/match3/backend_puzzle.py">
import dataclasses
import random
from collections import Counter
from copy import deepcopy

from common.match3.gem_types import GemTypes
from common.match3.helpers import apply_move_to_grid
from common.match3.player_actions import MoveAction

Match = list[tuple[int, int]]


@dataclasses.dataclass
class BackendGem:
    gem_type: GemTypes


@dataclasses.dataclass
class ExplodeAndReplacePhase:
    """
    A list of matches and the replacements to fill the gaps created by
    exploding the matches.
    """

    matches: list[Match]
    replacements: list[tuple[int, list[GemTypes]]]

    def is_nothing_to_do(self) -> bool:
        return not bool(self.matches)


class BackendPuzzleState:
    """
    The backend puzzle state. Reads player actions, and responds with backend
    actions to display to the player via the frontend puzzle.
    """

    def __init__(self, width: int, height: int) -> None:
        self.puzzle_state = self.get_initial_puzzle_state_with_no_matches(width, height)
        self.width = width
        self.height = height
        self.next_gems_to_spawn: list[GemTypes] = []

    def get_initial_puzzle_state_with_no_matches(
        self, width: int, height: int
    ) -> list[list[BackendGem]]:
        """
        Creates a 2D array of gem types with no more than 2 consecutive gems of
        the same color in any row or column.

        Args:
          width: Width of the grid (number of columns).
          length: Length of the grid (number of rows).

        Returns:
          A 2D list containing the gem types.
        """
        # Create a list of all gem types
        gem_types = set(gem_type for gem_type in GemTypes)

        # Initialize the grid with empty lists for each row
        grid: list[list[BackendGem]] = [[] for _ in range(width)]

        for x in range(width):
            for y in range(height):

                possible_gems = gem_types

                if y >= 2:
                    if grid[x][y - 1].gem_type == grid[x][y - 2].gem_type:
                        possible_gems = possible_gems - set([grid[x][y - 1].gem_type])

                if x >= 2:
                    if grid[x - 1][y].gem_type == grid[x - 2][y].gem_type:
                        possible_gems = possible_gems - set([grid[x - 1][y].gem_type])

                grid[x].append(BackendGem(gem_type=random.choice(list(possible_gems))))

        return grid

    def get_next_explode_and_replace_phase(
        self, actions: list[MoveAction]
    ) -> ExplodeAndReplacePhase:
        """
        Given the following list of actions, get the next phase of exploding and replacing.
        """
        # Apply actions
        for action in actions:
            self.puzzle_state = self._get_puzzle_state_after_move(
                self.puzzle_state, action
            )

        # Get matches
        matches = self._get_matches(self.puzzle_state)

        replacements = []
        counter = Counter(x for x, y in set(gem for gems in matches for gem in gems))
        for x in range(self.width):
            replacements_for_col = []
            for _ in range(counter[x]):
                replacements_for_col.append(self._get_next_gem_to_spawn().gem_type)
            if replacements_for_col:
                replacements.append((x, replacements_for_col))

        # Sort replacements from left to right
        replacements.sort(key=lambda x: x[0])

        # Apply this phase to the current state
        explode_and_replace_phase = ExplodeAndReplacePhase(
            matches=matches, replacements=replacements
        )
        self.apply_explode_and_replace_phase(explode_and_replace_phase)

        # Return the applied phase
        return explode_and_replace_phase

    def get_matches_from_hypothetical_move(
        self, move_action: MoveAction
    ) -> list[Match]:
        hypothetical_state = self._get_puzzle_state_after_move(
            self.puzzle_state, move_action
        )
        return self._get_matches(hypothetical_state)

    def _get_next_gem_to_spawn(self) -> BackendGem:
        if self.next_gems_to_spawn:
            return BackendGem(gem_type=self.next_gems_to_spawn.pop(0))
        return BackendGem(gem_type=random.choice(list(GemTypes)))

    def add_next_gem_to_spawn(self, gem_type: GemTypes) -> None:
        self.next_gems_to_spawn.append(gem_type)

    def add_next_gems_to_spawn(self, gem_types: list[GemTypes]) -> None:
        self.next_gems_to_spawn.extend(gem_types)

    @staticmethod
    def _get_matches(puzzle_state: list[list[BackendGem]]) -> list[Match]:
        matches = []

        width = len(puzzle_state)
        height = len(puzzle_state[0])

        # Get all vertical matches
        for x in range(width):
            match = []
            last = puzzle_state[x][0]
            match.append((x, 0))
            for y in range(1, height):
                if puzzle_state[x][y] == last:
                    match.append((x, y))
                else:
                    if len(match) > 2:
                        matches.append(match)
                    match = [(x, y)]
                last = puzzle_state[x][y]
            if len(match) > 2:
                matches.append(match)

        # Get all horizontal matches
        for y in range(height):
            match = []
            last = puzzle_state[0][y]
            match.append((0, y))
            for x in range(1, width):
                if puzzle_state[x][y] == last:
                    match.append((x, y))
                else:
                    if len(match) > 2:
                        matches.append(match)
                    match = [(x, y)]
                last = puzzle_state[x][y]
            if len(match) > 2:
                matches.append(match)

        return matches

    @staticmethod
    def _get_puzzle_state_after_move(
        puzzle_state: list[list[BackendGem]], move_action: MoveAction
    ) -> list[list[BackendGem]]:
        """
        Creates another view of the puzzle state after a specified move is
        applied.
        """
        # I just need to copy the lists inside the lists, not actually the
        # BackendGem objects themselves. But this solves the problem for now.
        # Can probably optimise later if more performance is needed.
        state_after_move = deepcopy(puzzle_state)
        apply_move_to_grid(state_after_move, move_action)
        return state_after_move

    def apply_explode_and_replace_phase(
        self, explode_and_replace_phase: ExplodeAndReplacePhase
    ) -> None:
        explode_gems = set(
            gem for match in explode_and_replace_phase.matches for gem in match
        )
        replacements = {
            col: replacements
            for col, replacements in explode_and_replace_phase.replacements
        }
        for x in range(self.width):
            for y in reversed(range(self.height)):
                if (x, y) in explode_gems:
                    self.puzzle_state[x].pop(y)
            if x in replacements:
                for replacement in replacements[x]:
                    self.puzzle_state[x].insert(0, BackendGem(gem_type=replacement))

    def reset(self) -> None:
        """
        If this function is called, a new bunch of backend gems is generated.
        """
        self.puzzle_state = self.get_initial_puzzle_state_with_no_matches(
            self.width, self.height
        )
</file>

<file path="common/match3/events.py">
import dataclasses

import pygame

from common.match3.backend_puzzle import Match
from common.match3.gem_types import GemTypes

SCORING_EVENT = pygame.event.custom_type()


@dataclasses.dataclass
class ScoreEvent:
    scoring_matches: list[tuple[Match, GemTypes]]
    combo_level: int


def post_scoring_event(score_event: ScoreEvent) -> None:
    event = create_event(score_event)
    success = pygame.event.post(event)
    if not success:
        raise Exception(f'Posting event "{event}" went wrong somehow?')


def create_event(score_event: ScoreEvent) -> pygame.Event:
    return pygame.Event(SCORING_EVENT, score_event=score_event)
</file>

<file path="common/match3/frontend_puzzle_particle_system.py">
import math
import random

import pygame

from common.match3.gem_types import GemTypes


class FrontendPuzzleParticleSystem:
    def __init__(
        self,
        position: pygame.Vector2,
        gem_width: int,
        gem_height: int,
        border: int,
    ) -> None:
        self.position = position
        self.gem_width = gem_width
        self.gem_height = gem_height

        self.particles: list[ImmediateBlastParticle] = []

    def process(self, delta: float) -> None:
        for particle in self.particles:
            particle.process(delta)
        for i in reversed(range(len(self.particles))):
            particle = self.particles[i]
            if particle.is_dead():
                self.particles.pop(i)

    def render(self, screen: pygame.Surface) -> None:
        for particle in self.particles:
            particle.draw(screen)

    def create_explosion(
        self, explosion_location: pygame.Vector2, num_particles: int, gem_type: GemTypes
    ) -> None:
        for i in range(num_particles):
            self.particles.append(
                ImmediateBlastParticle(
                    explosion_location
                    + self.position
                    + pygame.Vector2(self.gem_width / 2, self.gem_height / 2),
                    4,
                    GemTypes.get_color_from_gem_type(gem_type),
                    lifespan=0.5,
                )
            )


class ImmediateBlastParticle:
    def __init__(
        self,
        initial_position: pygame.Vector2,
        max_radius: int,
        color: pygame.Color,
        lifespan: float,
    ):
        self.position = initial_position
        self.max_radius = max_radius
        self.color = color
        self.lifespan = 0.3
        self.age = 0.0

        angle = random.uniform(0, 2 * math.pi)
        self.velocity = pygame.Vector2(math.cos(angle), math.sin(angle)) * 150

    def process(self, delta):
        self.position += self.velocity * delta
        self.age += delta

    def draw(self, screen):
        radius = self.max_radius * (1 - (self.age / self.lifespan))
        pygame.draw.circle(
            screen,
            pygame.Color("white"),
            (self.position.x, self.position.y),
            radius,
        )

    def is_dead(self) -> bool:
        return self.age > self.lifespan
</file>

<file path="common/match3/frontend_puzzle.py">
import dataclasses
import math
import random
from enum import Enum, auto
from itertools import pairwise
from typing import Literal

import pygame
import pytweening
from pygame import Surface, Vector2

from common.assets.sounds.combo_sounds import COMBO_SOUNDS
from common.assets.sounds.glass_clinks import GLASS_CLINKS, NUM_GLASS_CLINKS
from common.assets.sounds.rock_clacks import ROCK_CLACKS
from common.helpers import scale_and_clamp, wrapf
from common.managers.managers import audio_manager
from common.match3.backend_puzzle import BackendPuzzleState, Match
from common.match3.events import ScoreEvent, post_scoring_event
from common.match3.frontend_puzzle_particle_system import FrontendPuzzleParticleSystem
from common.match3.gem import FrontendGem
from common.match3.gem_assets import GemAssets
from common.match3.helpers import apply_move_to_grid
from common.match3.player_actions import MoveAction


class FrontendPuzzle:

    MAX_TWEEN_TIME = 0.6
    FALL_TIME = 0.5
    MAX_COMBO_LEVEL = 16

    # How long transitions (grid empty -> grid full and vice versa) should take.
    TRANSITION_TIME = 1.0

    class GameGridPauseState(Enum):
        """Whether or not the game is paused."""

        ACTIVE = auto()
        PAUSED = auto()

    class GameGridState(Enum):
        """The state of the grid and whether its filling or not."""

        EMPTY = auto()
        TRANSITIONING_TO_FULL = auto()
        FULL = auto()
        TRANSITIONING_TO_EMPTY = auto()

    @dataclasses.dataclass
    class RowColTransform:
        axis: Literal["row"] | Literal["col"]
        index: int
        magnitude: float

    @dataclasses.dataclass
    class TweenedRowColTransform:
        axis: Literal["row"] | Literal["col"]
        index: int
        max_magnitude: float
        seconds_since_release: float
        tween_time: float

    class MouseState(Enum):
        MOUSE_UP = auto()
        MOUSE_DOWN = auto()

    def __init__(
        self,
        position: Vector2,
        grid_width: int,
        grid_height: int,
        initial_state: Literal["full", "empty"],
    ) -> None:
        self.position = position

        self.grid_width = grid_width
        self.grid_height = grid_height
        self.gem_width = 30
        self.gem_height = 30

        self.gem_assets = GemAssets()

        self.pause_state = self.GameGridPauseState.ACTIVE
        self.grid_state = (
            self.GameGridState.EMPTY
            if initial_state == "empty"
            else self.GameGridState.FULL
        )
        self.transition_timer = 0.0
        self.mouse_state = self.MouseState.MOUSE_UP

        self.gem_grid_surface = Surface(self.get_surface_size(), flags=pygame.SRCALPHA)

        self.grab_distance = pygame.Vector2(0, 0)
        self.clicked = False
        self.click_initial_position = Vector2(0, 0)
        self.clicked_gem = (0, 0)

        self.accepting_inputs = True

        self.backend_puzzle_state = BackendPuzzleState(
            self.grid_width, self.grid_height
        )

        # Combo logic
        self.combo_level = 0
        self.combo_active = False

        # Create the frontend puzzle state from the backend puzzle state.
        self.gems: list[list[FrontendGem]] = self.get_frontend_gems()

        self.snapping_row_col_transforms: list[
            FrontendPuzzle.TweenedRowColTransform
        ] = []
        self.grabbed_row_col_transform: FrontendPuzzle.RowColTransform | None = None

        self.applied_actions_waiting_for_explosions_to_complete: list[MoveAction] = []
        self.explosions: list[FrontendGem] = []

        # Particle System
        self.particle_system = FrontendPuzzleParticleSystem(
            self.position,
            gem_width=self.gem_width,
            gem_height=self.gem_height,
            border=10,
        )

        # Load required audio
        for i, path in enumerate(GLASS_CLINKS):
            audio_manager.load_sound(f"glass_clink_{i}", path)
        for i, path in enumerate(ROCK_CLACKS):
            audio_manager.load_sound(f"rocks_clacking_{i:02d}", path)
        for i, path in enumerate(COMBO_SOUNDS):
            audio_manager.load_sound(f"combo_sound_{i:02d}", path)
            audio_manager.set_sound_volume(f"combo_sound_{i:02d}", 0.2)

    def get_surface_size(self) -> tuple[int, int]:
        return (self.grid_width * self.gem_width, self.grid_height * self.gem_height)

    def get_gem_default_position_from_grid_coord(
        self, grid_coord: tuple[int, int]
    ) -> Vector2:
        return Vector2(self.gem_width * grid_coord[0], self.gem_height * grid_coord[1])

    def process(self, delta: float) -> None:
        if self.pause_state == FrontendPuzzle.GameGridPauseState.PAUSED:
            return

        if self.grid_state == FrontendPuzzle.GameGridState.TRANSITIONING_TO_EMPTY:
            self.process_transition_to_empty_animation(delta)

        for column in self.gems:
            for gem in column:
                gem.process(delta)

        self.process_exploding_gems(delta)
        self.process_snapping_row_col_tweens(delta)

        if self.is_ready_for_next_explode_and_replace_phase():
            self.frontend_handle_explode_and_replace_phase()

        gem_positions = self.get_position_of_gems()

        # Set positions of gems to the gem_positions
        for gem_col, position_col in zip(self.gems, gem_positions):
            for gem, position in zip(gem_col, position_col):
                if gem.state == FrontendGem.FrontendGemState.IDLE:
                    gem.position = position
                elif gem.state == FrontendGem.FrontendGemState.FALLING:
                    if (
                        self.grid_state
                        != FrontendPuzzle.GameGridState.TRANSITIONING_TO_EMPTY
                    ):
                        if gem.position.y >= position.y:
                            gem.stop_falling()

        # If we are transitioning to full, when all the gems are idle, we're full :)
        if self.grid_state == FrontendPuzzle.GameGridState.TRANSITIONING_TO_FULL:
            if all(
                gem.state == FrontendGem.FrontendGemState.IDLE
                for gem_col in self.gems
                for gem in gem_col
            ):
                self.grid_state = FrontendPuzzle.GameGridState.FULL

        self.particle_system.process(delta)

    def render(self, screen: Surface) -> None:
        # If the grid is empty, just don't render. There shouldn't be anything
        # to render anyway, and we run into problems trying to render the match
        # lines for frontend gems that don't exist.
        if self.grid_state == self.GameGridState.EMPTY:
            return

        # Blank the gem grid surface, ready for drawing
        self.gem_grid_surface.fill((0, 0, 0, 0))

        self.particle_system.render(screen)
        self.draw_match_lines()
        self.draw_frontend_gems()

        # Draw the gem grid surface to the screen
        screen.blit(self.gem_grid_surface, self.position)

    def draw_match_lines(self) -> None:
        row_col_transform = self.get_row_col_transform_from_drag_vector(
            self.grab_distance
        )
        move_action = self.get_move_from_row_col_transform(row_col_transform)
        matches = self.backend_puzzle_state.get_matches_from_hypothetical_move(
            move_action
        )

        for match in matches:
            if not self.should_draw_match_lines_for_this_match(
                match, row_col_transform
            ):
                continue

            actual_match = self.get_actual_match_of_gems_in_hypothetical_match(
                match, move_action, self.grid_width, self.grid_height
            )
            for coord_1, coord_2 in pairwise(actual_match):
                fraction = self.get_linear_fraction_to_closest_snap(
                    row_col_transform, self.gem_width, self.gem_height
                )
                line_width = self.get_match_line_thickness_from_fraction(fraction)
                pygame.draw.line(
                    self.gem_grid_surface,
                    "white",
                    self.gems[coord_1[0]][coord_1[1]].center,
                    self.gems[coord_2[0]][coord_2[1]].center,
                    width=line_width,
                )

    @staticmethod
    def should_draw_match_lines_for_this_match(
        match: Match, row_col_transform: RowColTransform
    ) -> bool:
        """
        Given a match and the RowColTransform of the currently grabbed row/col,
        return a boolean. If True, we should draw the white lines under the
        gems in the match. If False, we should not.

        This is implemented such that lines are only drawn on matches that are
        caused as a direct result of manually moving a row/col.
        """
        for gem in match:
            if row_col_transform.axis == "row":
                index = 1
            else:
                index = 0
            if (
                row_col_transform.index == gem[index]
                and row_col_transform.magnitude != 0
            ):
                return True
        return False

    def draw_frontend_gems(self) -> None:
        # Draw exploding gems
        for gem in self.explosions:
            gem.render(self.gem_grid_surface)

        # Draw the gems in the grid.
        for row in self.gems:
            for gem in row:
                gem.render(self.gem_grid_surface)

    @staticmethod
    def get_actual_match_of_gems_in_hypothetical_match(
        match: Match, move_action: MoveAction, grid_width: int, grid_height: int
    ) -> list[tuple[int, int]]:
        """
        In the frontend, we have the state of our gems, and we know what
        matches we can get given a hypothetical move, but then we need to get
        the index of the ACTUAL frontend gems from the hypothetical match
        index. This is the function that does that.
        """
        modified_match: list[tuple[int, int]] = []
        for coords in match:
            if move_action.row_or_col == "row":
                if coords[1] == move_action.index:
                    modified_match.append(
                        ((coords[0] - move_action.amount) % grid_width, coords[1])
                    )
                else:
                    modified_match.append(coords)
            else:
                if coords[0] == move_action.index:
                    modified_match.append(
                        (coords[0], (coords[1] + move_action.amount) % grid_height)
                    )
                else:
                    modified_match.append(coords)

        return modified_match

    def get_position_of_gems(self) -> list[list[pygame.Vector2]]:
        # First, get all the default positions
        gem_positions = []
        for x in range(self.grid_width):
            row = []
            for y in range(self.grid_height):
                row.append(self.get_gem_default_position_from_grid_coord((x, y)))
            gem_positions.append(row)

        gem_positions = self.apply_currently_snapping_row_col_transforms(gem_positions)
        gem_positions = self.apply_currently_grabbed_row_col_transform(gem_positions)
        return gem_positions

    def apply_currently_snapping_row_col_transforms(
        self, gem_positions: list[list[pygame.Vector2]]
    ) -> list[list[pygame.Vector2]]:
        for tweened_row_col_transform in self.snapping_row_col_transforms:
            if tweened_row_col_transform.tween_time == 0:
                tween_multiplier = 1
            else:
                tween_multiplier = pytweening.easeInCubic(
                    tweened_row_col_transform.seconds_since_release
                    / tweened_row_col_transform.tween_time
                )

            distance = tweened_row_col_transform.max_magnitude * (1 - tween_multiplier)
            gem_positions = self.apply_row_col_transform_to_gem_positions(
                gem_positions,
                self.RowColTransform(
                    axis=tweened_row_col_transform.axis,
                    index=tweened_row_col_transform.index,
                    magnitude=distance,
                ),
            )
        return gem_positions

    def apply_currently_grabbed_row_col_transform(
        self, gem_positions: list[list[pygame.Vector2]]
    ) -> list[list[pygame.Vector2]]:
        # If it exists, apply the currently grabbed row_col_transform (assuming it's valid)
        if self.grab_distance:
            row_col_transform = self.get_row_col_transform_from_drag_vector(
                self.grab_distance
            )
            if self.is_valid_row_col_transform_given_snapping_transforms(
                self.snapping_row_col_transforms, row_col_transform
            ):
                gem_positions = self.apply_row_col_transform_to_gem_positions(
                    gem_positions, row_col_transform
                )
        return gem_positions

    def process_exploding_gems(self, delta: float) -> None:
        # For now, exploding gems just disappear. Can improve animations later.
        for i in reversed(range(len(self.explosions))):
            exploding_gem = self.explosions[i]
            exploding_gem.process_exploding(delta)
            if exploding_gem.is_explosion_finished():
                self.explosions.pop(i)

    def process_snapping_row_col_tweens(self, delta: float) -> None:
        completed_tween_indexes = []

        for i, tweened_row_col_transform in enumerate(self.snapping_row_col_transforms):
            tweened_row_col_transform.seconds_since_release += delta

            if (
                tweened_row_col_transform.seconds_since_release
                >= tweened_row_col_transform.tween_time
            ):
                completed_tween_indexes.append(i)
                random_clink = random.randint(0, NUM_GLASS_CLINKS - 1)
                clink_sound = f"glass_clink_{random_clink}"
                audio_manager.set_sound_volume(
                    clink_sound,
                    min(
                        1.0,
                        abs(tweened_row_col_transform.max_magnitude)
                        / (self.gem_height * 3),
                    ),
                )
                audio_manager.play_sound(clink_sound)

        for i in reversed(completed_tween_indexes):
            self.snapping_row_col_transforms.pop(i)

    def handle_event(self, event) -> bool:
        # If the grid is empty, filling, or emptying, we don't want to process
        # any events for it, and just let it animate.
        if self.grid_state != self.GameGridState.FULL:
            return False

        # Also if we're not accepting inputs, just do nothing. Sometimes when
        # the grid is full, we also don't want to accept inputs. For example,
        # when the grid is full, and the countdown is counting, but the round
        # hasn't started yet.
        if not self.accepting_inputs:
            return False

        if event.type == pygame.MOUSEBUTTONDOWN:
            clicked_in_gem_grid = (
                self.gem_grid_surface.get_rect()
                .move(self.position.x, self.position.y)
                .collidepoint(event.pos)
            )
            if clicked_in_gem_grid:
                self.click_initial_position = Vector2(event.pos)
                self.set_clicked_gem(
                    self.get_clicked_gem_from_mouse_position(event.pos)
                )
                self.mouse_state = self.MouseState.MOUSE_DOWN
                return True
            else:
                return False

        if event.type == pygame.MOUSEBUTTONUP:
            if self.mouse_state == self.MouseState.MOUSE_DOWN:
                self.mouse_state = self.MouseState.MOUSE_UP

                # Get the current move/drag distance and put it into the queue of snapping row/cols
                row_col_transform = self.get_row_col_transform_from_drag_vector(
                    self.grab_distance
                )
                # Get the move action from the current transform.
                move_action = self.get_move_from_row_col_transform(row_col_transform)
                # Get any hypothetical matches from that move action
                matches = self.backend_puzzle_state.get_matches_from_hypothetical_move(
                    move_action
                )

                # If there are matches
                if matches:
                    # Add the move to a list of moves to apply to the backend
                    # all at once when animations have finished
                    self.applied_actions_waiting_for_explosions_to_complete.append(
                        move_action
                    )

                    # Apply the move to the frontend
                    self.frontend_apply_move_actions([move_action])

                    # Add a tweened row col transform to move the row/col from
                    # where it was dropped, to it's new match location.
                    self.snapping_row_col_transforms.append(
                        self.get_magnitude_to_snap_to_currently_hovered_position(
                            row_col_transform
                        )
                    )

                # If there aren't, snap it back to where it was before.
                else:
                    if self.is_valid_row_col_transform_given_snapping_transforms(
                        self.snapping_row_col_transforms, row_col_transform
                    ):
                        self.snapping_row_col_transforms.append(
                            self.TweenedRowColTransform(
                                axis=row_col_transform.axis,
                                index=row_col_transform.index,
                                max_magnitude=row_col_transform.magnitude,
                                seconds_since_release=0.0,
                                tween_time=scale_and_clamp(
                                    self.gem_height * 3,
                                    0.0,
                                    self.MAX_TWEEN_TIME,
                                    self.MAX_TWEEN_TIME / 4,
                                    abs(row_col_transform.magnitude),
                                ),
                            )
                        )

                self.grab_distance = pygame.Vector2(0, 0)
                return True
            else:
                return False

        if event.type == pygame.MOUSEMOTION:
            if self.mouse_state == self.MouseState.MOUSE_DOWN:
                pos = Vector2(event.pos)
                self.grab_distance = pos - self.click_initial_position
                self.grabbed_row_col_transform = (
                    self.get_row_col_transform_from_drag_vector(self.grab_distance)
                )
                return True
            else:
                return False

        return False

    def set_clicked_gem(self, clicked_gem: tuple[int, int]) -> None:
        self.clicked_gem = clicked_gem

    def get_clicked_gem_from_mouse_position(
        self, mouse_pos: tuple[int, int]
    ) -> tuple[int, int]:
        relative_pos = mouse_pos - self.position
        return (
            int(relative_pos[0] // self.gem_width),
            int(relative_pos[1] // self.gem_height),
        )

    def get_row_col_transform_from_drag_vector(
        self, drag_vector: pygame.Vector2
    ) -> RowColTransform:
        angle_in_rads = math.radians(Vector2(1, 0).angle_to(drag_vector))
        directional_scaling_factor = abs(math.cos(angle_in_rads * 2))

        if abs(drag_vector.x) > abs(drag_vector.y):
            return self.RowColTransform(
                axis="row",
                index=self.clicked_gem[1],
                magnitude=drag_vector.x * directional_scaling_factor,
            )
        else:
            return self.RowColTransform(
                axis="col",
                index=self.clicked_gem[0],
                magnitude=drag_vector.y * directional_scaling_factor,
            )

    def apply_row_col_transform_to_gem_positions(
        self,
        gem_positions: list[list[pygame.Vector2]],
        row_col_transform: RowColTransform,
    ) -> list[list[pygame.Vector2]]:
        if row_col_transform.axis == "row":
            gem_positions = self.apply_row_transform(
                gem_positions, row_col_transform.index, row_col_transform.magnitude
            )
        else:
            gem_positions = self.apply_col_transform(
                gem_positions, row_col_transform.index, row_col_transform.magnitude
            )
        return gem_positions

    def apply_col_transform(
        self,
        gem_positions: list[list[pygame.Vector2]],
        col_index: int,
        magnitude: float,
    ) -> list[list[pygame.Vector2]]:
        for y in range(self.grid_height):
            gem_position = gem_positions[col_index][y]
            new_y_position = gem_position.y + magnitude
            wrapped_new_y_position = wrapf(
                new_y_position,
                self.get_gem_default_position_from_grid_coord((col_index, -1)).y
                + self.gem_height / 2,
                self.get_gem_default_position_from_grid_coord(
                    (col_index, self.grid_height - 1)
                ).y
                + self.gem_height / 2,
            )
            gem_position.y = wrapped_new_y_position
        return gem_positions

    def apply_row_transform(
        self,
        gem_positions: list[list[pygame.Vector2]],
        row_index: int,
        magnitude: float,
    ) -> list[list[pygame.Vector2]]:
        for x in range(self.grid_width):
            gem_position = gem_positions[x][row_index]
            new_x_position = gem_position.x + magnitude
            wrapped_new_x_position = wrapf(
                new_x_position,
                self.get_gem_default_position_from_grid_coord((0, row_index)).x
                - self.gem_width / 2,
                self.get_gem_default_position_from_grid_coord(
                    (self.grid_width - 1, row_index)
                ).x
                + self.gem_width / 2,
            )
            gem_position.x = wrapped_new_x_position
        return gem_positions

    def get_move_from_row_col_transform(
        self, row_col_transform: RowColTransform
    ) -> MoveAction:
        row_or_col = row_col_transform.axis
        if row_or_col == "row":
            amount = (
                (row_col_transform.magnitude - (self.gem_width / 2)) // self.gem_width
            ) + 1
        else:
            amount = (
                (row_col_transform.magnitude - (self.gem_height / 2)) // self.gem_height
            ) + 1
            amount *= -1

        return MoveAction(
            row_or_col=row_or_col, index=row_col_transform.index, amount=int(amount)
        )

    @staticmethod
    def get_linear_fraction_to_closest_snap(
        row_col_transform: RowColTransform, gem_width: int, gem_height: int
    ) -> float:
        """
        When you're dragging a col/row, sometimes the col/row you're dragging
        aligns perfectly with the other rows and cols, at other times, it's
        exactly in the middle between rows. This function returns 1 when it's
        exactly in the middle, and 0 when it's perfectly aligned so you can
        animate things based on that.
        """
        if row_col_transform.axis == "row":
            amount = row_col_transform.magnitude % gem_width
            return abs(1 - (abs((gem_width / 2) - amount) / (gem_width / 2)))
        else:
            amount = row_col_transform.magnitude % gem_height
            return abs(1 - (abs((gem_height / 2) - amount) / (gem_height / 2)))

    @staticmethod
    def get_match_line_thickness_from_fraction(fraction: float) -> int:
        """
        Where fraction is a float from 0 (meaning gems are perfectly aligned),
        to 1, meaning gems are not aligned at all, get the line thickness of
        the "match line" to draw between the gems.
        """
        return int(5 * (1 - fraction))

    @staticmethod
    def is_valid_row_col_transform_given_snapping_transforms(
        snapping_row_col_transforms: list[TweenedRowColTransform],
        row_col_transform: RowColTransform,
    ) -> bool:
        """
        You shouldn't be able to drag rows when cols are already snapping,
        because then you'll have one gem out of alignment. Vice-versa for cols
        when rows are snapping too.
        """
        # Because of this rule, all row/col snapping transforms are going to
        # be in the same axis, so we only need to check the first one.
        if snapping_row_col_transforms:
            if snapping_row_col_transforms[0].axis != row_col_transform.axis:
                return False

        # You also can not have multiple row/col transforms to the same row/col
        for snapping_row_col_transform in snapping_row_col_transforms:
            if snapping_row_col_transform.index == row_col_transform.index:
                return False

        return True

    def frontend_apply_move_actions(self, move_actions: list[MoveAction]) -> None:
        """
        Apply the supplied move actions to the frontend gem grid.
        """
        for move_action in move_actions:
            apply_move_to_grid(self.gems, move_action)

    def frontend_handle_explode_and_replace_phase(self) -> None:
        """
        When we submit moves to the backend puzzle and get back an
        ExplodeAndReplacePhase, this kicks off a few things on the frontend
        side.
        """
        explode_and_replace_phase = (
            self.backend_puzzle_state.get_next_explode_and_replace_phase(
                self.applied_actions_waiting_for_explosions_to_complete
            )
        )
        self.applied_actions_waiting_for_explosions_to_complete = []

        if explode_and_replace_phase.is_nothing_to_do():
            self.combo_level = 0
            self.combo_active = False
            return

        # Create and post scoring event
        post_scoring_event(
            ScoreEvent(
                scoring_matches=[
                    (match, self.gems[match[0][0]][match[0][1]].gem_type)
                    for match in explode_and_replace_phase.matches
                ],
                combo_level=self.combo_level,
            )
        )

        # Remove gems from gem grid and insert into the list of exploding gems.
        gems_to_explode = set(
            gem for match in explode_and_replace_phase.matches for gem in match
        )

        self.set_all_gems_above_exploding_gems_to_falling_state(gems_to_explode)

        # Move the gems that are exploding from the gem grid to the explosions list.
        for gem in reversed(sorted(gems_to_explode, key=lambda x: (x[1], x[0]))):
            # and put it in the explosion state
            exploding_gem = self.gems[gem[0]].pop(gem[1])
            exploding_gem.set_exploding()
            self.explosions.append(exploding_gem)
            self.particle_system.create_explosion(
                self.get_gem_default_position_from_grid_coord(gem),
                5,
                exploding_gem.gem_type,
            )

        # Handle combos
        if self.combo_active:
            self.combo_level += 1
        else:
            self.combo_active = True
        audio_manager.play_sound(
            f"combo_sound_{min(self.combo_level, self.MAX_COMBO_LEVEL - 1):02d}"
        )

        # Put replacement gems into the list of falling replacement gems.
        replacement_gems = {
            col: replacement_gem_types
            for col, replacement_gem_types in explode_and_replace_phase.replacements
        }

        # Put the replacement gems into the gem grid, and set their positions
        # to above the grid and their states to falling.
        for col, replacement_gem_types in replacement_gems.items():
            for i, gem_type in enumerate(replacement_gem_types):
                replacement_frontend_gem = FrontendGem(
                    position=self.get_gem_default_position_from_grid_coord(
                        (col, -i - 1)
                    ),
                    gem_assets=self.gem_assets,
                    gem_type=gem_type,
                    grid_width=self.grid_width,
                    grid_height=self.grid_height,
                    gem_width=self.gem_width,
                    gem_height=self.gem_height,
                )
                replacement_frontend_gem.state = FrontendGem.FrontendGemState.FALLING
                self.gems[col].insert(0, replacement_frontend_gem)

    def set_all_gems_above_exploding_gems_to_falling_state(
        self, gems_to_explode: set[tuple[int, int]]
    ) -> None:
        lowest_exploding_gem_from_each_column: dict[int, int] = {}
        for x, y in gems_to_explode:
            lowest_exploding_gem_from_each_column[x] = max(
                lowest_exploding_gem_from_each_column.get(x, -1), y
            )

        for x in range(self.grid_width):
            for y in range(self.grid_height):
                if x in lowest_exploding_gem_from_each_column:
                    if y < lowest_exploding_gem_from_each_column[x]:
                        self.gems[x][y].state = FrontendGem.FrontendGemState.FALLING

    def is_ready_for_next_explode_and_replace_phase(self) -> bool:
        """
        Return True if the frontend is ready to start animating the next
        explode and replace phase.
        """
        full_state = self.grid_state == FrontendPuzzle.GameGridState.FULL

        nothing_falling = not any(
            gem.state == FrontendGem.FrontendGemState.FALLING
            for col in self.gems
            for gem in col
        )

        return full_state and nothing_falling

    def get_magnitude_to_snap_to_currently_hovered_position(
        self, row_col_transform: RowColTransform
    ) -> TweenedRowColTransform:
        """
        When you drag a row/col it creates a RowColTransform. If you drag it to
        a position that results in a match, you want to snap it to that match.
        This function calculates the TweenedRowColTransform that snaps from the
        position you un-clicked, back to the grid. Maybe this illustration will
        show what I mean?

                    ┌──────┬──────┬──────┬──────┬──────┐
                    │  g1  │  g2  │  g3  │  g4  │  g5  │
                                  ◄───────────────
                                ─►   Original Drag
                          Generated Tween
        """
        if row_col_transform.axis == "row":
            magnitude = self.gem_width / 2 - (
                row_col_transform.magnitude % self.gem_width
            )

        else:
            magnitude = self.gem_height / 2 - (
                row_col_transform.magnitude % self.gem_height
            )

        if magnitude < 0:
            magnitude = -15 - magnitude
        else:
            magnitude = 15 - magnitude

        return self.TweenedRowColTransform(
            axis=row_col_transform.axis,
            index=row_col_transform.index,
            max_magnitude=magnitude,
            seconds_since_release=0.0,
            tween_time=scale_and_clamp(
                self.gem_height * 3,
                0.0,
                self.MAX_TWEEN_TIME,
                self.MAX_TWEEN_TIME / 4,
                abs(row_col_transform.magnitude),
            ),
        )

    def pause_frontend_puzzle(self) -> None:
        self.pause_state = FrontendPuzzle.GameGridPauseState.PAUSED

    def resume_frontend_puzzle(self) -> None:
        self.pause_state = FrontendPuzzle.GameGridPauseState.ACTIVE

    def get_frontend_puzzle_state(self) -> GameGridPauseState:
        return self.pause_state

    def toggle_frontend_puzzle_state(self) -> None:
        if self.pause_state == FrontendPuzzle.GameGridPauseState.PAUSED:
            self.pause_state = FrontendPuzzle.GameGridPauseState.ACTIVE
        else:
            self.pause_state = FrontendPuzzle.GameGridPauseState.PAUSED

    def fill_grid(self) -> None:
        if self.grid_state != FrontendPuzzle.GameGridState.EMPTY:
            raise Exception(
                "You should only fill the grid when its empty. We shouldn't ever get here."
            )

        # Reset the backend gem state so we get a fresh new frontend grid
        # every time we fill the grid.
        self.backend_puzzle_state.reset()
        self.grid_state = self.GameGridState.TRANSITIONING_TO_FULL
        self.transition_timer = 0.0
        self.gems = self.get_frontend_gems()

        for x in range(self.grid_width):
            for y in range(self.grid_height):
                gem_num = x * self.grid_width - y + self.grid_height
                self.gems[x][y].position.y -= self.gem_height * self.grid_height
                self.gems[x][y].state = FrontendGem.FrontendGemState.FALLING
                self.gems[x][y].velocity = pygame.Vector2(0, -gem_num * 10)

    def get_frontend_gems(self) -> list[list[FrontendGem]]:
        """
        Create a 2D array of frontend gems and return it.
        """
        gems = []
        for x in range(self.grid_width):
            row = []
            for y in range(self.grid_height):
                frontend_gem = FrontendGem(
                    position=pygame.Vector2(
                        x * self.gem_width,
                        y * self.gem_height,
                    ),
                    gem_assets=self.gem_assets,
                    gem_type=self.backend_puzzle_state.puzzle_state[x][y].gem_type,
                    grid_height=self.grid_height,
                    grid_width=self.grid_width,
                    gem_height=self.gem_height,
                    gem_width=self.gem_width,
                )
                row.append(frontend_gem)
            gems.append(row)
        return gems

    def empty_grid(self) -> None:
        if self.grid_state != FrontendPuzzle.GameGridState.FULL:
            raise Exception(
                "You should only empty the grid when its full. We shouldn't ever get here."
            )

        self.grid_state = self.GameGridState.TRANSITIONING_TO_EMPTY
        self.transition_timer = 0.0

    def process_transition_to_empty_animation(self, delta: float) -> None:
        # Increment the timer
        self.transition_timer += delta

        # Set rows to falling one at a time
        rows_to_set_to_falling = int(self.transition_timer / 0.1)
        for x in range(min(self.grid_width, rows_to_set_to_falling)):
            for y in range(self.grid_height):
                self.gems[x][y].state = FrontendGem.FrontendGemState.FALLING

        # If all the rows are below the screen, set the state to empty.
        if all(
            gem.position.y >= ((self.grid_height + 1) * self.gem_height)
            for gem_col in self.gems
            for gem in gem_col
        ):
            self.gems = []
            self.grid_state = FrontendPuzzle.GameGridState.EMPTY

    def set_accepting_inputs(self, is_accepting_inputs: bool) -> None:
        self.accepting_inputs = is_accepting_inputs
</file>

<file path="common/match3/gem_assets.py">
import os

import pygame

from common.file_helpers import get_gems_directory
from common.match3.gem_types import GemTypes


class GemAssets:
    def __init__(self) -> None:
        self.gem_frames: dict[GemTypes, list[pygame.Surface]] = {}

        for gem_type in GemTypes:
            gem_type_frames: list[pygame.Surface] = []
            for i in range(8):
                gem_type_frames.append(
                    pygame.image.load(
                        os.path.join(
                            get_gems_directory(),
                            f"{gem_type.name.lower()}_gem_{i}.png",
                        )
                    )
                )
            self.gem_frames[gem_type] = gem_type_frames

    def get_gem_frames(self, gem_type: GemTypes) -> list[pygame.Surface]:
        return self.gem_frames[gem_type]
</file>

<file path="common/match3/gem_types.py">
import random
from enum import Enum, auto

import pygame


class GemTypes(Enum):
    BLUE = auto()
    GREEN = auto()
    RED = auto()
    BLACK = auto()
    ORANGE = auto()
    WHITE = auto()

    @classmethod
    def get_color_from_gem_type(cls, gem_type: "GemTypes") -> pygame.Color:
        return {
            GemTypes.BLUE: pygame.Color(77, 155, 230),
            GemTypes.GREEN: pygame.Color(30, 188, 115),
            GemTypes.RED: pygame.Color(240, 79, 120),
            GemTypes.BLACK: pygame.Color(46, 34, 47),
            GemTypes.ORANGE: pygame.Color(249, 194, 43),
            GemTypes.WHITE: pygame.Color(255, 255, 255),
        }[gem_type]

    @classmethod
    def get_random_gem_type(cls) -> "GemTypes":
        return random.choice([x for x in cls])
</file>

<file path="common/match3/gem.py">
import random
from enum import Enum, auto

import pygame
from pygame import Surface, Vector2

from common.assets.sounds.rock_clacks import NUM_ROCK_CLACKS_SOUNDS
from common.managers.managers import audio_manager
from common.match3.gem_assets import GemAssets
from common.match3.gem_types import GemTypes


class FrontendGem:

    ANIMATION_FPS = 30

    class FrontendGemState(Enum):
        IDLE = auto()
        FALLING = auto()
        EXPLODING = auto()

    def __init__(
        self,
        position: Vector2,
        gem_assets: GemAssets,
        gem_type: GemTypes,
        grid_width: int,
        grid_height: int,
        gem_width: int,
        gem_height: int,
    ) -> None:
        self.position = position
        self.gem_type = gem_type
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.gem_width = gem_width
        self.gem_height = gem_height
        self.state = self.FrontendGemState.IDLE

        # To handle movement when falling
        self.acceleration = pygame.Vector2(0, 1000)
        self.velocity = pygame.Vector2(0, 0)

        self.gem_frames = gem_assets.get_gem_frames(self.gem_type)
        self.frame_index = 0
        self.exploding_time = 0.0
        self.explosion_finished = False

    def process(self, delta: float) -> None:
        if self.state == self.FrontendGemState.IDLE:
            pass
        elif self.state == self.FrontendGemState.FALLING:
            self.process_falling(delta)
        elif self.state == self.FrontendGemState.EXPLODING:
            self.process_exploding(delta)

    def render(self, screen: Surface) -> None:
        screen.blit(self.gem_frames[self.frame_index], self.position)

        # Only draw fake wrap around gems when in an idle state. We don't want
        # wrap exploding gems, and when gems are falling, they're either being
        # spawned in from offscreen, or they're falling from ON the screen and
        # will never wrap.
        if self.state != self.FrontendGemState.IDLE:
            return

        if self.position.x < 0:
            screen.blit(
                self.gem_frames[self.frame_index],
                self.position + Vector2(self.grid_width * self.gem_width, 0),
            )
        if self.position.x > self.gem_width * (self.grid_width - 1):
            screen.blit(
                self.gem_frames[self.frame_index],
                self.position - Vector2(self.grid_width * self.gem_width, 0),
            )
        if self.position.y < 0:
            screen.blit(
                self.gem_frames[self.frame_index],
                self.position + Vector2(0, self.grid_height * self.gem_height),
            )
        if self.position.y > self.gem_height * (self.grid_height - 1):
            screen.blit(
                self.gem_frames[self.frame_index],
                self.position - Vector2(0, self.grid_height * self.gem_height),
            )

    @property
    def center(self) -> Vector2:
        center_x = self.position.x + self.gem_width / 2
        center_y = self.position.y + self.gem_height / 2
        return Vector2(center_x, center_y)

    def process_falling(self, delta: float) -> None:
        self.velocity += self.acceleration * delta
        self.position += self.velocity * delta

    def stop_falling(self) -> None:
        self.velocity = pygame.Vector2(0, 0)
        self.state = self.FrontendGemState.IDLE
        audio_manager.play_sound(
            f"rocks_clacking_{random.randint(0, NUM_ROCK_CLACKS_SOUNDS-1):02d}"
        )

    def set_exploding(self) -> None:
        self.state = self.FrontendGemState.EXPLODING
        self.exploding_time = 0.0

    def process_exploding(self, delta: float) -> None:
        self.exploding_time += delta
        frame = int(self.exploding_time / (1 / self.ANIMATION_FPS))
        if frame > len(self.gem_frames):
            self.explosion_finished = True
        self.frame_index = min(frame, len(self.gem_frames) - 1)

    def is_explosion_finished(self) -> bool:
        return self.explosion_finished
</file>

<file path="common/match3/helpers.py">
"""
A collection of helpers used in multiple places in the puzzle grid.
"""

from typing import Any

from common.match3.player_actions import MoveAction


def apply_move_to_grid(
    grid: list[list[Any]], move_action: MoveAction
) -> list[list[Any]]:
    """
    Given any grid object (list of lists) mutates it to apply a move.
    """
    if move_action.row_or_col == "row":
        width = len(grid)
        amount = move_action.amount % width
        row = [grid[x][move_action.index] for x in range(width)]
        row = row[-amount:] + row[:-amount]
        for x in range(width):
            grid[x][move_action.index] = row[x]
    if move_action.row_or_col == "col":
        height = len(grid[0])
        amount = move_action.amount % height
        grid[move_action.index] = (
            grid[move_action.index][amount:] + grid[move_action.index][:amount]
        )
    return grid
</file>

<file path="common/match3/player_actions.py">
import dataclasses
from typing import Literal


@dataclasses.dataclass
class MoveAction:
    row_or_col: Literal["row", "col"]
    index: int
    amount: int
</file>

<file path="common/constants.py">
SCREEN_WIDTH = 1920 / 4  # 480
SCREEN_HEIGHT = 1080 / 4  # 270
</file>

<file path="common/file_helpers.py">
import os


def get_repo_root() -> str:
    # Get the full path of the current file
    current_file_path = os.path.abspath(__file__)

    # Get the directory name of the current file
    current_directory = os.path.dirname(current_file_path)

    return os.path.abspath(os.path.join(current_directory, ".."))


def get_game_directory() -> str:
    return os.path.join(get_repo_root(), "common")


def get_assets_directory() -> str:
    return os.path.join(get_game_directory(), "assets")


def get_sounds_directory() -> str:
    return os.path.join(get_assets_directory(), "sounds")


def get_fonts_directory() -> str:
    return os.path.join(get_assets_directory(), "fonts")


def get_cards_directory() -> str:
    return os.path.join(get_assets_directory(), "cards")


def get_sprites_directory() -> str:
    return os.path.join(get_assets_directory(), "sprites")


def get_gems_directory() -> str:
    return os.path.join(get_sprites_directory(), "gems")
</file>

<file path="common/helpers.py">
from collections import deque
from typing import Callable


class Tweener:
    """
    An object to handle everything tweening.
    """

    def __init__(
        self,
        start_value: float,
        end_value: float,
        duration_seconds: float,
        tween_function: None | Callable[[float], float] = None,
    ):
        """
        A tweener object for tweening things. Stores the state of the tween
        and updates itself each frame.
        """
        self.start_value = start_value
        self.end_value = end_value
        self.duration = duration_seconds
        if tween_function is not None:
            self.tween_function = tween_function
        else:
            self.tween_function = lambda x: x

        self.elapsed = 0
        self.value = end_value
        self.finished = True

    def update(self, delta_time: float) -> None:
        if self.finished:
            return

        self.elapsed += delta_time
        if self.elapsed >= self.duration:
            self.elapsed = self.duration
            self.finished = True

        t = self.elapsed / self.duration
        self.value = self.tween_function(
            self.start_value + (self.end_value - self.start_value) * t
        )
        return self.value

    def start(
        self,
        start_value: None | float = None,
        end_value: None | float = None,
        duration_seconds: None | float = None,
    ) -> None:
        """
        This starts the tween if it's not currently running. It restarts it if
        it is. If any of the optional parameters are specified, then they
        replace the current values for start/end/duration.
        """
        self.finished = False
        self.elapsed = 0

        if start_value is not None:
            self.start_value = start_value
        if end_value is not None:
            self.end_value = end_value
        if duration_seconds is not None:
            self.duration_seconds = duration_seconds

    def get_value(self) -> float:
        return self.value

    def is_finished(self) -> bool:
        return self.finished


class MovingAverage:
    def __init__(self, size: int):
        self.size = size
        self.queue = deque(maxlen=size)
        self.sum = 0

    def add(self, value: float) -> None:
        if len(self.queue) == self.size:
            self.sum -= self.queue[0]
        self.queue.append(value)
        self.sum += value

    def average(self) -> float:
        if not self.queue:
            return 0
        return self.sum / len(self.queue)


def wrapf(value: float, min_value: float, max_value: float):
    range_size = max_value - min_value
    wrapped_value = (value - min_value) % range_size + min_value
    return wrapped_value if wrapped_value != max_value else min_value


def clamp(value, minimum, maximum):
    return max(minimum, min(value, maximum))


def scale_and_clamp(
    in_a: float, in_b: float, out_a: float, out_b: float, value: float
) -> float:
    if in_a == in_b:
        raise ValueError("Both inputs cannot be the same value")

    # Scale the value
    scaled_value = ((value - in_a) / (in_b - in_a)) * (out_b - out_a) + out_a

    # Clamp the value within the output range
    clamped_value = clamp(scaled_value, min(out_a, out_b), max(out_a, out_b))

    return clamped_value
</file>

<file path="examples/1_cards/example.py">
import os
import random
from enum import Enum, auto

import cv2
import numpy as np
import pygame
import pytweening

from common.assets.fonts import M5X7
from common.constants import SCREEN_HEIGHT, SCREEN_WIDTH
from common.file_helpers import get_cards_directory, get_sounds_directory
from common.helpers import MovingAverage, Tweener
from common.managers.managers import audio_manager, font_manager


class Card:

    TIME_TO_SNAP_TO_CURSOR_ON_PICKUP = 0.2  # Seconds
    MAX_CARD_ROTATION = 50  # Degrees

    class CardState(Enum):
        IDLE = auto()
        GRABBED = auto()

    def __init__(
        self,
        position: pygame.Vector2,
        size: pygame.Vector2,
        background_surface: pygame.Surface,
    ) -> None:
        self.position = position
        self.size = size
        self.background_surface = background_surface

        self.state = self.CardState.IDLE
        self.card_goal_position: pygame.Vector2 = position
        self.card_pickup_position: pygame.Vector2 = pygame.Vector2(0, 0)
        self.tweener_snap_to_mouse = Tweener(
            1.0, 0.0, self.TIME_TO_SNAP_TO_CURSOR_ON_PICKUP, pytweening.easeInCubic
        )
        self.average_velocity_x = MovingAverage(size=10)
        self.average_velocity_y = MovingAverage(size=10)
        self.velocity: pygame.Vector2 = pygame.Vector2(0, 0)

        self.points = np.array(
            [
                [-self.size.x / 2, self.size.y / 2, 0],
                [self.size.x / 2, self.size.y / 2, 0],
                [self.size.x / 2, -self.size.y / 2, 0],
                [-self.size.x / 2, -self.size.y / 2, 0],
            ]
        )
        self.card_rotation = pygame.Vector2(0, 0)

        self.surface = pygame.Surface(self.size)

    def render(self, screen: pygame.Surface, delta: float) -> None:
        self.update_position_and_velocity(delta)
        self.update_card_rotation(delta)

        self.surface.fill("purple")
        self.surface.blit(self.background_surface, (0, 0))

        points = self.get_screen_coord_points()

        self.blit_perspective_transformed_card_surface(screen, points)
        self.blit_card_outline(screen, points)

    def update_position_and_velocity(self, delta: float) -> None:
        # Update tweener
        self.tweener_snap_to_mouse.update(delta)

        # Get new position
        if self.tweener_snap_to_mouse.is_finished():
            new_position = self.card_goal_position
        else:
            new_position = self.card_goal_position - (
                (self.tweener_snap_to_mouse.get_value())
                * (self.card_goal_position - self.card_pickup_position)
            )

        # Calculate velocity based on an average of the last few position
        # changes. I only do this because using instantaneous position is super
        # jerky because it's essentially zero except the frame/subframe when a
        # mouse event is received.
        self.average_velocity_x.add((new_position.x - self.position.x) / delta)
        self.average_velocity_y.add((new_position.y - self.position.y) / delta)
        x_velocity = self.average_velocity_x.average()
        y_velocity = self.average_velocity_y.average()

        # If the velocity is below a threshold, snap it to 0. This stops float
        # errors where the velocity just stays at 1e-13 or something instead of
        # returning to zero, and the card looks rotated at rest.
        VELOCITY_EPSILON = 1
        self.velocity = pygame.Vector2(
            x_velocity if abs(x_velocity) > VELOCITY_EPSILON else 0,
            y_velocity if abs(y_velocity) > VELOCITY_EPSILON else 0,
        )

        # Set position
        self.position = new_position

    def update_card_rotation(self, delta: float) -> None:
        card_rotation_vector = pygame.Vector2(
            -self.velocity.x / 15, self.velocity.y / 15
        )

        ROTATION_EPSILON = 4
        # Rotations below this magnitude are snapped to zero because tiny
        # rotations stop us aligning cards nicely when moving cards around
        # slowly.
        if card_rotation_vector.magnitude() < ROTATION_EPSILON:
            card_rotation_vector = pygame.Vector2(0, 0)
        elif card_rotation_vector.magnitude() > self.MAX_CARD_ROTATION:
            card_rotation_vector = card_rotation_vector / (
                card_rotation_vector.magnitude() / self.MAX_CARD_ROTATION
            )

        self.card_rotation_degrees_y = card_rotation_vector.x
        self.card_rotation_degrees_x = card_rotation_vector.y

    @staticmethod
    def get_bounding_box_dimensions(points: np.ndarray) -> tuple[int, int]:
        if points.size == 0:
            return 0, 0

        min_x = np.min(points[:, 0])
        max_x = np.max(points[:, 0])
        min_y = np.min(points[:, 1])
        max_y = np.max(points[:, 1])

        width = max_x - min_x
        height = max_y - min_y

        return int(width), int(height)

    def rotate_points(
        self, points: list[np.ndarray], degrees_x: float, degrees_y: float
    ) -> np.ndarray:
        # Convert angles from degrees to radians
        degrees_x = np.radians(degrees_x)
        degrees_y = np.radians(degrees_y)

        # Rotation matrix around the x-axis
        Rx = np.array(
            [
                [1, 0, 0],
                [0, np.cos(degrees_x), -np.sin(degrees_x)],
                [0, np.sin(degrees_x), np.cos(degrees_x)],
            ]
        )

        # Rotation matrix around the y-axis
        Ry = np.array(
            [
                [np.cos(degrees_y), 0, np.sin(degrees_y)],
                [0, 1, 0],
                [-np.sin(degrees_y), 0, np.cos(degrees_y)],
            ]
        )

        # Apply the rotations
        rotated_points = []
        for point in points:
            rotated_point = np.dot(Rx, point)
            rotated_point = np.dot(Ry, rotated_point)
            rotated_points.append(rotated_point)

        return np.array(rotated_points)

    def perspective_projection(self, points: np.ndarray, d: float) -> np.ndarray:
        projected_points = []
        for point in points:
            x, y, z = point
            x_p = x * d / (z + d)
            y_p = y * d / (z + d)
            projected_points.append([x_p, y_p])

        return np.array(projected_points)

    def get_screen_coord_points(self) -> np.ndarray:
        points = []
        rotated_points = self.rotate_points(
            self.points, self.card_rotation_degrees_x, self.card_rotation_degrees_y
        )
        projected_points = self.perspective_projection(rotated_points, 150)
        for point in projected_points:
            points.append([point[0], point[1]])
        return np.array(points)

    def calculate_perspective_transform(
        self, src: np.ndarray, dst: np.ndarray
    ) -> np.ndarray:
        """
        Calculate the perspective transform matrix from src to dst points.

        Parameters:
        src (numpy.ndarray): Source points, shape (4, 2).
        dst (numpy.ndarray): Destination points, shape (4, 2).

        Returns:
        numpy.ndarray: The perspective transformation matrix, shape (3, 3).
        """

        src_copy = src[:, :2].copy()
        src_copy += np.array([self.size.x / 2, self.size.y / 2])

        dst_copy = dst.copy()
        min_values = dst_copy.min(axis=0)

        dst_copy -= min_values

        return cv2.getPerspectiveTransform(
            src_copy.astype(np.float32), dst_copy.astype(np.float32)
        )

    def blit_perspective_transformed_card_surface(
        self, surface: pygame.Surface, points: np.ndarray
    ) -> None:
        # Calculate the transform matrix required to transform the surface.
        transform = self.calculate_perspective_transform(self.points, points)

        transformed_surface = self.apply_perspective_transform(
            self.surface,
            transform,
            self.get_bounding_box_dimensions(points),
        )

        # Transform the top left point so we know the end location of the top left point.
        top_left_point = np.array([0, 0])
        top_left = self.transform_point(top_left_point, transform)

        surface.blit(
            transformed_surface,
            self.position - top_left + points[3],
        )

    def blit_card_outline(self, surface: pygame.Surface, points: np.ndarray) -> None:
        # Iterate through pairs including the wrap-around pair
        modified_points = points.tolist()
        modified_points[0][1] -= 1
        modified_points[1][0] -= 1
        modified_points[1][1] -= 1
        modified_points[2][0] -= 1
        for i in range(len(modified_points)):
            a, b = (modified_points[i], modified_points[(i + 1) % len(modified_points)])

            pygame.draw.line(
                surface,
                pygame.Color(0, 0, 0, 100),
                a + self.position,
                b + self.position,
                1,
            )

    def apply_perspective_transform(
        self, surface: pygame.Surface, matrix: np.ndarray, dst_size: tuple[int, int]
    ) -> pygame.Surface:
        """
        Apply a perspective transform to a Pygame surface using a transformation matrix.

        Parameters:
        surface (pygame.Surface): The source Pygame surface.
        matrix (numpy.ndarray): The 3x3 transformation matrix.
        dst_size (tuple): The size of the output surface (width, height).

        Returns:
        pygame.Surface: The transformed Pygame surface.
        """
        # Convert Pygame surface to numpy array
        src_array = pygame.surfarray.array3d(surface)

        # Swap axes to match OpenCV format
        src_array = np.swapaxes(src_array, 0, 1)

        x = np.zeros((src_array.shape[0], src_array.shape[1], 4), dtype=np.uint8)
        x += 255
        x[:, :, :3] = src_array

        # Apply perspective warp using OpenCV
        dst_array = cv2.warpPerspective(
            x,
            matrix.astype(float),
            dst_size,
            flags=cv2.INTER_NEAREST,
        )

        a = np.ascontiguousarray(dst_array)
        return pygame.image.frombuffer(a.tobytes(), a.shape[1::-1], "RGBA")

    def transform_point(self, point: np.ndarray, matrix: np.ndarray) -> np.ndarray:
        """
        Transform a single point using the perspective transformation matrix.

        Parameters:
        point (numpy.ndarray): The point to transform, shape (1, 2).
        matrix (numpy.ndarray): The 3x3 transformation matrix.

        Returns:
        numpy.ndarray: The transformed point, shape (1, 2).
        """
        point = np.array([[point]], dtype=np.float32)  # Shape (1, 1, 2)
        transformed_point = cv2.perspectiveTransform(point, matrix)
        return transformed_point[0][0]

    def get_clickable_rect(self) -> pygame.Rect:
        """
        Get the rect of the card where a click in the rect counts as a click
        on the card.
        """
        return pygame.rect.Rect(
            self.position[0] - self.size.x / 2,
            self.position[1] - self.size.y / 2,
            self.size.x,
            self.size.y,
        )

    def process_events(self, event: pygame.event.Event) -> bool:
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.get_clickable_rect().collidepoint(event.pos):
                if self.state == self.CardState.IDLE:
                    self.transition_to_grabbed(event)
                    return True

        if event.type == pygame.MOUSEMOTION:
            if self.state == self.CardState.GRABBED:
                self.card_goal_position = pygame.Vector2(event.pos)
                return True

        if event.type == pygame.MOUSEBUTTONUP:
            if self.state == self.CardState.GRABBED:
                self.transition_to_idle()
                return True

        return False

    def transition_to_grabbed(self, event: pygame.event.Event) -> None:
        self.card_pickup_position = self.position
        self.card_goal_position = pygame.Vector2(event.pos)
        self.state = self.CardState.GRABBED
        audio_manager.play_sound("card_sound_5")
        self.tweener_snap_to_mouse.start()

    def transition_to_idle(self) -> None:
        self.state = self.CardState.IDLE
        audio_manager.play_sound("card_sound_4")


class CardController:
    def __init__(self, surface: pygame.Surface) -> None:
        self.surface = surface
        self.cards: list[Card] = []

    def add_card(self, card: Card) -> None:
        self.cards.append(card)

    def render(self, surface: pygame.surface, delta: float) -> None:
        for card in reversed(self.cards):
            card.render(surface, delta)

    def process_event(self, event: pygame.event.Event) -> bool:
        for i, card in enumerate(self.cards):
            if card.process_events(event):
                self.cards.insert(0, self.cards.pop(i))
                return True


class Particle:
    def __init__(
        self,
        x: float,
        y: float,
        radius: int,
        color: pygame.Color,
        speed: float,
        lifespan: float,
    ):
        self.x = x
        self.y = y
        self.radius = radius
        self.color = color
        self.speed = speed
        self.lifespan = lifespan
        self.age = 0.0

    def update(self, delta):
        self.y += self.speed * delta
        self.age += delta

    def draw(self, screen):
        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.radius)


class ParticleSystem:
    def __init__(self, x: float, y: float, colours: list[pygame.Color]):
        self.x = x
        self.y = y
        self.particles: list[Particle] = []
        self.spawn_rate = 20
        self.time_since_last_spawn = 0.0
        self.colours = colours

    def update(self, delta: float):
        self.time_since_last_spawn += delta
        # Spawn new particles
        if self.time_since_last_spawn >= 1.0 / self.spawn_rate:
            self.time_since_last_spawn -= 1.0 / self.spawn_rate
            self.particles.append(self.create_particle())

        # Update existing particles
        for particle in self.particles:
            particle.update(delta)
            if particle.age >= particle.lifespan:
                self.particles.remove(particle)

    def create_particle(self):
        radius = random.randint(2, 10)
        color = random.choice(self.colours)
        speed = random.uniform(50, 100)
        lifespan = 3
        return Particle(
            self.x + random.randint(0, 60),
            self.y - radius,
            radius,
            color,
            speed,
            lifespan,
        )

    def render(self, surface: pygame.Surface):
        for particle in self.particles:
            particle.draw(surface)


class AnimatedBackground:

    DARK = pygame.Color(91, 110, 225)
    LIGHT = pygame.Color(99, 155, 255)
    WHITE = pygame.Color(255, 255, 255)

    def __init__(self, size: tuple[int, int]) -> None:
        self.size = size
        self.surface = pygame.surface.Surface(size)
        self.particle_system = ParticleSystem(0, 0, [self.DARK, self.LIGHT, self.WHITE])

    def render(self, delta: float) -> None:
        self.surface.fill(self.WHITE)
        self.particle_system.update(delta)
        self.particle_system.render(self.surface)

    def get_surface(self) -> pygame.Surface:
        return self.surface


def main() -> None:
    pygame.init()
    pygame.display.set_caption(
        "Card Demo",
    )

    font_manager.load_font("main_font", M5X7, 16)
    audio_manager.load_sound(
        "card_sound_4",
        os.path.join(get_sounds_directory(), "card_sounds", "card_sound_4.wav"),
    )
    audio_manager.load_sound(
        "card_sound_5",
        os.path.join(get_sounds_directory(), "card_sounds", "card_sound_5.wav"),
    )
    audio_manager.set_sound_volume("card_sound_4", 0.5)
    audio_manager.set_sound_volume("card_sound_5", 0.5)

    screen = pygame.display.set_mode(
        (SCREEN_WIDTH, SCREEN_HEIGHT),
        flags=pygame.RESIZABLE | pygame.SCALED,
    )

    game_clock = pygame.time.Clock()

    card_background = pygame.image.load(
        os.path.join(get_cards_directory(), "card_1.png")
    )
    card_2_background = pygame.image.load(
        os.path.join(get_cards_directory(), "card_2.png")
    )
    card_3_background = pygame.image.load(
        os.path.join(get_cards_directory(), "card_3.png")
    )
    animated_background = AnimatedBackground((60, 90))

    card = Card(
        position=pygame.Vector2(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2),
        background_surface=card_background,
        size=pygame.Vector2(60, 90),
    )
    card2 = Card(
        position=pygame.Vector2(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2),
        background_surface=card_2_background,
        size=pygame.Vector2(60, 90),
    )
    card3 = Card(
        position=pygame.Vector2(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2),
        background_surface=card_3_background,
        size=pygame.Vector2(60, 90),
    )
    card4 = Card(
        position=pygame.Vector2(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2),
        background_surface=animated_background.get_surface(),
        size=pygame.Vector2(60, 90),
    )
    card5 = Card(
        position=pygame.Vector2(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2),
        background_surface=card_background,
        size=pygame.Vector2(45, 30),
    )

    card_controller = CardController(screen)
    card_controller.add_card(card)
    card_controller.add_card(card2)
    card_controller.add_card(card3)
    card_controller.add_card(card4)
    card_controller.add_card(card5)

    time = 0

    running = True
    while True:

        delta_ms = game_clock.tick(144)
        delta = delta_ms / 1000
        time += delta

        animated_background.render(delta)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                break

            card_controller.process_event(event)

        screen.fill("white")

        card_controller.render(screen, delta)

        pygame.display.flip()

        if not running:
            break

    pygame.quit()


main()
</file>

<file path="examples/2_match_three/example.py">
import pygame

from common.assets.fonts import M5X7
from common.managers.managers import font_manager
from common.match3.frontend_puzzle import FrontendPuzzle

SCREEN_WIDTH = int(240)
SCREEN_HEIGHT = int(270)


def game_loop() -> None:
    pygame.init()

    screen = pygame.display.set_mode(
        (SCREEN_WIDTH, SCREEN_HEIGHT),
        flags=pygame.RESIZABLE | pygame.SCALED,
    )

    game_clock = pygame.time.Clock()

    font_manager.load_font("main_font", M5X7, 16)

    frontend_grid = FrontendPuzzle(
        position=pygame.Vector2(15, 15),
        grid_width=7,
        grid_height=8,
        initial_state="full",
    )

    event_handling_functions = [
        frontend_grid.handle_event,
    ]

    running = True
    while True:

        screen.fill("black")

        delta_ms = game_clock.tick(144)
        delta = delta_ms / 1000

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                break

            for event_handler in event_handling_functions:
                event_consumed = event_handler(event)
                if event_consumed:
                    break

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    frontend_grid.toggle_frontend_puzzle_state()

        # Process everything
        frontend_grid.process(delta)

        # Render everything
        frontend_grid.render(screen)

        pygame.display.flip()

        if not running:
            break

    pygame.quit()


if __name__ == "__main__":
    game_loop()
</file>

<file path=".gitignore">
.venv
.vscode
__pycache__
*.egg-info
</file>

<file path=".pre-commit-config.yaml">
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v2.3.0
    hooks:
      - id: check-yaml
      - id: end-of-file-fixer
      - id: trailing-whitespace
  - repo: local
    hooks:
      - id: black
        name: black
        entry: black
        language: system
        types: [python]
        args: ["--line-length=88"]
        files: \.py$
  - repo: local
    hooks:
      - id: isort
        name: isort
        entry: isort
        language: system
        types: [python]
        args: ["--profile", "black"]
        files: \.py$
</file>

<file path="pyproject.toml">
[project]
name = "pygame_examples"
version = "0.1.0"
description = "An example PyGame game."
authors = [{ name = "John Scolaro", email = "johnscolaro95@gmail.com" }]
readme = "README.md"
requires-python = ">=3.12"
classifiers = [
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.12",
]
dependencies = [
    "pygame-ce==2.4.1",
    "pytweening==1.2.0",
    "opencv-python==4.10.0.84"
]

[project.optional-dependencies]
dev = ["pytest==8.2.1", "isort==5.13.2", "black==24.4.2", "pre-commit==3.7.1"]

[tool.black]
line-length = 88
target-version = ['py312']

[tool.isort]
profile = "black"
</file>

<file path="README.md">
# Pygame Examples

This repo contains examples of some things I've made in Pygame that I think are cool. These examples have been moved from a private repo containing far more code that I don't want to share. Consequently, if you think "This code should be split into multiple files", or "There are no tests?", rest assured that this code is in a much better state somewhere else.

## Setup

How to run the examples:

1. Create a virtual environment for this repository.
2. Install the current repository as a package in your environment with: `pip install -e .`.
3. Run the desired example: `python examples/1_cards/example.py`.
</file>

</files>
