This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-07-04T20:05:10.789Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.claude/
  settings.local.json
.github/
  workflows/
    claude.yml
scripts/
  copy-cesium-assets.js
src/
  components/
    ui/
      button.tsx
      card.tsx
      dialog.tsx
      menubar.tsx
      scroll-area.tsx
      separator.tsx
      sheet.tsx
    CesiumMap.tsx
    ClueDisplay.tsx
    ClueSheet.tsx
    DenseClueGrid.tsx
    GemLegend.tsx
    GemLegendDialog.tsx
    HabitatLegend.tsx
    SpeciesHeaderCard.tsx
    SpeciesPanel.old.tsx
    SpeciesPanel.tsx
  config/
    habitatColors.ts
  game/
    scenes/
      Boot.ts
      Game.ts
      GameOver.ts
      MainMenu.ts
      Preloader.ts
    BackendPuzzle.ts
    BoardView.ts
    clueConfig.ts
    constants.ts
    EventBus.ts
    ExplodeAndReplacePhase.ts
    gemCategoryMapping.ts
    main.ts
    MoveAction.ts
  lib/
    speciesService.ts
    supabaseClient.ts
    utils.ts
  pages/
    _app.tsx
    _document.tsx
    highscores.tsx
    index.tsx
  styles/
    globals.css
  types/
    database.ts
  utils/
    config.ts
  App.tsx.template-backup
  global.d.ts
  MainAppLayout.tsx
  PhaserGame.tsx
.editorconfig
.env.example
.env.local.example
.eslintrc.json
.gitignore
BOARD_POSITION_FIX.md
CLUE_BOARD_IMPLEMENTATION.md
CLUE_DISPLAY_COMPONENT_SPEC.md
components.json
DATABASE_USER_GUIDE.md
GAME_REACTIVITY_GUIDE.md
LICENSE
log.js
MAP_MINIMIZE_IMPLEMENTATION.md
next.config.mjs
package.json
postcss.config.js
README.md
SHADCN_IMPLEMENTATION_GUIDE.md
supabase_location_query_function.sql
supabase_spatial_function.sql
supabase-mcp-config.json
tailwind.config.js
tsconfig.json
UI_DISPLAY_SYSTEM_REFERENCE.md
vercel.json

================================================================
Files
================================================================

================
File: .claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(git:*)",
      "Bash(npm:*)",
      "Bash(node:*)",
      "Bash(npx:*)",
      "Bash(grep:*)",
      "Bash(rm:*)",
      "Bash(find:*)",
      "Bash(ls:*)",
      "Bash(curl:*)",
      "Bash(timeout 15s npm run build-nolog)",
      "Bash(timeout:*)",
      "Bash(pkill:*)",
      "Bash(rg:*)",
      "WebFetch(domain:context7.com)",
      "Bash(Check for .env.example file)",
      "Bash(tree:*)",
      "WebFetch(domain:azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net)",
      "mcp__context7__get-library-docs",
      "mcp__context7__resolve-library-id",
      "Bash(claude mcp:*)",
      "WebFetch(domain:rexrainbow.github.io)",
      "mcp__snap-happy__TakeScreenshot",
      "mcp__snap-happy__GetLastScreenshot",
      "mcp__supabase__list_edge_functions",
      "WebFetch(domain:v0.dev)",
      "WebFetch(domain:github.com)"
    ],
    "deny": []
  }
}

================
File: .github/workflows/claude.yml
================
name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}

================
File: scripts/copy-cesium-assets.js
================
const fs = require('fs');
const path = require('path');

/**
 * Recursively copy directory contents
 * Fallback for environments where symlinks don't work (like Vercel)
 */
function copyRecursiveSync(src, dest) {
  const exists = fs.existsSync(src);
  const stats = exists && fs.statSync(src);
  const isDirectory = exists && stats.isDirectory();
  
  if (isDirectory) {
    // Create destination directory if it doesn't exist
    if (!fs.existsSync(dest)) {
      fs.mkdirSync(dest, { recursive: true });
    }
    
    // Copy all contents recursively
    fs.readdirSync(src).forEach(function(childItemName) {
      copyRecursiveSync(
        path.join(src, childItemName),
        path.join(dest, childItemName)
      );
    });
  } else {
    // Copy file
    fs.copyFileSync(src, dest);
  }
}

/**
 * Main function to copy Cesium assets
 */
function copyCesiumAssets() {
  const cesiumSource = path.join(__dirname, '../node_modules/cesium/Build/Cesium');
  const cesiumDest = path.join(__dirname, '../public/cesium');
  
  try {
    // Check if source exists
    if (!fs.existsSync(cesiumSource)) {
      throw new Error(`Cesium source directory not found: ${cesiumSource}`);
    }
    
    console.log('📦 Copying Cesium assets...');
    console.log(`Source: ${cesiumSource}`);
    console.log(`Destination: ${cesiumDest}`);
    
    // Remove existing destination if it exists
    if (fs.existsSync(cesiumDest)) {
      fs.rmSync(cesiumDest, { recursive: true, force: true });
    }
    
    // Copy assets
    copyRecursiveSync(cesiumSource, cesiumDest);
    
    // Verify copy was successful
    const copiedFiles = fs.readdirSync(cesiumDest);
    console.log(`✅ Cesium assets copied successfully (${copiedFiles.length} items)`);
    
    return true;
  } catch (error) {
    console.error('❌ Failed to copy Cesium assets:', error.message);
    console.log('🔄 Will attempt to fall back to symlink strategy');
    return false;
  }
}

// Execute if run directly
if (require.main === module) {
  const success = copyCesiumAssets();
  process.exit(success ? 0 : 1);
}

module.exports = { copyCesiumAssets, copyRecursiveSync };

================
File: src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

================
File: src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

================
File: src/components/ui/dialog.tsx
================
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    data-slot="dialog-overlay"
    className={cn(
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-[9999] bg-black/90",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-[10000] grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}

================
File: src/components/ui/menubar.tsx
================
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return (
    <MenubarPrimitive.Root
      data-slot="menubar"
      className={cn(
        "bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs",
        className
      )}
      {...props}
    />
  )
}

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return (
    <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
  )
}

function MenubarTrigger({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return (
    <MenubarPrimitive.Trigger
      data-slot="menubar-trigger"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none",
        className
      )}
      {...props}
    />
  )
}

function MenubarContent({
  className,
  align = "start",
  alignOffset = -4,
  sideOffset = 8,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </MenubarPortal>
  )
}

function MenubarItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <MenubarPrimitive.Item
      data-slot="menubar-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function MenubarCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem
      data-slot="menubar-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  )
}

function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem
      data-slot="menubar-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  )
}

function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.Label
      data-slot="menubar-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function MenubarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return (
    <MenubarPrimitive.Separator
      data-slot="menubar-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function MenubarShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="menubar-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.SubTrigger
      data-slot="menubar-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  )
}

function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return (
    <MenubarPrimitive.SubContent
      data-slot="menubar-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent,
}

================
File: src/components/ui/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: src/components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

================
File: src/components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: src/components/CesiumMap.tsx
================
// src/components/CesiumMap.tsx
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Viewer, ImageryLayer, Entity, EllipseGraphics } from 'resium';
import {
  Ion,
  Cartesian3,
  Color,
  Rectangle,
  ScreenSpaceEventHandler,
  ScreenSpaceEventType,
  defined,
  Cartographic,
  UrlTemplateImageryProvider,
  WebMercatorTilingScheme,
  Credit,
  Math as CesiumMath,
  HeightReference
} from 'cesium';
import { EventBus } from '../game/EventBus';
import { speciesService } from '../lib/speciesService';
import type { Species } from '../types/database';
import { getAppConfig } from '../utils/config';
import HabitatLegend from './HabitatLegend';

// Configuration - using environment variables with fallbacks
const TITILER_BASE_URL = process.env.NEXT_PUBLIC_TITILER_BASE_URL || "https://azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net";
const COG_URL = process.env.NEXT_PUBLIC_COG_URL || "https://azurecog.blob.core.windows.net/cogtif/habitat_cog.tif";
const HABITAT_RADIUS_METERS = 10000.0; // Updated to match raster query (10km)
const SPECIES_RADIUS_METERS = 10000.0;

const CesiumMap: React.FC = () => { // Changed to React.FC for consistency
  const viewerRef = useRef<any>(null); // Typed viewerRef for Resium
  const [imageryProvider, setImageryProvider] = useState<UrlTemplateImageryProvider | null>(null); // Typed state
  const [clickedPosition, setClickedPosition] = useState<Cartesian3 | null>(null); // Cartesian3
  const [clickedLonLat, setClickedLonLat] = useState<{ lon: number, lat: number } | null>(null); // { lon, lat }
  const [infoBoxData, setInfoBoxData] = useState<{
    lon?: number;
    lat?: number;
    habitats: string[];
    species: Species[];
    rasterHabitats?: Array<{habitat_type: string; percentage: number}>;
    habitatCount?: number;
    topHabitat?: string;
    message?: string | null;
  }>({ habitats: [], species: [] });
  const [showInfoBox, setShowInfoBox] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    // Crucial for Next.js: CESIUM_BASE_URL is defined in next.config.mjs and made global in global.d.ts
    // Cesium will pick it up automatically for loading assets.
    // buildModuleUrl.setBaseUrl(CESIUM_BASE_URL); // This line was incorrect and is removed.
    
    // Use environment variable for Ion token as configured in the migration plan
    Ion.defaultAccessToken = process.env.NEXT_PUBLIC_CESIUM_ION_TOKEN || 'YOUR_FALLBACK_TOKEN'; 
  }, []);

  useEffect(() => {
    // Load configuration and setup TiTiler imagery
    const setupImagery = async () => {
      try {
        // Try to use dynamic config first, fallback to env vars
        const config = await getAppConfig().catch(() => ({
          cogUrl: COG_URL,
          titilerBaseUrl: TITILER_BASE_URL
        }));

        const encodedCOGUrl = encodeURIComponent(config.cogUrl);
        const colormapName = "habitat_custom"; // From your backend setup
        const tileMatrixSetId = "WebMercatorQuad"; // Standard TMS for web mapping
        const tileJsonUrl = `${config.titilerBaseUrl}/cog/${tileMatrixSetId}/tilejson.json?url=${encodedCOGUrl}&colormap_name=${colormapName}&nodata=0`;

        console.log("Resium: Requesting TileJSON from:", tileJsonUrl);
        const response = await fetch(tileJsonUrl);
        
        if (!response.ok) {
          const text = await response.text();
          throw new Error(`TileJSON Error ${response.status}: ${text}`);
        }
        
        const tileJson = await response.json();
        console.log("Resium: Received TileJSON:", tileJson);
        if (!tileJson.tiles || tileJson.tiles.length === 0) {
          throw new Error("TileJSON missing 'tiles' array or 'tiles' array is empty.");
        }
        let templateUrl = tileJson.tiles[0];
        if (!templateUrl) {
            throw new Error("TileJSON 'tiles' array does not contain a valid URL template.");
        }
        
        // Force HTTPS if the Azure endpoint returns HTTP URLs
        if (templateUrl.startsWith('http://azure-local-dfgagqgub7fhb5fv')) {
          templateUrl = templateUrl.replace('http://', 'https://');
        }
        
        console.log("Resium: Using Template URL:", templateUrl);

        const provider = new UrlTemplateImageryProvider({
          url: templateUrl,
          tilingScheme: new WebMercatorTilingScheme(),
          tileWidth: 256,
          tileHeight: 256,
          minimumLevel: tileJson.minzoom ?? 0,
          maximumLevel: tileJson.maxzoom ?? 18,
          credit: new Credit('IUCN Habitat Map via TiTiler')
        });
        setImageryProvider(provider);

        if (viewerRef.current && viewerRef.current.cesiumElement && tileJson.bounds) {
          const viewer = viewerRef.current.cesiumElement;
          
          // Set showGroundAtmosphere on the globe
          if (viewer.scene && viewer.scene.globe) {
            viewer.scene.globe.showGroundAtmosphere = false;
          }
          
          const [west, south, east, north] = tileJson.bounds;
          if ([west, south, east, north].every(coord => typeof coord === 'number' && isFinite(coord))) {
            const rectangle = Rectangle.fromDegrees(west, south, east, north);
            const widthRad = Rectangle.computeWidth(rectangle);
            const heightRad = Rectangle.computeHeight(rectangle);
            if(widthRad < 0.001 && heightRad < 0.001) { 
                // Expand the rectangle directly
                rectangle.north += 0.05; // radians
                rectangle.south -= 0.05; // radians
                rectangle.east += 0.05;  // radians
                rectangle.west -= 0.05;  // radians
            }
            viewer.camera.flyTo({
              destination: rectangle,
              duration: 1.5
            });
            console.log("Resium: Flying to bounds:", tileJson.bounds);
          } else {
            console.warn("Resium: Invalid TileJSON bounds.", tileJson.bounds);
          }
        } else if (!tileJson.bounds) {
            console.log("Resium: TileJSON missing bounds. Default camera view used.");
        }
      } catch (err: any) {
        console.error("Resium: Error loading habitat layer:", err);
        alert(`Failed to load habitat layer: ${err.message}`);
      }
    };

    setupImagery();
  }, []); 


  const handleMapClick = useCallback((movement: any) => { // Typed movement
    if (!viewerRef.current || !viewerRef.current.cesiumElement || isLoading) return;

    const viewer = viewerRef.current.cesiumElement;
    const cartesian = viewer.camera.pickEllipsoid(movement.position, viewer.scene.globe.ellipsoid);

    if (cartesian) {
      setClickedPosition(cartesian); 
      const cartographic = Cartographic.fromCartesian(cartesian);
      const longitude = CesiumMath.toDegrees(cartographic.longitude);
      const latitude = CesiumMath.toDegrees(cartographic.latitude);
      setClickedLonLat({ lon: longitude, lat: latitude });
      setShowInfoBox(true);
      setInfoBoxData({ habitats: [], species: [], message: `Querying for Lon: ${longitude.toFixed(4)}, Lat: ${latitude.toFixed(4)}...` });
      setIsLoading(true);

      console.log("Resium: Calling speciesService for location:", longitude, latitude);

      // Use Supabase species service for location data
      Promise.all([
        speciesService.getSpeciesAtPoint(longitude, latitude),
        speciesService.getRasterHabitatDistribution(longitude, latitude)
      ])
        .then(([speciesResult, rasterHabitats]) => {
          console.log("Resium: Species service response:", speciesResult);
          console.log("Resium: Raster habitat response:", rasterHabitats);
          
          // Keep legacy habitat extraction for backward compatibility (if needed elsewhere)
          const legacyHabitats = new Set<string>();
          speciesResult.species.forEach(species => {
            if (species.hab_desc) legacyHabitats.add(species.hab_desc);
            if (species.aquatic) legacyHabitats.add('aquatic');
            if (species.freshwater) legacyHabitats.add('freshwater');
            if (species.terrestr || species.terrestria) legacyHabitats.add('terrestrial');
            if (species.marine) legacyHabitats.add('marine');
          });

          const habitatList = Array.from(legacyHabitats);
          
          // Process raster habitat data for info display
          const habitatCount = rasterHabitats.length;
          const topHabitat = rasterHabitats.length > 0 
            ? `${rasterHabitats[0].habitat_type} (${rasterHabitats[0].percentage}%)`
            : undefined;
          
          setInfoBoxData({
            lon: longitude,
            lat: latitude,
            habitats: habitatList, // Keep for legacy compatibility
            species: speciesResult.species,
            rasterHabitats: rasterHabitats,
            habitatCount: habitatCount,
            topHabitat: topHabitat,
            message: null
          });
          
          // Emit event with actual species data and raster habitat data for the game
          EventBus.emit('cesium-location-selected', {
            lon: longitude,
            lat: latitude,
            habitats: habitatList,
            species: speciesResult.species,
            rasterHabitats: rasterHabitats
          });
        })
        .catch(err => {
          console.error("Resium: Error calling species service:", err);
          setInfoBoxData({ 
            habitats: [], 
            species: [], 
            message: `Error: ${err.message || 'Failed to load species data'}` 
          });
        })
        .finally(() => {
            setIsLoading(false);
        });
    } else {
      setShowInfoBox(true);
      setInfoBoxData({ habitats: [], species: [], message: 'Click on the globe to query location.' });
      setClickedPosition(null);
      setClickedLonLat(null);
    }
  }, [isLoading]);

  return (
    <div style={{ width: '100%', height: '100%', position: 'relative' }}>
      <Viewer
        ref={viewerRef}
        full 
        timeline={false}
        animation={false}
        baseLayerPicker={true} 
        geocoder={false}
        onClick={handleMapClick}
      >
        {imageryProvider && (
          <ImageryLayer
            imageryProvider={imageryProvider}
            alpha={0.7}
          />
        )}

        {clickedPosition && (
          <>
            <Entity position={clickedPosition} name="Habitat Query Radius">
              <EllipseGraphics
                semiMinorAxis={HABITAT_RADIUS_METERS}
                semiMajorAxis={HABITAT_RADIUS_METERS}
                material={Color.RED.withAlpha(0.2)}
                outline
                outlineColor={Color.RED}
                outlineWidth={2}
                heightReference={HeightReference.CLAMP_TO_GROUND}
              />
            </Entity>
            <Entity position={clickedPosition} name="Species Query Radius">
              <EllipseGraphics
                semiMinorAxis={SPECIES_RADIUS_METERS}
                semiMajorAxis={SPECIES_RADIUS_METERS}
                material={Color.BLUE.withAlpha(0.15)}
                outline
                outlineColor={Color.BLUE}
                outlineWidth={2}
                heightReference={HeightReference.CLAMP_TO_GROUND}
              />
            </Entity>
          </>
        )}
      </Viewer>
      {showInfoBox && (
        <div style={{
          position: 'absolute', top: '10px', left: '10px',
          background: 'rgba(40,40,40,0.85)', color: 'white',
          padding: '5px', borderRadius: '5px', fontFamily: 'sans-serif',
          fontSize: '12px', maxWidth: '350px', zIndex: 1000, pointerEvents: 'auto'
        }}>
          <div style={{ marginBottom: '5px' }}>
            {infoBoxData.message ? <p style={{ margin: 0 }}>{infoBoxData.message}</p> : (
              <p style={{ margin: 0 }}>
                <b>Habitats:</b> {infoBoxData.rasterHabitats?.length || 0} &nbsp;&nbsp;
                <b>Species:</b> {infoBoxData.species.length}
              </p>
            )}
            {isLoading && <p style={{ margin: 0 }}><em>Loading...</em></p>}
          </div>
          
          {infoBoxData.rasterHabitats && infoBoxData.rasterHabitats.length > 0 && (
            <HabitatLegend 
              habitats={infoBoxData.rasterHabitats}
              radiusKm={HABITAT_RADIUS_METERS / 1000}
            />
          )}
        </div>
      )}
    </div>
  );
}

export default CesiumMap;

================
File: src/components/ClueDisplay.tsx
================
import React, { useState, useEffect } from 'react';
import { EventBus } from '../game/EventBus';
import type { CluePayload } from '../game/clueConfig';
import { GemLegend } from './GemLegend';

interface ClueDisplayProps {
  style?: React.CSSProperties;
}

export const ClueDisplay: React.FC<ClueDisplayProps> = ({ style }) => {
  const [clues, setClues] = useState<CluePayload[]>([]);
  const [selectedSpeciesName, setSelectedSpeciesName] = useState<string>('');
  const [selectedSpeciesId, setSelectedSpeciesId] = useState<number>(0);
  const [totalSpecies, setTotalSpecies] = useState<number>(0);
  const [currentSpeciesIndex, setCurrentSpeciesIndex] = useState<number>(0);
  const [showLegend, setShowLegend] = useState<boolean>(false);
  const [isLoadingClue, setIsLoadingClue] = useState<boolean>(false);
  const [allCluesRevealed, setAllCluesRevealed] = useState<boolean>(false);
  const [allSpeciesCompleted, setAllSpeciesCompleted] = useState<boolean>(false);

  useEffect(() => {
    // Listen for clue reveals from the game
    const handleClueRevealed = (clueData: CluePayload) => {
      setIsLoadingClue(true);
      // Simulate a brief loading state for clue processing
      setTimeout(() => {
        setClues(prev => [...prev, clueData]);
        setIsLoadingClue(false);
      }, 500);
    };

    // Listen for new game starts
    const handleNewGame = (data: { speciesName: string; speciesId: number; totalSpecies: number; currentIndex: number }) => {
      setClues([]);
      setSelectedSpeciesName(data.speciesName);
      setSelectedSpeciesId(data.speciesId);
      setTotalSpecies(data.totalSpecies);
      setCurrentSpeciesIndex(data.currentIndex);
      setAllCluesRevealed(false);
      setAllSpeciesCompleted(false);
    };

    // Listen for game reset
    const handleGameReset = () => {
      setClues([]);
      setSelectedSpeciesName('');
      setSelectedSpeciesId(0);
      setTotalSpecies(0);
      setCurrentSpeciesIndex(0);
      setAllCluesRevealed(false);
      setAllSpeciesCompleted(false);
    };

    // Listen for no species found
    const handleNoSpeciesFound = () => {
      setSelectedSpeciesName('No species found at this location');
      setClues([]);
    };

    // Listen for all clues revealed
    const handleAllCluesRevealed = () => {
      setAllCluesRevealed(true);
    };

    // Listen for all species completed
    const handleAllSpeciesCompleted = () => {
      setAllSpeciesCompleted(true);
    };

    EventBus.on('clue-revealed', handleClueRevealed);
    EventBus.on('new-game-started', handleNewGame);
    EventBus.on('game-reset', handleGameReset);
    EventBus.on('no-species-found', handleNoSpeciesFound);
    EventBus.on('all-clues-revealed', handleAllCluesRevealed);
    EventBus.on('all-species-completed', handleAllSpeciesCompleted);

    return () => {
      EventBus.off('clue-revealed', handleClueRevealed);
      EventBus.off('new-game-started', handleNewGame);
      EventBus.off('game-reset', handleGameReset);
      EventBus.off('no-species-found', handleNoSpeciesFound);
      EventBus.off('all-clues-revealed', handleAllCluesRevealed);
      EventBus.off('all-species-completed', handleAllSpeciesCompleted);
    };
  }, []);

  const containerStyle: React.CSSProperties = {
    ...style,
    overflowY: 'auto',
    height: '100%'
  };

  const clueItemStyle: React.CSSProperties = {
    marginBottom: '10px',
    padding: '8px',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: '4px',
    borderLeft: '3px solid #4a90e2'
  };

  const headingStyle: React.CSSProperties = {
    fontSize: '16px',
    fontWeight: 'bold',
    marginBottom: '4px',
    color: '#4a90e2'
  };

  const clueTextStyle: React.CSSProperties = {
    fontSize: '14px',
    color: '#e0e0e0'
  };


  const legendButtonStyle: React.CSSProperties = {
    position: 'absolute',
    top: '10px',
    right: '10px',
    padding: '5px 10px',
    backgroundColor: '#4a90e2',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    fontSize: '12px',
    zIndex: 10
  };

  if (!selectedSpeciesName && clues.length === 0) {
    return (
      <div style={containerStyle}>
        <h2>Species Discovery</h2>
        <p>Click on the Cesium map to select a location and discover species.</p>
        <p>Match gems to reveal clues about each species.</p>
        <button 
          style={legendButtonStyle}
          onClick={() => setShowLegend(!showLegend)}
        >
          {showLegend ? 'Hide Legend' : 'Show Legend'}
        </button>
        {showLegend && (
          <GemLegend style={{ marginTop: '20px' }} />
        )}
      </div>
    );
  }

  return (
    <div style={containerStyle}>
      <button 
        style={legendButtonStyle}
        onClick={() => setShowLegend(!showLegend)}
      >
        {showLegend ? 'Hide Legend' : 'Show Legend'}
      </button>
      
      {allSpeciesCompleted ? (
        <>
          <h2 style={{ color: '#00ff00' }}>All Species Discovered!</h2>
          <p style={{ fontSize: '16px', marginBottom: '20px' }}>
            Congratulations! You have discovered all {totalSpecies} species at this location.
          </p>
        </>
      ) : (
        <>
          <h2 style={{ color: '#00ff00' }}>
            Current Species: {selectedSpeciesName}
          </h2>
          {selectedSpeciesId > 0 && (
            <p style={{ fontSize: '14px', color: '#aaa', marginBottom: '10px' }}>
              ID: {selectedSpeciesId} | Species {currentSpeciesIndex} of {totalSpecies}
            </p>
          )}
          {allCluesRevealed && (
            <p style={{ fontSize: '14px', color: '#ffff00', marginBottom: '10px', fontStyle: 'italic' }}>
              All clues revealed! Advancing to next species...
            </p>
          )}
        </>
      )}
      
      {showLegend && (
        <GemLegend style={{ marginBottom: '15px' }} />
      )}
      
      {!allSpeciesCompleted && (
        <>
          {clues.length === 0 && !isLoadingClue ? (
            <p style={{ color: '#999', fontStyle: 'italic' }}>
              Match gems to reveal clues about this species...
            </p>
          ) : (
            <div>
              {clues.map((clue, index) => (
                <div key={index} style={{
                  ...clueItemStyle,
                  borderLeft: `3px solid ${clue.color}`
                }}>
                  <div style={headingStyle}>
                    {clue.icon} {clue.name}
                  </div>
                  <div style={clueTextStyle}>{clue.clue}</div>
                </div>
              ))}
              {isLoadingClue && (
                <div style={{ 
                  ...clueItemStyle, 
                  display: 'flex', 
                  alignItems: 'center',
                  backgroundColor: 'rgba(74, 144, 226, 0.1)',
                  borderLeft: '3px solid #4a90e2'
                }}>
                  <div style={{
                    width: '16px',
                    height: '16px',
                    border: '2px solid #f3f3f3',
                    borderTop: '2px solid #4a90e2',
                    borderRadius: '50%',
                    animation: 'spin 1s linear infinite',
                    marginRight: '8px'
                  }}></div>
                  <span style={{ color: '#4a90e2', fontSize: '14px' }}>
                    Processing clue...
                  </span>
                </div>
              )}
            </div>
          )}
        </>
      )}
    </div>
  );
};

================
File: src/components/ClueSheet.tsx
================
import React from 'react';
import { Button } from '@/components/ui/button';
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from '@/components/ui/sheet';
import { ScrollArea } from '@/components/ui/scroll-area';
import { FileText } from 'lucide-react';
import type { CluePayload } from '../game/clueConfig';

interface ClueSheetProps {
  clues: CluePayload[];
  speciesName: string;
  hasSelectedSpecies: boolean;
}

export const ClueSheet: React.FC<ClueSheetProps> = ({ clues, speciesName, hasSelectedSpecies }) => {
  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button
          variant="outline"
          size="sm"
          className="w-full bg-slate-700 hover:bg-slate-600 border-slate-600"
          disabled={!hasSelectedSpecies}
        >
          <FileText className="h-4 w-4 mr-2" />
          Field Notes ({clues.length})
        </Button>
      </SheetTrigger>
      <SheetContent className="bg-slate-900 border-slate-700 text-slate-100">
        <SheetHeader>
          <SheetTitle className="text-cyan-300">Field Notes</SheetTitle>
          <SheetDescription className="text-slate-400">
            {speciesName || 'No species selected'}
          </SheetDescription>
        </SheetHeader>
        <ScrollArea className="h-[calc(100vh-120px)] mt-4">
          {clues.length === 0 ? (
            <p className="text-slate-400 italic">No clues discovered yet.</p>
          ) : (
            <div className="space-y-3">
              {clues.map((clue, index) => (
                <div
                  key={index}
                  className="bg-slate-800 rounded-lg p-4"
                  style={{ borderLeft: `4px solid ${clue.color}` }}
                >
                  <div className="flex items-center gap-2 mb-2">
                    <span className="text-xl">{clue.icon}</span>
                    <h3 className="font-semibold text-cyan-300">{clue.name}</h3>
                  </div>
                  <p className="text-sm text-slate-300">{clue.clue}</p>
                </div>
              ))}
            </div>
          )}
        </ScrollArea>
      </SheetContent>
    </Sheet>
  );
};

================
File: src/components/DenseClueGrid.tsx
================
import React from 'react';
import type { CluePayload } from '../game/clueConfig';

interface DenseClueGridProps {
  clues: CluePayload[];
  hasSelectedSpecies: boolean;
}

export const DenseClueGrid: React.FC<DenseClueGridProps> = ({ clues, hasSelectedSpecies }) => {
  if (!hasSelectedSpecies) {
    return (
      <div className="flex-1 bg-slate-800 rounded-lg p-4 flex items-center justify-center text-slate-400">
        <p className="text-center">
          Click on the Cesium map to select a location and discover species.
          <br />
          Match gems to reveal clues!
        </p>
      </div>
    );
  }

  if (clues.length === 0) {
    return (
      <div className="flex-1 bg-slate-800 rounded-lg p-4 flex items-center justify-center text-slate-400">
        <p className="text-center italic">Match gems to reveal clues about this species...</p>
      </div>
    );
  }

  return (
    <div className="flex-1 bg-slate-800 rounded-lg p-3 overflow-y-auto">
      <div className="grid gap-2">
        {clues.map((clue, index) => (
          <div
            key={index}
            className="bg-slate-700 rounded-md p-2 transition-all hover:bg-slate-600"
            style={{ borderLeft: `3px solid ${clue.color}` }}
          >
            <div className="flex items-start gap-2">
              <span className="text-lg mt-0.5">{clue.icon}</span>
              <div className="flex-1 min-w-0">
                <div className="text-sm font-medium text-cyan-300">{clue.name}</div>
                <div className="text-xs text-slate-300 break-words">{clue.clue}</div>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

================
File: src/components/GemLegend.tsx
================
import React from 'react';

interface GemLegendProps {
  style?: React.CSSProperties;
}

export const GemLegend: React.FC<GemLegendProps> = ({ style }) => {
  const gemCategories = [
    { color: 'red', category: 'Classification', icon: '🧬', description: 'Taxonomic information' },
    { color: 'green', category: 'Habitat', icon: '🌳', description: 'Where it lives' },
    { color: 'blue', category: 'Geographic & Habitat', icon: '🗺️', description: 'Geographic range & habitat' },
    { color: 'orange', category: 'Morphology', icon: '🐾', description: 'Physical appearance & dimensions' },
    { color: 'white', category: 'Behavior & Diet', icon: '💨', description: 'How it acts & what it eats' },
    { color: 'black', category: 'Life Cycle', icon: '⏳', description: 'Reproduction & lifespan' },
    { color: 'yellow', category: 'Conservation', icon: '🛡️', description: 'Conservation status' },
    { color: 'purple', category: 'Key Facts', icon: '❗', description: 'Unique identifying traits' }
  ];

  const containerStyle: React.CSSProperties = {
    ...style,
    padding: '15px',
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    borderRadius: '8px',
    color: 'white',
    fontSize: '12px',
    maxHeight: '400px',
    overflowY: 'auto'
  };

  const titleStyle: React.CSSProperties = {
    fontSize: '16px',
    fontWeight: 'bold',
    marginBottom: '10px',
    textAlign: 'center'
  };

  const legendItemStyle: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    marginBottom: '8px',
    padding: '4px'
  };

  const gemColorStyle = (color: string): React.CSSProperties => ({
    width: '16px',
    height: '16px',
    borderRadius: '50%',
    marginRight: '8px',
    border: '1px solid #ccc',
    backgroundColor: color === 'black' ? '#2c2c2c' : color === 'purple' ? '#8B00FF' : color,
    flexShrink: 0
  });

  const iconStyle: React.CSSProperties = {
    marginRight: '6px',
    fontSize: '14px'
  };

  const textContainerStyle: React.CSSProperties = {
    flex: 1
  };

  const categoryStyle: React.CSSProperties = {
    fontWeight: 'bold',
    marginBottom: '2px'
  };

  const descriptionStyle: React.CSSProperties = {
    color: '#ccc',
    fontSize: '11px'
  };

  return (
    <div style={containerStyle}>
      <div style={titleStyle}>Gem Categories</div>
      {gemCategories.map((item, index) => (
        <div key={index} style={legendItemStyle}>
          <div style={gemColorStyle(item.color)}></div>
          <span style={iconStyle}>{item.icon}</span>
          <div style={textContainerStyle}>
            <div style={categoryStyle}>{item.category}</div>
            <div style={descriptionStyle}>{item.description}</div>
          </div>
        </div>
      ))}
    </div>
  );
};

================
File: src/components/GemLegendDialog.tsx
================
import React from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { CLUE_CONFIG, GemCategory } from '../game/clueConfig';

interface GemLegendDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export const GemLegendDialog: React.FC<GemLegendDialogProps> = ({ open, onOpenChange }) => {
  const legendItemStyle: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    marginBottom: '12px',
    padding: '8px',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: '4px'
  };

  const gemIconStyle: React.CSSProperties = {
    width: '32px',
    height: '32px',
    marginRight: '12px',
    imageRendering: 'pixelated'
  };

  const textStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    gap: '2px'
  };

  const categoryStyle: React.CSSProperties = {
    fontSize: '14px',
    fontWeight: 'bold',
    color: '#4a90e2'
  };


  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-md max-h-[80vh] overflow-y-auto bg-black border-gray-700" style={{ backgroundColor: '#000000' }}>
        <DialogHeader>
          <DialogTitle>Gem Legend</DialogTitle>
          <DialogDescription>
            Match 3 or more gems to reveal clues about the species
          </DialogDescription>
        </DialogHeader>
        <div className="mt-4">
          {Object.entries(CLUE_CONFIG).map(([categoryId, config]) => {
            const category = parseInt(categoryId) as GemCategory;
            return (
              <div key={category} style={legendItemStyle}>
                <img
                  src={`/assets/${config.color}_gem_0.png`}
                  alt={`${config.categoryName} gem`}
                  style={gemIconStyle}
                />
                <div style={textStyle}>
                  <div style={categoryStyle}>
                    {config.icon} {config.categoryName}
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </DialogContent>
    </Dialog>
  );
};

================
File: src/components/HabitatLegend.tsx
================
import React, { useState } from 'react';
import { getHabitatColor } from '../config/habitatColors';

interface HabitatData {
  habitat_type: string;
  percentage: number;
  color?: string;
}

interface HabitatLegendProps {
  habitats: HabitatData[];
  radiusKm: number;
}

export default function HabitatLegend({ habitats, radiusKm }: HabitatLegendProps) {
  const [isCollapsed, setIsCollapsed] = useState(true);

  const sortedHabitats = [...habitats].sort((a, b) => b.percentage - a.percentage);

  return (
    <div style={{
      width: '100%',
      paddingTop: '5px',
      marginTop: '5px',
      borderTop: '1px solid #555',
      color: 'white',
      fontFamily: 'sans-serif',
      fontSize: '12px'
    }}>
      <div style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        marginBottom: isCollapsed ? 0 : '5px',
        cursor: 'pointer'
      }} onClick={() => setIsCollapsed(!isCollapsed)}>
        <h4 style={{ 
          margin: 0, 
          fontSize: '12px',
          fontWeight: 'normal'
        }}>
          Details
        </h4>
        <button
          style={{
            background: 'none',
            border: 'none',
            color: 'white',
            fontSize: '12px',
            cursor: 'pointer',
            padding: '0 0 0 8px',
            display: 'flex',
            alignItems: 'center'
          }}
          aria-label={isCollapsed ? 'Expand' : 'Collapse'}
        >
          {isCollapsed ? '▶' : '▼'}
        </button>
      </div>
      
      {!isCollapsed && (
        <div style={{ 
          marginTop: '4px',
          maxHeight: '200px',
          overflowY: 'auto',
          overflowX: 'hidden',
          paddingRight: '5px'
        }}>
          {sortedHabitats.length === 0 ? (
            <div style={{ fontSize: '12px', opacity: 0.8 }}>
              No habitats detected
            </div>
          ) : (
            sortedHabitats.map((habitat, index) => (
              <div
                key={`${habitat.habitat_type}-${index}`}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  marginBottom: '4px',
                  fontSize: '12px'
                }}
              >
                <span
                  style={{
                    width: '12px',
                    height: '12px',
                    backgroundColor: habitat.color || getHabitatColor(habitat.habitat_type),
                    border: '1px solid #fff',
                    marginRight: '6px',
                    flexShrink: 0,
                    borderRadius: '2px'
                  }}
                />
                <span style={{ 
                  flex: 1, 
                  marginRight: '4px',
                  wordBreak: 'break-word',
                  lineHeight: '1.2'
                }}>
                  {habitat.habitat_type.split(' - ').map((part, i) => {
                    // For the first part (category), display as-is
                    if (i === 0) {
                      return (
                        <React.Fragment key={i}>
                          {part}
                        </React.Fragment>
                      );
                    }
                    
                    // For the description part, split into multiple lines if needed
                    const words = part.split(' ');
                    if (words.length <= 2 && part.length <= 20) {
                      // Short descriptions stay on same line
                      return (
                        <React.Fragment key={i}>
                          {' - '}
                          {part}
                        </React.Fragment>
                      );
                    }
                    
                    // Long descriptions get split into multiple lines
                    const lines: string[] = [];
                    let currentLine = '';
                    
                    words.forEach((word, wordIndex) => {
                      const testLine = currentLine ? `${currentLine} ${word}` : word;
                      
                      // Start a new line if:
                      // - Adding this word would exceed 20 chars
                      // - Current line already has 2+ words
                      // - We're at the 3rd line
                      if (lines.length < 2 && currentLine && 
                          (testLine.length > 20 || currentLine.split(' ').length >= 2)) {
                        lines.push(currentLine);
                        currentLine = word;
                      } else {
                        currentLine = testLine;
                      }
                    });
                    
                    // Add the last line
                    if (currentLine) {
                      lines.push(currentLine);
                    }
                    
                    return (
                      <React.Fragment key={i}>
                        {' - '}
                        <br />
                        {lines.map((line, lineIndex) => (
                          <React.Fragment key={lineIndex}>
                            {lineIndex > 0 && <br />}
                            {line}
                          </React.Fragment>
                        ))}
                      </React.Fragment>
                    );
                  })}
                </span>
                <span style={{ 
                  fontWeight: 'bold',
                  minWidth: '40px',
                  textAlign: 'right'
                }}>
                  {habitat.percentage.toFixed(1)}%
                </span>
              </div>
            ))
          )}
        </div>
      )}
    </div>
  );
}

================
File: src/components/SpeciesHeaderCard.tsx
================
import React from 'react';
import { Button } from '@/components/ui/button';
import { Info } from 'lucide-react';

interface SpeciesHeaderCardProps {
  speciesName: string;
  currentSpeciesIndex: number;
  totalSpecies: number;
  revealedClueCount: number;
  discoveredClues: Array<{
    name: string;
    color: string;
    icon: string;
  }>;
  onShowLegend: () => void;
}

export const SpeciesHeaderCard: React.FC<SpeciesHeaderCardProps> = ({
  speciesName,
  currentSpeciesIndex,
  totalSpecies,
  revealedClueCount,
  discoveredClues,
  onShowLegend,
}) => {
  const maxClues = 8; // Total number of gem categories

  return (
    <div className="bg-slate-800 rounded-lg p-3 space-y-2">
      {/* Species Info Row */}
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-cyan-300 font-semibold text-lg">
            {speciesName || 'Select a location to discover species'}
          </h3>
          {totalSpecies > 0 && (
            <p className="text-slate-400 text-sm">
              Species {currentSpeciesIndex} of {totalSpecies} • {revealedClueCount}/{maxClues} clues
            </p>
          )}
        </div>
        <Button
          variant="ghost"
          size="sm"
          onClick={onShowLegend}
          className="text-slate-400 hover:text-cyan-300"
        >
          <Info className="h-4 w-4" />
        </Button>
      </div>

      {/* Discovered Clues Row */}
      {discoveredClues.length > 0 && (
        <div className="flex gap-2 flex-wrap">
          {discoveredClues.map((clue, index) => (
            <div
              key={index}
              className="flex items-center gap-1 px-2 py-1 bg-slate-700 rounded-md"
              style={{ borderLeft: `3px solid ${clue.color}` }}
            >
              <span className="text-sm">{clue.icon}</span>
              <span className="text-xs text-slate-300">{clue.name}</span>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

================
File: src/components/SpeciesPanel.old.tsx
================
import React, { useState, useEffect } from 'react';
import { EventBus } from '../game/EventBus';
import type { CluePayload } from '../game/clueConfig';
import { GemLegendDialog } from './GemLegendDialog';

interface SpeciesPanelProps {
  style?: React.CSSProperties;
}

export const SpeciesPanel: React.FC<SpeciesPanelProps> = ({ style }) => {
  const [clues, setClues] = useState<CluePayload[]>([]);
  const [selectedSpeciesName, setSelectedSpeciesName] = useState<string>('');
  const [selectedSpeciesId, setSelectedSpeciesId] = useState<number>(0);
  const [totalSpecies, setTotalSpecies] = useState<number>(0);
  const [currentSpeciesIndex, setCurrentSpeciesIndex] = useState<number>(0);
  const [legendOpen, setLegendOpen] = useState<boolean>(false);
  const [isLoadingClue, setIsLoadingClue] = useState<boolean>(false);
  const [allCluesRevealed, setAllCluesRevealed] = useState<boolean>(false);
  const [allSpeciesCompleted, setAllSpeciesCompleted] = useState<boolean>(false);

  useEffect(() => {
    // Listen for clue reveals from the game
    const handleClueRevealed = (clueData: CluePayload) => {
      setIsLoadingClue(true);
      // Simulate a brief loading state for clue processing
      setTimeout(() => {
        setClues(prev => [...prev, clueData]);
        setIsLoadingClue(false);
      }, 500);
    };

    // Listen for new game starts
    const handleNewGame = (data: { speciesName: string; speciesId: number; totalSpecies: number; currentIndex: number }) => {
      setClues([]);
      setSelectedSpeciesName(data.speciesName);
      setSelectedSpeciesId(data.speciesId);
      setTotalSpecies(data.totalSpecies);
      setCurrentSpeciesIndex(data.currentIndex);
      setAllCluesRevealed(false);
      setAllSpeciesCompleted(false);
    };

    // Listen for game reset
    const handleGameReset = () => {
      setClues([]);
      setSelectedSpeciesName('');
      setSelectedSpeciesId(0);
      setTotalSpecies(0);
      setCurrentSpeciesIndex(0);
      setAllCluesRevealed(false);
      setAllSpeciesCompleted(false);
    };

    // Listen for no species found
    const handleNoSpeciesFound = () => {
      setSelectedSpeciesName('No species found at this location');
      setClues([]);
    };

    // Listen for all clues revealed
    const handleAllCluesRevealed = () => {
      setAllCluesRevealed(true);
    };

    // Listen for all species completed
    const handleAllSpeciesCompleted = () => {
      setAllSpeciesCompleted(true);
    };

    EventBus.on('clue-revealed', handleClueRevealed);
    EventBus.on('new-game-started', handleNewGame);
    EventBus.on('game-reset', handleGameReset);
    EventBus.on('no-species-found', handleNoSpeciesFound);
    EventBus.on('all-clues-revealed', handleAllCluesRevealed);
    EventBus.on('all-species-completed', handleAllSpeciesCompleted);

    return () => {
      EventBus.off('clue-revealed', handleClueRevealed);
      EventBus.off('new-game-started', handleNewGame);
      EventBus.off('game-reset', handleGameReset);
      EventBus.off('no-species-found', handleNoSpeciesFound);
      EventBus.off('all-clues-revealed', handleAllCluesRevealed);
      EventBus.off('all-species-completed', handleAllSpeciesCompleted);
    };
  }, []);

  const containerStyle: React.CSSProperties = {
    ...style,
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    backgroundColor: '#1a1a1a',
    borderRadius: '8px',
    overflow: 'hidden',
    position: 'relative'
  };

  const contentStyle: React.CSSProperties = {
    flex: 1,
    overflowY: 'auto',
    padding: '16px'
  };

  const clueItemStyle: React.CSSProperties = {
    marginBottom: '10px',
    padding: '8px',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: '4px',
    borderLeft: '3px solid #4a90e2'
  };

  const headingStyle: React.CSSProperties = {
    fontSize: '16px',
    fontWeight: 'bold',
    marginBottom: '4px',
    color: '#4a90e2'
  };

  const clueTextStyle: React.CSSProperties = {
    fontSize: '14px',
    color: '#e0e0e0'
  };

  const legendButtonStyle: React.CSSProperties = {
    position: 'absolute',
    top: '10px',
    right: '10px',
    padding: '5px 10px',
    backgroundColor: '#4a90e2',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    fontSize: '12px',
    zIndex: 10
  };

  return (
    <div style={containerStyle}>
      <button 
        style={legendButtonStyle}
        onClick={() => setLegendOpen(true)}
      >
        Show Legend
      </button>
      <div style={contentStyle}>
        {!selectedSpeciesName && clues.length === 0 ? (
          <>
            <h2 style={{ color: '#00ff00' }}>Species Discovery</h2>
            <p>Click on the Cesium map to select a location and discover species.</p>
            <p>Match gems to reveal clues about each species.</p>
          </>
        ) : (
          <>
            {allSpeciesCompleted ? (
              <>
                <h2 style={{ color: '#00ff00' }}>All Species Discovered!</h2>
                <p style={{ fontSize: '16px', marginBottom: '20px' }}>
                  Congratulations! You have discovered all {totalSpecies} species at this location.
                </p>
              </>
            ) : (
              <>
                <h2 style={{ color: '#00ff00' }}>
                  Current Species: {selectedSpeciesName}
                </h2>
                {selectedSpeciesId > 0 && (
                  <p style={{ fontSize: '14px', color: '#aaa', marginBottom: '10px' }}>
                    ID: {selectedSpeciesId} | Species {currentSpeciesIndex} of {totalSpecies}
                  </p>
                )}
                {allCluesRevealed && (
                  <p style={{ fontSize: '14px', color: '#ffff00', marginBottom: '10px', fontStyle: 'italic' }}>
                    All clues revealed! Advancing to next species...
                  </p>
                )}
              </>
            )}
            
            {!allSpeciesCompleted && (
              <>
                {clues.length === 0 && !isLoadingClue ? (
                  <p style={{ color: '#999', fontStyle: 'italic' }}>
                    Match gems to reveal clues about this species...
                  </p>
                ) : (
                  <div>
                    {clues.map((clue, index) => (
                      <div key={index} style={{
                        ...clueItemStyle,
                        borderLeft: `3px solid ${clue.color}`
                      }}>
                        <div style={headingStyle}>
                          {clue.icon} {clue.name}
                        </div>
                        <div style={clueTextStyle}>{clue.clue}</div>
                      </div>
                    ))}
                    {isLoadingClue && (
                      <div style={{ 
                        ...clueItemStyle, 
                        display: 'flex', 
                        alignItems: 'center',
                        backgroundColor: 'rgba(74, 144, 226, 0.1)',
                        borderLeft: '3px solid #4a90e2'
                      }}>
                        <div style={{
                          width: '16px',
                          height: '16px',
                          border: '2px solid #f3f3f3',
                          borderTop: '2px solid #4a90e2',
                          borderRadius: '50%',
                          animation: 'spin 1s linear infinite',
                          marginRight: '8px'
                        }}></div>
                        <span style={{ color: '#4a90e2', fontSize: '14px' }}>
                          Processing clue...
                        </span>
                      </div>
                    )}
                  </div>
                )}
              </>
            )}
          </>
        )}
      </div>

      <GemLegendDialog open={legendOpen} onOpenChange={setLegendOpen} />
    </div>
  );
};

================
File: src/components/SpeciesPanel.tsx
================
import React, { useState, useEffect } from 'react';
import { toast } from 'sonner';
import { EventBus } from '../game/EventBus';
import type { CluePayload } from '../game/clueConfig';
import { GemLegendDialog } from './GemLegendDialog';
import { SpeciesHeaderCard } from './SpeciesHeaderCard';
import { DenseClueGrid } from './DenseClueGrid';
import { ClueSheet } from './ClueSheet';

interface SpeciesPanelProps {
  style?: React.CSSProperties;
}

export const SpeciesPanel: React.FC<SpeciesPanelProps> = ({ style }) => {
  const [clues, setClues] = useState<CluePayload[]>([]);
  const [selectedSpeciesName, setSelectedSpeciesName] = useState<string>('');
  const [selectedSpeciesId, setSelectedSpeciesId] = useState<number>(0);
  const [totalSpecies, setTotalSpecies] = useState<number>(0);
  const [currentSpeciesIndex, setCurrentSpeciesIndex] = useState<number>(0);
  const [legendOpen, setLegendOpen] = useState<boolean>(false);
  const [allCluesRevealed, setAllCluesRevealed] = useState<boolean>(false);
  const [allSpeciesCompleted, setAllSpeciesCompleted] = useState<boolean>(false);
  const [discoveredClues, setDiscoveredClues] = useState<Array<{
    name: string;
    color: string;
    icon: string;
  }>>([]);

  // Function to show clue toast and add to discovered row
  const showClueToast = (clue: CluePayload) => {
    // Add to discovered clues row (avoid duplicates)
    setDiscoveredClues((prev) => {
      const exists = prev.some((c) => c.name === clue.name);
      if (exists) return prev;
      return [
        ...prev,
        {
          name: clue.name,
          color: clue.color,
          icon: clue.icon,
        },
      ];
    });

    // Show the toast
    toast(clue.name, {
      description: clue.clue,
      icon: clue.icon,
      duration: 5000,
      style: {
        borderLeft: `4px solid ${clue.color}`,
      },
    });
  };

  useEffect(() => {
    // Listen for clue reveals from the game
    const handleClueRevealed = (clueData: CluePayload) => {
      setClues(prev => {
        // Avoid duplicates
        if (prev.some(c => c.category === clueData.category)) return prev;
        const newClues = [...prev, clueData];
        showClueToast(clueData);
        return newClues;
      });
    };

    // Listen for new game starts
    const handleNewGame = (data: { speciesName: string; speciesId: number; totalSpecies: number; currentIndex: number }) => {
      setClues([]);
      setDiscoveredClues([]);
      setSelectedSpeciesName(data.speciesName);
      setSelectedSpeciesId(data.speciesId);
      setTotalSpecies(data.totalSpecies);
      setCurrentSpeciesIndex(data.currentIndex);
      setAllCluesRevealed(false);
      setAllSpeciesCompleted(false);
    };

    // Listen for game reset
    const handleGameReset = () => {
      setClues([]);
      setDiscoveredClues([]);
      setSelectedSpeciesName('');
      setSelectedSpeciesId(0);
      setTotalSpecies(0);
      setCurrentSpeciesIndex(0);
      setAllCluesRevealed(false);
      setAllSpeciesCompleted(false);
    };

    // Listen for no species found
    const handleNoSpeciesFound = () => {
      setSelectedSpeciesName('No species found at this location');
      setClues([]);
      setDiscoveredClues([]);
    };

    // Listen for all clues revealed
    const handleAllCluesRevealed = () => {
      setAllCluesRevealed(true);
      toast.success('All clues revealed!', {
        description: 'Advancing to next species...',
        duration: 3000,
      });
    };

    // Listen for all species completed
    const handleAllSpeciesCompleted = () => {
      setAllSpeciesCompleted(true);
      toast.success('Congratulations!', {
        description: `You have discovered all ${totalSpecies} species at this location.`,
        duration: 5000,
      });
    };

    EventBus.on('clue-revealed', handleClueRevealed);
    EventBus.on('new-game-started', handleNewGame);
    EventBus.on('game-reset', handleGameReset);
    EventBus.on('no-species-found', handleNoSpeciesFound);
    EventBus.on('all-clues-revealed', handleAllCluesRevealed);
    EventBus.on('all-species-completed', handleAllSpeciesCompleted);

    return () => {
      EventBus.off('clue-revealed', handleClueRevealed);
      EventBus.off('new-game-started', handleNewGame);
      EventBus.off('game-reset', handleGameReset);
      EventBus.off('no-species-found', handleNoSpeciesFound);
      EventBus.off('all-clues-revealed', handleAllCluesRevealed);
      EventBus.off('all-species-completed', handleAllSpeciesCompleted);
    };
  }, [totalSpecies]);

  const containerStyle: React.CSSProperties = {
    ...style,
    height: '100%',
    backgroundColor: '#0f172a',
    padding: '6px',
    boxSizing: 'border-box',
    display: 'flex',
    flexDirection: 'column',
    gap: '6px',
  };

  const hasSelectedSpecies = selectedSpeciesId > 0 || (!!selectedSpeciesName && selectedSpeciesName !== 'No species found at this location');

  return (
    <div style={containerStyle}>
      {/* Species Header with Horizontal Clue Indicators */}
      <SpeciesHeaderCard
        speciesName={allSpeciesCompleted ? 'All Species Discovered!' : selectedSpeciesName}
        currentSpeciesIndex={currentSpeciesIndex}
        totalSpecies={totalSpecies}
        revealedClueCount={clues.length}
        discoveredClues={discoveredClues}
        onShowLegend={() => setLegendOpen(true)}
      />

      {/* Compact Field Notes List - Quick Reference */}
      <DenseClueGrid 
        clues={clues} 
        hasSelectedSpecies={hasSelectedSpecies}
      />

      {/* Sheet Button for Detailed View */}
      <div className="flex-shrink-0">
        <ClueSheet 
          clues={clues} 
          speciesName={selectedSpeciesName} 
          hasSelectedSpecies={hasSelectedSpecies}
        />
      </div>

      <GemLegendDialog open={legendOpen} onOpenChange={setLegendOpen} />
    </div>
  );
};

================
File: src/config/habitatColors.ts
================
// src/config/habitatColors.ts

// Habitat color mapping based on IUCN habitat codes
// Colors are from the official IUCN colormap and should match the TiTiler backend.
export const habitatColorMap: Record<string, string> = {
  // Water
  'Water': '#002de1',
  
  // Forest types
  'Forest': '#0a941c',
  'Forest - Boreal': '#115e4e',
  'Forest - Subarctic': '#07a187',
  'Forest - Subantarctic': '#00fac0',
  'Forest - Temperate': '#27a170',
  'Forest - Subtropical-tropical dry': '#9df941',
  'Forest - Subtropical-tropical moist lowland': '#2af434',
  'Forest - Subtropical-tropical mangrove vegetation': '#a0fecc',
  'Forest - Subtropical-tropical swamp': '#677e2d',
  'Forest - Subtropical-tropical moist montane': '#00c410',
  
  // Savanna
  'Savanna': '#c6ff53',
  'Savanna - Dry': '#f5e936',
  'Savanna - Moist': '#cdff27',
  
  // Shrubland
  'Shrubland': '#eaa03f',
  'Shrubland - Subarctic': '#645800',
  'Shrubland - Subantarctic': '#7b7a60',
  'Shrubland - Boreal': '#84a79b',
  'Shrubland - Temperate': '#9addd4',
  'Shrubland - Subtropical-tropical dry': '#ffe97b',
  'Shrubland - Subtropical-tropical moist': '#f0a625',
  'Shrubland - Subtropical-tropical high altitude': '#ce9bc2',
  'Shrubland - Mediterranean-type': '#7f1dd5',
  
  // Grassland
  'Grassland': '#98fae7',
  'Grassland - Tundra': '#bdeed8',
  'Grassland - Subarctic': '#adc4c0',
  'Grassland - Subantarctic': '#264758',
  'Grassland - Temperate': '#33b988',
  'Grassland - Subtropical-tropical dry': '#fff5cb',
  'Grassland - Subtropical-tropical seasonally wet or flooded': '#89e8f0',
  'Grassland - Subtropical-tropical high altitude': '#facbff',
  
  // Wetlands
  'Wetlands (inland)': '#5bb5ff',
  'Wetlands (inland) - Permanent rivers streams creeks': '#00fafa',
  'Wetlands (inland) - Seasonal/intermittent/irregular rivers/streams/creeks': '#d6a0f9',
  'Wetlands (inland) - Shrub dominated wetlands': '#bf2ae8',
  'Wetlands (inland) - Bogs/marshes/swamps/fens/peatlands': '#314872',
  'Wetlands (inland) - Permanent freshwater lakes': '#0e77d9',
  'Wetlands (inland) - Seasonal/intermittent freshwater lakes (over 8 ha)': '#6e96c4',
  'Wetlands (inland) - Permanent freshwater marshes/pools (under 8 ha)': '#00add8',
  'Wetlands (inland) - Seasonal/intermittent freshwater marshes/pools (under 8 ha)': '#218ed6',
  'Wetlands (inland) - Freshwater springs and oases': '#301f99',
  'Wetlands (inland) - Tundra wetlands': '#a1e6ec',
  'Wetlands (inland) - Alpine wetlands': '#c7e1e4',
  'Wetlands (inland) - Geothermal wetlands': '#f9e9d4',
  'Wetlands (inland) - Permanent inland deltas': '#0025fc',
  'Wetlands (inland) - Permanent saline brackish or alkaline lakes': '#166b95',
  'Wetlands (inland) - Seasonal/intermittent saline brackish or alkaline lakes and flats': '#46a4c0',
  'Wetlands (inland) - Permanent /saline / brackish or alkaline marshes/pools': '#3e71e0',
  'Wetlands (inland) - Seasonal/intermittent /saline / brackish or alkaline marshes/pools': '#9c75d0',
  'Wetlands (inland) / Karst and other subterranean hydrological systems': '#ff01bc',

  // Rocky Areas
  'Rocky Areas': '#a59283',
  
  // Desert
  'Desert': '#fffce1',
  'Desert - Hot': '#ffb701',
  'Desert - Temperate': '#e4e9d4',
  'Desert - Cold': '#daedf5',

  // Marine
  'Marine - Neritic': '#99ddf7',
  'Marine - Neritic Pelagic': '#d1ecf7',
  'Marine - Coral Reefs': '#fd7c6e',
  'Marine - Seagrass (submerged)': '#86a475',
  'Marine - Oceanic': '#1da2d8',
  'Marine - Epipelagic': '#1781ac',
  'Marine - Mesopelagic': '#0e516c',
  'Marine - Bathypelagic': '#083040',
  'Marine - Abyssopelagic': '#021015',
  'Marine - Deep Ocean Floor': '#7fcdff',
  'Marine - Continental Slope/Bathyl zone': '#1199d1',
  'Marine - Abyssal Plain ': '#60bde3',
  'Marine - Abyssal Mountains/Hills ': '#1a91c2',
  'Marine - Hadal/Deep Sea Trench ': '#027495',
  'Marine - Seamounts ': '#6baed6',
  'Marine - Deep Sea Vent ': '#7F00FF',
  'Marine - Intertidal': '#4ce6e6',
  'Marine - Tidepools': '#3212b3',
  'Marine - Mangroves submerged Roots': '#7cd9cc',

  // Artificial/Terrestrial
  'Artificial - Terrestrial': '#d95049',
  'Arable land': '#ffa083',
  'Pastureland': '#ff83ca',
  'Plantations': '#FF0800',
  'Rural Gardens': '#ddcb25',
  'Urban Areas': '#000000',
  'Subtropical/Tropical Heavily Degraded Former Forest': '#ff1601',

  // Unknown
  'Unknown': '#ffffff'
};

/**
 * Gets the official IUCN hex color for a given habitat type.
 * @param habitatType The string label of the habitat.
 * @returns The hex color code as a string. Defaults to white ('#ffffff') if the habitat type is not found.
 */
export function getHabitatColor(habitatType: string): string {
  // The official color for 'Unknown' is white. This serves as a good default.
  return habitatColorMap[habitatType] || '#ffffff';
}

================
File: src/game/scenes/Boot.ts
================
import Phaser from 'phaser';

export class Boot extends Phaser.Scene {
    constructor() {
        super('Boot');
    }

    // No preload needed here

    create() {
        console.log("Boot: Starting Preloader");
        this.scene.start('Preloader');
    }
}

================
File: src/game/scenes/Game.ts
================
// src/game/scenes/Game.ts
import Phaser from 'phaser';
import { BackendPuzzle } from '../BackendPuzzle';
import { MoveAction, MoveDirection } from '../MoveAction';
import { BoardView } from '../BoardView';
import {
    GRID_COLS, GRID_ROWS, AssetKeys,
    DRAG_THRESHOLD, MOVE_THRESHOLD
} from '../constants';
import { EventBus, EventPayloads } from '../EventBus';
import { ExplodeAndReplacePhase, Coordinate } from '../ExplodeAndReplacePhase';
import { GemType } from '../constants';
import { GemCategory, CLUE_CONFIG, CluePayload } from '../clueConfig';
import type { Species } from '@/types/database';
import type { RasterHabitatResult } from '@/lib/speciesService';

interface BoardOffset {
    x: number;
    y: number;
}

interface SpritePosition {
    x: number;
    y: number;
    gridX: number;
    gridY: number;
}

export class Game extends Phaser.Scene {
    // --- MVC Components ---
    private backendPuzzle: BackendPuzzle | null = null;
    private boardView: BoardView | null = null;

    // --- Controller State ---
    private canMove: boolean = false; // Start false, true after board init
    private isDragging: boolean = false;
    private dragStartX: number = 0;
    private dragStartY: number = 0;
    private dragDirection: MoveDirection | null = null;
    private dragStartPointerX: number = 0;
    private dragStartPointerY: number = 0;
    private draggingSprites: Phaser.GameObjects.Sprite[] = [];
    private dragStartSpritePositions: SpritePosition[] = [];

    // --- Layout ---
    private gemSize: number = 64;
    private boardOffset: BoardOffset = { x: 0, y: 0 };

    // --- Backend Data ---
    private isBoardInitialized: boolean = false;
    private statusText: Phaser.GameObjects.Text | null = null;
    private scoreText: Phaser.GameObjects.Text | null = null;
    private movesText: Phaser.GameObjects.Text | null = null;
    
    // --- Species Integration ---
    private currentSpecies: Species[] = [];
    private selectedSpecies: Species | null = null;
    private revealedClues: Set<GemCategory> = new Set();
    private currentSpeciesIndex: number = 0;
    private allCluesRevealed: boolean = false;
    // --- Raster Habitat Integration ---
    private rasterHabitats: RasterHabitatResult[] = [];
    private usedRasterHabitats: Set<string> = new Set();

    // Touch event handlers
    private _touchPreventDefaults: ((e: Event) => void) | null = null;
    
    // Layout state
    private isMapMinimized: boolean = false;

    constructor() {
        super('Game');
    }

    update(): void {
        if (!this.backendPuzzle || !this.isBoardInitialized) return;

        // Update UI
        if (this.scoreText) {
            this.scoreText.setText(`Score: ${this.backendPuzzle.getScore()}`);
        }
        if (this.movesText) {
            this.movesText.setText(`Moves: ${this.backendPuzzle.getMovesRemaining()}`);
        }

        // Check game over
        if (this.backendPuzzle.isGameOver() && this.canMove) {
            this.canMove = false;
            const finalScore = this.backendPuzzle.getScore();
            console.log(`Game Over! Final score: ${finalScore}`);
            this.scene.start('GameOver', { score: finalScore });
        }
    }

    create(): void {
        console.log("Game Scene: create");
        const { width, height } = this.scale;

        if (this.textures.exists(AssetKeys.BACKGROUND)) {
            this.add.image(width / 2, height / 2, AssetKeys.BACKGROUND).setOrigin(0.5).setAlpha(0.5);
        } else {
            this.cameras.main.setBackgroundColor('#1a1a2e');
        }

        if (typeof BackendPuzzle === 'undefined' || typeof MoveAction === 'undefined' || typeof BoardView === 'undefined') {
            this.add.text(width / 2, height / 2, `Error: Game logic missing.\nCheck console.`, { 
                color: '#ff0000', 
                fontSize: '20px' 
            }).setOrigin(0.5);
            return;
        }

        this.statusText = this.add.text(width / 2, height / 2, "Waiting for location selection from map...", {
            fontSize: '20px',
            color: '#ffffff',
            backgroundColor: '#000000aa',
            padding: { x: 10, y: 5 },
            align: 'center'
        }).setOrigin(0.5).setDepth(100);

        // Score display
        this.scoreText = this.add.text(20, height - 25, 'Score: 0', {
            fontSize: '20px',
            color: '#ffffff',
            stroke: '#000000',
            strokeThickness: 3
        }).setDepth(100);

        // Moves display
        this.movesText = this.add.text(width - 20, height - 25, 'Moves: 50', {
            fontSize: '20px',
            color: '#ffffff',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(1, 0).setDepth(100);


        // Initialize BackendPuzzle and BoardView, but board visuals are created later
        this.backendPuzzle = new BackendPuzzle(GRID_COLS, GRID_ROWS);
        this.calculateBoardDimensions();
        this.boardView = new BoardView(this, {
            cols: GRID_COLS,
            rows: GRID_ROWS,
            gemSize: this.gemSize,
            boardOffset: this.boardOffset
        });

        this.input.addPointer(1);
        this.disableTouchScrolling();
        this.input.on(Phaser.Input.Events.POINTER_DOWN, this.handlePointerDown, this);
        this.input.on(Phaser.Input.Events.POINTER_MOVE, this.handlePointerMove, this);
        this.input.on(Phaser.Input.Events.POINTER_UP, this.handlePointerUp, this);
        this.input.on(Phaser.Input.Events.POINTER_UP_OUTSIDE, this.handlePointerUp, this);
        this.scale.on(Phaser.Scale.Events.RESIZE, this.handleResize, this);
        EventBus.on('cesium-location-selected', this.initializeBoardFromCesium, this);
        EventBus.on('layout-changed', this.handleLayoutChange, this);

        this.resetDragState(); // Resets isDragging etc.
        this.canMove = false; // Input disabled until board initialized by Cesium
        this.isBoardInitialized = false;

        EventBus.emit('current-scene-ready', this);
        console.log("Game Scene: Create method finished. Waiting for Cesium data.");
    }

    private initializeBoardFromCesium(data: EventPayloads['cesium-location-selected']): void {
        console.log("Game Scene: Received 'cesium-location-selected' data:", data);
        this.canMove = false; // Disable moves during reinitialization
        this.isBoardInitialized = false; // Mark as not ready
        const { width, height } = this.scale;

        if (this.statusText && this.statusText.active) {
            this.statusText.setText("Initializing new game board...");
        }

        try {
            // Sort species by ogc_fid (lowest first)
            this.currentSpecies = [...data.species].sort((a, b) => a.ogc_fid - b.ogc_fid);
            this.currentSpeciesIndex = 0;
            this.revealedClues.clear(); // Reset clues for new game
            this.allCluesRevealed = false;
            
            // Store raster habitat data for green gem clues
            this.rasterHabitats = [...data.rasterHabitats];
            this.usedRasterHabitats.clear(); // Reset used raster habitats for new game
            console.log("Game Scene: Stored raster habitats:", this.rasterHabitats);
            
            if (this.currentSpecies.length > 0) {
                // Select the species with lowest ogc_fid
                this.selectedSpecies = this.currentSpecies[0];
                console.log("Game Scene: Selected species:", this.selectedSpecies.comm_name || this.selectedSpecies.sci_name, "ogc_fid:", this.selectedSpecies.ogc_fid);
                
                // Emit event to inform React components about the new game
                EventBus.emit('new-game-started', {
                    speciesName: this.selectedSpecies.comm_name || this.selectedSpecies.sci_name || 'Unknown Species',
                    speciesId: this.selectedSpecies.ogc_fid,
                    totalSpecies: this.currentSpecies.length,
                    currentIndex: this.currentSpeciesIndex + 1
                });
            } else {
                this.selectedSpecies = null;
                console.log("Game Scene: No species available for this location");
                EventBus.emit('no-species-found', {});
            }

            if (!this.backendPuzzle) { // Should exist from create()
                this.backendPuzzle = new BackendPuzzle(GRID_COLS, GRID_ROWS);
            }
            // Regenerate the board with new random gems
            this.backendPuzzle.regenerateBoard();

            this.calculateBoardDimensions(); // Recalculate for current scale
            if (!this.boardView) { // Should exist from create()
                this.boardView = new BoardView(this, {
                    cols: GRID_COLS,
                    rows: GRID_ROWS,
                    gemSize: this.gemSize,
                    boardOffset: this.boardOffset
                });
            } else {
                // Update boardView dimensions without animating (board will be recreated)
                this.boardView.updateDimensions(this.gemSize, this.boardOffset);
            }

            // Destroy old board sprites and create new ones based on the (potentially new) backendPuzzle state
            if (this.boardView.destroyBoard) this.boardView.destroyBoard();
            this.boardView.createBoard(this.backendPuzzle.getGridState());

            if (this.statusText && this.statusText.active) {
                this.statusText.destroy();
                this.statusText = null;
            }
            this.isBoardInitialized = true;
            this.canMove = true; // Board is ready, enable input
            console.log("Game Scene: Board initialized with random gems. Input enabled.");

        } catch (error) {
            console.error("Game Scene: Error initializing board from Cesium data:", error);
            if (this.statusText && this.statusText.active) this.statusText.destroy();
            
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.statusText = this.add.text(width / 2, height / 2, `Error initializing board:\n${errorMessage}`, {
                fontSize: '18px',
                color: '#ff4444',
                backgroundColor: '#000000cc',
                align: 'center',
                padding: { x: 10, y: 5 },
                wordWrap: { width: width * 0.8 }
            }).setOrigin(0.5).setDepth(100);
            this.canMove = false;
            this.isBoardInitialized = false;
        }
    }

    private calculateBoardDimensions(): void {
        const { width, height } = this.scale;
        if (width <= 0 || height <= 0) {
            console.warn("Invalid scale dimensions.");
            return;
        }
        
        // Define constants for UI space
        const TOP_UI_OFFSET = 60; // Space for score/moves text at top
        
        const usableWidth = width * 0.95;
        
        // When map is minimized, use more vertical space but leave room at top for UI
        const usableHeight = this.isMapMinimized 
            ? height - TOP_UI_OFFSET - 20  // Almost full height minus top UI
            : height * 0.90;               // Original logic
        
        const sizeFromWidth = Math.floor(usableWidth / GRID_COLS);
        const sizeFromHeight = Math.floor(usableHeight / GRID_ROWS);
        this.gemSize = Math.max(24, Math.min(sizeFromWidth, sizeFromHeight));
        const boardWidth = GRID_COLS * this.gemSize;
        const boardHeight = GRID_ROWS * this.gemSize;
        
        // X offset is still centered
        const boardOffsetX = Math.round((width - boardWidth) / 2);
        
        // Y offset changes based on map minimized state
        const boardOffsetY = this.isMapMinimized
            ? TOP_UI_OFFSET  // Position right below top UI when map minimized
            : Math.round((height - boardHeight) / 2); // Center vertically normally
        
        this.boardOffset = {
            x: boardOffsetX,
            y: boardOffsetY
        };
    }
    
    private handleLayoutChange(data: { mapMinimized: boolean }): void {
        console.log(`Game Scene: Layout changed - Map minimized = ${data.mapMinimized}`);
        this.isMapMinimized = data.mapMinimized;
        
        // Trigger a resize/recalculation to update board position
        this.handleResize();
    }

    private handleResize(): void {
        console.log("Game Scene: Resize detected.");
        const { width, height } = this.scale;
        this.calculateBoardDimensions();
        
        if (this.statusText && this.statusText.active) {
            this.statusText.setPosition(width / 2, height / 2);
            const textStyle = this.statusText.style;
            if (textStyle && typeof textStyle.setWordWrapWidth === 'function') {
                textStyle.setWordWrapWidth(width * 0.8);
            }
        }
        
        // Update UI positions
        if (this.movesText) {
            this.movesText.setPosition(width - 20, height - 25);
        }
        if (this.scoreText) {
            this.scoreText.setPosition(20, height - 25);
        }
        
        if (this.boardView) {
            this.boardView.updateVisualLayout(this.gemSize, this.boardOffset);
        }
    }

    private handlePointerDown(pointer: Phaser.Input.Pointer): void {
        if (!this.canMove || !this.isBoardInitialized || !this.boardView || !this.backendPuzzle) return;
        if (this.isDragging) { // Should not happen if logic is correct, but as a safeguard
            console.warn("PointerDown while already dragging. Resetting drag state.");
            this.resetDragState(); // Reset internal flags
            // Visually snap back any lingering sprites from a broken drag state
            if (this.boardView && this.draggingSprites.length > 0) {
                this.boardView.snapBack(this.draggingSprites, this.dragStartSpritePositions, undefined, 0, 0)
                    .catch(e => console.error("Error snapping back during PointerDown reset:", e));
            }
            this.draggingSprites = []; // Ensure these are clear
            this.dragStartSpritePositions = [];
        }

        const worldX = pointer.x;
        const worldY = pointer.y;
        const boardRect = new Phaser.Geom.Rectangle(
            this.boardOffset.x, this.boardOffset.y,
            GRID_COLS * this.gemSize, GRID_ROWS * this.gemSize
        );

        if (!boardRect.contains(worldX, worldY)) return;

        const gridX = Math.floor((worldX - this.boardOffset.x) / this.gemSize);
        const gridY = Math.floor((worldY - this.boardOffset.y) / this.gemSize);

        this.dragStartX = Phaser.Math.Clamp(gridX, 0, GRID_COLS - 1);
        this.dragStartY = Phaser.Math.Clamp(gridY, 0, GRID_ROWS - 1);
        this.dragStartPointerX = worldX;
        this.dragStartPointerY = worldY;
        this.isDragging = true; // Set drag flag
        this.dragDirection = null;
        // IMPORTANT: Initialize these here for the new drag operation
        this.draggingSprites = [];
        this.dragStartSpritePositions = [];
    }

    private handlePointerMove(pointer: Phaser.Input.Pointer): void {
        if (!this.isDragging || !this.canMove || !this.isBoardInitialized || !this.boardView) return;
        if (!pointer.isDown) {
            this.handlePointerUp(pointer); // Treat as pointer up if button released
            return;
        }

        const worldX = pointer.x;
        const worldY = pointer.y;
        const deltaX = worldX - this.dragStartPointerX;
        const deltaY = worldY - this.dragStartPointerY;

        if (!this.dragDirection && (Math.abs(deltaX) > DRAG_THRESHOLD || Math.abs(deltaY) > DRAG_THRESHOLD)) {
            this.dragDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'row' : 'col';
            const allSprites = this.boardView.getGemsSprites();
            if (!allSprites) {
                this.cancelDrag("BoardView sprites unavailable");
                return;
            }

            const index = (this.dragDirection === 'row') ? this.dragStartY : this.dragStartX;
            const limit = (this.dragDirection === 'row') ? GRID_COLS : GRID_ROWS;

            // Clear and repopulate for this drag action
            this.draggingSprites = [];
            this.dragStartSpritePositions = [];

            for (let i = 0; i < limit; i++) {
                const x = (this.dragDirection === 'row') ? i : index;
                const y = (this.dragDirection === 'row') ? index : i;
                const sprite = allSprites[x]?.[y];
                if (sprite && sprite.active) {
                    this.draggingSprites.push(sprite);
                    this.dragStartSpritePositions.push({ x: sprite.x, y: sprite.y, gridX: x, gridY: y });
                    this.tweens.killTweensOf(sprite);
                }
            }
            if (this.draggingSprites.length === 0) {
                this.cancelDrag("No sprites in dragged line");
                return;
            }
        }

        if (this.dragDirection) {
            this.boardView.moveDraggingSprites(
                this.draggingSprites, this.dragStartSpritePositions, deltaX, deltaY, this.dragDirection
            );
        }
    }

    private async handlePointerUp(pointer: Phaser.Input.Pointer): Promise<void> {
        // Store these values *before* calling resetDragState or any async operation
        const wasDragging = this.isDragging;
        const currentDragDirection = this.dragDirection;
        const dSprites = [...this.draggingSprites]; // Critical: Copy before resetDragState clears them
        const dStartPositions = [...this.dragStartSpritePositions]; // Critical: Copy
        const sPointerX = this.dragStartPointerX;
        const sPointerY = this.dragStartPointerY;
        const sGridX = this.dragStartX;
        const sGridY = this.dragStartY;

        if (!wasDragging) { // If not dragging (e.g. just a click, or already processed)
            this.resetDragState(); // Still reset to be safe
            return;
        }

        // Reset drag state flags immediately. Visuals handled based on match outcome.
        this.resetDragState();

        // Calculate deltas here as they are used in multiple branches below
        // These are the deltas from the start of the drag to the point of pointer release.
        const worldX = pointer.x;
        const worldY = pointer.y;
        const deltaX = worldX - sPointerX;
        const deltaY = worldY - sPointerY;

        if (!this.canMove || !this.isBoardInitialized || !this.boardView || !this.backendPuzzle) {
            console.warn("PointerUp: Conditions not met (canMove, board not ready, etc.).");
            if (dSprites.length > 0 && this.boardView) {
                // Pass currentDragDirection (which might be null) and calculated deltas.
                // The snapBack in BoardView will need to handle a potentially null dragDirection gracefully.
                await this.boardView.snapBack(dSprites, dStartPositions, currentDragDirection || undefined, deltaX, deltaY);
            }
            return; // Do not proceed further
        }

        if (!currentDragDirection || dSprites.length === 0) {
            console.log("Pointer up: No valid drag determined or no sprites collected.");
            if (dSprites.length > 0 && this.boardView) {
                // currentDragDirection is null or dSprites is empty.
                // Pass currentDragDirection (which is likely null) and deltas (which might be small/zero).
                // snapBack should handle this by likely defaulting to a non-sliding snap if direction is missing.
                await this.boardView.snapBack(dSprites, dStartPositions, currentDragDirection || undefined, deltaX, deltaY);
            }
            return;
        }

        this.canMove = false; // Disable input for processing the move

        const moveAction = this.calculateMoveAction(deltaX, deltaY, currentDragDirection, sGridX, sGridY);

        try {
            if (moveAction.amount === 0) {
                console.log("Pointer up: No logical move threshold met, snapping back.");
                await this.boardView.snapBack(dSprites, dStartPositions, currentDragDirection || undefined, deltaX, deltaY);
            } else {
                const hypotheticalMatches = this.backendPuzzle.getMatchesFromHypotheticalMove(moveAction);

                if (hypotheticalMatches && hypotheticalMatches.length > 0) {
                    console.log(`Pointer up: Committing move (Matches found)`);
                    this.boardView.updateGemsSpritesArrayAfterMove(moveAction);
                    this.boardView.snapDraggedGemsToFinalGridPositions();
                    await this.applyMoveAndHandleResults(moveAction);
                } else {
                    console.log(`Pointer up: Move resulted in NO matches. Snapping back.`);
                    await this.boardView.snapBack(dSprites, dStartPositions, currentDragDirection || undefined, deltaX, deltaY);
                }
            }
        } catch (error) {
            console.error("Error processing pointer up:", error);
            if (dSprites.length > 0 && this.boardView) {
                await this.boardView.snapBack(dSprites, dStartPositions, currentDragDirection || undefined, deltaX, deltaY);
            }
            if (this.boardView && this.backendPuzzle) {
                this.boardView.syncSpritesToGridPositions();
            }
        } finally {
            this.canMove = true;
        }
    }

    private async applyMoveAndHandleResults(moveAction: MoveAction): Promise<void> {
        if (!this.backendPuzzle || !this.boardView) return;
        
        // Capture grid state BEFORE applying the move to get original gem types
        const gridStateBeforeMove = this.backendPuzzle.getGridState();
        const phaseResult = this.backendPuzzle.getNextExplodeAndReplacePhase([moveAction]); // This applies the move
        
        if (!phaseResult.isNothingToDo()) {
            await this.animatePhaseWithOriginalGems(phaseResult, gridStateBeforeMove);
            await this.handleCascades();
        } else {
            console.warn("applyMoveAndHandleResults: Move was applied, but backend reports no matches. This might be a logic discrepancy.");
        }
    }

    private async handleCascades(): Promise<void> {
        if (!this.backendPuzzle || !this.boardView) return;
        
        // Capture grid state BEFORE checking for cascade matches
        const gridStateBeforeCascade = this.backendPuzzle.getGridState();
        const cascadePhase = this.backendPuzzle.getNextExplodeAndReplacePhase([]);
        
        if (!cascadePhase.isNothingToDo()) {
            await this.animatePhaseWithOriginalGems(cascadePhase, gridStateBeforeCascade);
            await this.handleCascades();
        }
    }

    private async animatePhaseWithOriginalGems(phaseResult: ExplodeAndReplacePhase, originalGridState: any): Promise<void> {
        if (!this.boardView || !this.backendPuzzle) return;
        try {
            // Process clues using original gem types
            this.processMatchedGemsWithOriginalTypes(phaseResult.matches, originalGridState);
            
            await this.boardView.animateExplosions(phaseResult.matches.flat());
            await this.boardView.animateFalls(phaseResult.replacements, this.backendPuzzle.getGridState());
        } catch (error) {
            console.error("Error during phase animation:", error);
            if (this.boardView && this.backendPuzzle) {
                this.boardView.syncSpritesToGridPositions();
            }
        }
    }

    private async animatePhase(phaseResult: ExplodeAndReplacePhase): Promise<void> {
        if (!this.boardView || !this.backendPuzzle) return;
        try {
            // Process clues using current grid state (fallback method)
            this.processMatchedGemsForClues(phaseResult.matches);
            
            await this.boardView.animateExplosions(phaseResult.matches.flat());
            await this.boardView.animateFalls(phaseResult.replacements, this.backendPuzzle.getGridState());
        } catch (error) {
            console.error("Error during phase animation:", error);
            if (this.boardView && this.backendPuzzle) {
                this.boardView.syncSpritesToGridPositions();
            }
        }
    }

    private processMatchedGemsWithOriginalTypes(matches: Coordinate[][], originalGridState: any): void {
        if (!this.selectedSpecies || matches.length === 0) return;

        // Debug: Log all matches
        console.log("Game Scene: Processing matches with original gem types:", matches.length, "match groups");
        
        // Extract all gem types from matched coordinates using original grid state
        const matchedGemTypes = new Set<GemType>();
        
        for (const match of matches) {
            console.log("Game Scene: Match group with", match.length, "gems at coords:", match);
            for (const coord of match) {
                const [x, y] = coord;
                const gem = originalGridState[x]?.[y];
                if (gem) {
                    console.log(`Game Scene: Original gem at [${x},${y}] was ${gem.gemType}`);
                    matchedGemTypes.add(gem.gemType);
                }
            }
        }

        // Convert gem types to categories and generate clues
        for (const gemType of matchedGemTypes) {
            const category = this.gemTypeToCategory(gemType);
            if (category !== null && !this.revealedClues.has(category)) {
                this.revealedClues.add(category);
                
                // Generate clue for this category
                let clueData: CluePayload | null = null;
                if (category === GemCategory.HABITAT) {
                    // Use raster habitat data for green gems
                    clueData = this.generateRasterHabitatClue();
                } else {
                    // Use CLUE_CONFIG for species-based clues
                    const config = CLUE_CONFIG[category];
                    if (config) {
                        const clueText = config.getClue(this.selectedSpecies);
                        if (clueText) {
                            clueData = {
                                category,
                                heading: this.selectedSpecies.comm_name || this.selectedSpecies.sci_name || 'Unknown Species',
                                clue: clueText,
                                speciesId: this.selectedSpecies.ogc_fid,
                                name: config.categoryName,
                                icon: config.icon,
                                color: config.color
                            };
                        }
                    }
                }
                
                if (clueData && clueData.clue) {
                    console.log("Game Scene: Revealing clue for category:", category, clueData);
                    EventBus.emit('clue-revealed', clueData);
                }
            }
        }
    }

    private processMatchedGemsForClues(matches: Coordinate[][]): void {
        if (!this.selectedSpecies || matches.length === 0) return;

        // Debug: Log all matches
        console.log("Game Scene: Processing matches:", matches.length, "match groups");
        
        // Extract all gem types from matched coordinates
        const matchedGemTypes = new Set<GemType>();
        
        for (const match of matches) {
            console.log("Game Scene: Match group with", match.length, "gems at coords:", match);
            for (const coord of match) {
                if (this.backendPuzzle) {
                    const [x, y] = coord;
                    const gridState = this.backendPuzzle.getGridState();
                    const gem = gridState[x]?.[y];
                    if (gem) {
                        console.log(`Game Scene: Gem at [${x},${y}] is ${gem.gemType}`);
                        matchedGemTypes.add(gem.gemType);
                    }
                }
            }
        }

        // Convert gem types to categories and generate clues
        for (const gemType of matchedGemTypes) {
            const category = this.gemTypeToCategory(gemType);
            if (category !== null && !this.revealedClues.has(category)) {
                this.revealedClues.add(category);
                
                // Generate clue for this category
                let clueData: CluePayload | null = null;
                if (category === GemCategory.HABITAT) {
                    // Use raster habitat data for green gems
                    clueData = this.generateRasterHabitatClue();
                } else {
                    // Use CLUE_CONFIG for species-based clues
                    const config = CLUE_CONFIG[category];
                    if (config) {
                        const clueText = config.getClue(this.selectedSpecies);
                        if (clueText) {
                            clueData = {
                                category,
                                heading: this.selectedSpecies.comm_name || this.selectedSpecies.sci_name || 'Unknown Species',
                                clue: clueText,
                                speciesId: this.selectedSpecies.ogc_fid,
                                name: config.categoryName,
                                icon: config.icon,
                                color: config.color
                            };
                        }
                    }
                }
                
                if (clueData && clueData.clue) {
                    console.log("Game Scene: Revealing clue for category:", category, clueData);
                    EventBus.emit('clue-revealed', clueData);
                }
            }
        }

        // Check if all clues are revealed (9 categories total)
        if (this.revealedClues.size >= 9 && !this.allCluesRevealed) {
            this.allCluesRevealed = true;
            console.log("Game Scene: All clues revealed for species:", this.selectedSpecies.ogc_fid);
            
            // Emit event that all clues are revealed
            EventBus.emit('all-clues-revealed', {
                speciesId: this.selectedSpecies.ogc_fid
            });
            
            // Advance to next species after a delay
            this.time.delayedCall(2000, () => {
                this.advanceToNextSpecies();
            });
        }
    }

    private advanceToNextSpecies(): void {
        this.currentSpeciesIndex++;
        
        if (this.currentSpeciesIndex < this.currentSpecies.length) {
            // Move to next species
            this.selectedSpecies = this.currentSpecies[this.currentSpeciesIndex];
            this.revealedClues.clear();
            this.allCluesRevealed = false;
            this.usedRasterHabitats.clear(); // Reset used raster habitats for new species
            
            console.log("Game Scene: Advancing to next species:", this.selectedSpecies.comm_name || this.selectedSpecies.sci_name, "ogc_fid:", this.selectedSpecies.ogc_fid);
            
            // Emit event for new species
            EventBus.emit('new-game-started', {
                speciesName: this.selectedSpecies.comm_name || this.selectedSpecies.sci_name || 'Unknown Species',
                speciesId: this.selectedSpecies.ogc_fid,
                totalSpecies: this.currentSpecies.length,
                currentIndex: this.currentSpeciesIndex + 1
            });
        } else {
            // All species completed
            console.log("Game Scene: All species completed!");
            EventBus.emit('all-species-completed', {
                totalSpecies: this.currentSpecies.length
            });
        }
    }

    private gemTypeToCategory(gemType: GemType): GemCategory | null {
        // Map gem types to categories based on corrected color scheme
        switch (gemType) {
            case 'red': return GemCategory.CLASSIFICATION;
            case 'green': return GemCategory.HABITAT;
            case 'blue': return GemCategory.GEOGRAPHIC; // Now includes habitat info
            case 'orange': return GemCategory.MORPHOLOGY; // Combines color/pattern and size/shape
            case 'white': return GemCategory.BEHAVIOR; // Now includes diet info
            case 'black': return GemCategory.LIFE_CYCLE;
            case 'yellow': return GemCategory.CONSERVATION;
            case 'purple': return GemCategory.KEY_FACTS; // Uses key_fact1, key_fact2, key_fact3
            default: return null;
        }
    }

    private resetDragState(): void {
        this.isDragging = false;
        this.dragDirection = null;
        this.draggingSprites = []; // Ensure these are cleared
        this.dragStartSpritePositions = []; // Ensure these are cleared
        // dragStartX, Y, etc., are fine to be overwritten on next POINTER_DOWN
    }

    private cancelDrag(reason: string = "Cancelled"): void {
        console.warn(`Drag cancelled: ${reason}`);
        if (this.boardView && this.draggingSprites.length > 0 && this.dragStartSpritePositions.length > 0) {
            this.boardView.snapBack(this.draggingSprites, this.dragStartSpritePositions, undefined, 0, 0)
                .catch(err => console.error("Error snapping back on cancel:", err));
        }
        this.resetDragState();
        if (this.isBoardInitialized) this.canMove = true;
    }

    private calculateMoveAction(deltaX: number, deltaY: number, direction: MoveDirection, startGridX: number, startGridY: number): MoveAction {
        let cellsMoved = 0;
        let index = 0;
        if (direction === 'row') {
            cellsMoved = deltaX / this.gemSize;
            index = startGridY;
        } else { // 'col'
            cellsMoved = deltaY / this.gemSize;
            index = startGridX;
        }
        let amount = 0;
        if (Math.abs(cellsMoved) >= MOVE_THRESHOLD) {
            amount = Math.round(cellsMoved);
        }
        return new MoveAction(direction, index, amount);
    }

    private disableTouchScrolling(): void {
        if (this.game.canvas) {
            this.game.canvas.style.touchAction = 'none';
            const opts = { passive: false };
            const preventDefault = (e: Event) => e.preventDefault();
            this.game.canvas.addEventListener('touchstart', preventDefault, opts);
            this.game.canvas.addEventListener('touchmove', preventDefault, opts);
            this._touchPreventDefaults = preventDefault;
        }
    }

    private enableTouchScrolling(): void {
        if (this.game.canvas) {
            this.game.canvas.style.touchAction = 'auto';
            if (this._touchPreventDefaults) {
                this.game.canvas.removeEventListener('touchstart', this._touchPreventDefaults);
                this.game.canvas.removeEventListener('touchmove', this._touchPreventDefaults);
                this._touchPreventDefaults = null;
            }
        }
    }

    /**
     * Generate a raster habitat clue from the stored habitat distribution data
     */
    private generateRasterHabitatClue(): CluePayload | null {
        if (!this.selectedSpecies) return null;
        
        // Find the next unused habitat type from raster data
        const availableHabitats = this.rasterHabitats.filter(
            habitat => !this.usedRasterHabitats.has(habitat.habitat_type)
        );
        
        if (availableHabitats.length === 0) {
            console.log("Game Scene: No more raster habitat types available for clues");
            return null;
        }
        
        // Get the habitat with highest percentage (first one since they're sorted DESC)
        const nextHabitat = availableHabitats[0];
        this.usedRasterHabitats.add(nextHabitat.habitat_type);
        
        const clue = `Search Area is ${nextHabitat.percentage}% ${nextHabitat.habitat_type}`;
        
        console.log("Game Scene: Generated raster habitat clue:", clue);
        
        const habitatConfig = CLUE_CONFIG[GemCategory.HABITAT];
        return {
            category: GemCategory.HABITAT,
            heading: this.selectedSpecies.comm_name || this.selectedSpecies.sci_name || 'Unknown Species',
            clue: clue,
            speciesId: this.selectedSpecies.ogc_fid,
            name: habitatConfig.categoryName,
            icon: habitatConfig.icon,
            color: habitatConfig.color
        };
    }

    shutdown(): void {
        console.log("Game Scene: Shutting down...");
        EventBus.off('cesium-location-selected', this.initializeBoardFromCesium, this);
        EventBus.off('layout-changed', this.handleLayoutChange, this);
        this.scale.off(Phaser.Scale.Events.RESIZE, this.handleResize, this);
        this.input.removeAllListeners(Phaser.Input.Events.POINTER_DOWN);
        this.input.removeAllListeners(Phaser.Input.Events.POINTER_MOVE);
        this.input.removeAllListeners(Phaser.Input.Events.POINTER_UP);
        this.input.removeAllListeners(Phaser.Input.Events.POINTER_UP_OUTSIDE);
        this.enableTouchScrolling();

        if (this.boardView) {
            this.boardView.destroyBoard();
            this.boardView = null;
        }
        this.backendPuzzle = null;
        if (this.statusText) {
            this.statusText.destroy();
            this.statusText = null;
        }
        if (this.scoreText) {
            this.scoreText.destroy();
            this.scoreText = null;
        }
        if (this.movesText) {
            this.movesText.destroy();
            this.movesText = null;
        }

        this.resetDragState(); // Clear drag state variables
        this.canMove = false;
        this.isBoardInitialized = false;
        
        // Reset species data
        this.currentSpecies = [];
        this.selectedSpecies = null;
        this.revealedClues.clear();
        this.currentSpeciesIndex = 0;
        this.allCluesRevealed = false;
        
        // Reset raster habitat data
        this.rasterHabitats = [];
        this.usedRasterHabitats.clear();
        
        // Emit game reset event
        EventBus.emit('game-reset', undefined);
        
        console.log("Game Scene: Shutdown complete.");
    }

    private verifyBoardState(): void {
        if (!this.backendPuzzle || !this.boardView) return;
        const modelState = this.backendPuzzle.getGridState();
        const viewSprites = this.boardView.getGemsSprites();
        let mismatches = 0;
        for (let x = 0; x < GRID_COLS; x++) {
            for (let y = 0; y < GRID_ROWS; y++) {
                const modelGem = modelState[x]?.[y];
                const viewSprite = viewSprites[x]?.[y];
                if (!modelGem && viewSprite && viewSprite.active) {
                    console.warn(`Verify Mismatch: View sprite at [${x},${y}], Model empty.`);
                    mismatches++;
                } else if (modelGem && (!viewSprite || !viewSprite.active)) {
                    console.warn(`Verify Mismatch: Model gem '${modelGem.gemType}' at [${x},${y}], View no active sprite.`);
                    mismatches++;
                } else if (modelGem && viewSprite && viewSprite.active) {
                    if (viewSprite.getData('gemType') !== modelGem.gemType) {
                        console.warn(`Verify Mismatch: Type diff at [${x},${y}]. M: ${modelGem.gemType}, V: ${viewSprite.getData('gemType')}`);
                        mismatches++;
                    }
                    if (viewSprite.getData('gridX') !== x || viewSprite.getData('gridY') !== y) {
                        console.warn(`Verify Mismatch: Sprite at [${x},${y}] thinks its pos is [${viewSprite.getData('gridX')},${viewSprite.getData('gridY')}]`);
                        mismatches++;
                    }
                }
            }
        }
        if (mismatches === 0) console.log("Verify Board State: OK.");
        else console.error(`Verify Board State: Found ${mismatches} Mismatches!`);
    }
}

================
File: src/game/scenes/GameOver.ts
================
import Phaser from 'phaser';
import { AssetKeys } from '../constants';
import { supabase } from '@/lib/supabaseClient';

export class GameOver extends Phaser.Scene {
    private finalScore: number = 0;
    
    constructor() {
        super('GameOver');
    }

    init(data: { score?: number }) {
        this.finalScore = data.score || 0;
    }

    async saveScore(username: string, score: number): Promise<boolean> {
        try {
            const trimmedUsername = username.trim();
            if (trimmedUsername.length < 2 || trimmedUsername.length > 25) {
                alert('Username must be between 2 and 25 characters');
                return false;
            }

            const { data, error } = await supabase
                .from('high_scores')
                .insert([{ 
                    username: trimmedUsername, 
                    score
                }])
                .select()
                .single();

            if (error) {
                console.error("Supabase Error:", error.message);
                alert(`Error saving score: ${error.message}`);
                return false;
            }
            
            console.log("Score saved successfully!", data);
            return true;
        } catch (err: any) {
            console.error('Unexpected error:', err);
            alert('Could not connect to server');
            return false;
        }
    }

    create(): void {
        console.log("GameOver: create");
        const { width, height } = this.cameras.main;
        const centerX = width / 2;
        const centerY = height / 2;

        // Dim background
        this.add.rectangle(centerX, centerY, width, height, 0x000000, 0.6).setOrigin(0.5);

        // Background Image (optional, faded)
        if (this.textures.exists(AssetKeys.BACKGROUND)) {
            this.add.image(centerX, centerY, AssetKeys.BACKGROUND).setOrigin(0.5).setAlpha(0.3);
        }

        // Game Over Text
        this.add.text(centerX, centerY * 0.6, 'Game Over', {
            fontFamily: 'Arial Black',
            fontSize: `${Math.min(width * 0.1, height * 0.15)}px`, // Ensure 'px' unit
            color: '#ff4444', // Red color
            stroke: '#000000',
            strokeThickness: 8,
            align: 'center'
        }).setOrigin(0.5);

        // Score display
        this.add.text(centerX, centerY * 0.9, `Final Score: ${this.finalScore}`, {
            fontFamily: 'Arial',
            fontSize: `${Math.min(width * 0.06, height * 0.08)}px`,
            color: '#ffff00',
            stroke: '#000000',
            strokeThickness: 4,
            align: 'center'
        }).setOrigin(0.5);

        // Restart instruction
         const restartText = this.add.text(centerX, centerY * 1.3, 'Click to Save Score & Restart', {
            fontFamily: 'Arial',
            fontSize: `${Math.min(width * 0.05, height * 0.06)}px`, // Ensure 'px' unit
            color: '#eeeeee',
            align: 'center'
        }).setOrigin(0.5);

        // Pulse effect
        this.tweens.add({
            targets: restartText,
            alpha: 0.6,
            duration: 900,
            ease: 'Sine.easeInOut',
            yoyo: true,
            repeat: -1
        });

        // Input to save score and return to Main Menu
        this.input.once(Phaser.Input.Events.POINTER_DOWN, async () => {
            const username = prompt("Enter your name to save score (2-25 characters):", "Player");

            if (username && username.trim()) {
                await this.saveScore(username, this.finalScore);
            }
            
            console.log("GameOver: Returning to MainMenu...");
            this.cameras.main.fadeOut(250, 0, 0, 0, (camera: Phaser.Cameras.Scene2D.Camera, progress: number) => {
                if (progress === 1) {
                    this.scene.start('MainMenu');
                }
            });
        });
    }
}

================
File: src/game/scenes/MainMenu.ts
================
import Phaser from 'phaser';
import { AssetKeys } from '../constants';

export class MainMenu extends Phaser.Scene {
    constructor() {
        super('MainMenu');
    }

    create(): void {
        console.log("MainMenu: create");
        const { width, height } = this.cameras.main;
        const centerX = width / 2;
        const centerY = height / 2;

        // Background
        if (this.textures.exists(AssetKeys.BACKGROUND)) {
            this.add.image(centerX, centerY, AssetKeys.BACKGROUND).setOrigin(0.5);
        } else {
            console.warn("Background texture not found in MainMenu scene.");
            this.cameras.main.setBackgroundColor('#3498db'); // Fallback color
        }

        // Logo
        if (this.textures.exists(AssetKeys.LOGO)) {
            this.add.image(centerX, centerY * 0.6, AssetKeys.LOGO).setOrigin(0.5).setScale(0.8); // Adjust position/scale
        } else {
             console.warn("Logo texture not found in MainMenu scene.");
        }

        // Title Text
        this.add.text(centerX, centerY, 'Phaser Match-3', {
            fontFamily: 'Arial Black', // Use a web-safe font or load custom
            fontSize: `${Math.min(width * 0.08, height * 0.1)}px`, // Responsive font size with 'px'
            color: '#ffffff',
            stroke: '#111111',
            strokeThickness: 6,
            align: 'center'
        }).setOrigin(0.5);

        // Play Button
        const playButton = this.add.text(centerX, centerY * 1.4, 'Play Game', {
            fontFamily: 'Arial',
            fontSize: `${Math.min(width * 0.05, height * 0.06)}px`,
            color: '#ffffff',
            backgroundColor: '#4CAF50',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();

        // High Scores Button
        const highScoresButton = this.add.text(centerX, centerY * 1.65, 'High Scores', {
            fontFamily: 'Arial',
            fontSize: `${Math.min(width * 0.04, height * 0.05)}px`,
            color: '#ffffff',
            backgroundColor: '#2196F3',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();

        // Button hover effects
        playButton.on('pointerover', () => {
            playButton.setStyle({ backgroundColor: '#5CBF60' });
        });
        playButton.on('pointerout', () => {
            playButton.setStyle({ backgroundColor: '#4CAF50' });
        });

        highScoresButton.on('pointerover', () => {
            highScoresButton.setStyle({ backgroundColor: '#42A5F5' });
        });
        highScoresButton.on('pointerout', () => {
            highScoresButton.setStyle({ backgroundColor: '#2196F3' });
        });

        // Simple pulse effect for the play button
        this.tweens.add({
            targets: playButton,
            scaleX: 1.05,
            scaleY: 1.05,
            duration: 800,
            ease: 'Sine.easeInOut',
            yoyo: true,
            repeat: -1
        });

        // Play button click handler
        playButton.on('pointerdown', () => {
            console.log("MainMenu: Starting Game scene...");
            // Add a brief fade out effect (optional)
             this.cameras.main.fadeOut(250, 0, 0, 0, (camera: Phaser.Cameras.Scene2D.Camera, progress: number) => {
                 if (progress === 1) {
                      this.scene.start('Game');
                 }
             });
        });

        // High Scores button click handler
        highScoresButton.on('pointerdown', () => {
            console.log("MainMenu: Navigating to High Scores...");
            window.location.href = '/highscores';
        });
    }
}

================
File: src/game/scenes/Preloader.ts
================
import Phaser from 'phaser';
import { GEM_TYPES, ASSETS_PATH, AssetKeys, GEM_FRAME_COUNT, GemType } from '../constants';

export class Preloader extends Phaser.Scene {
    constructor() {
        super('Preloader');
    }

    preload(): void {
        this.showLoadingProgress();

        // Set base path for assets relative to the 'public' folder
        this.load.setBaseURL(window.location.origin); // Ensures paths are relative to the server root
        const assetsFullPath = `${ASSETS_PATH}`; // ASSETS_PATH should be relative to public, e.g., 'assets/'

        // Load common assets
        this.load.image(AssetKeys.LOGO, `${assetsFullPath}logo.png`);
        this.load.image(AssetKeys.BACKGROUND, `${assetsFullPath}bg.png`); // Corrected key and filename

        // Load Gem Assets
        GEM_TYPES.forEach((type: GemType) => {
            for (let i = 0; i < GEM_FRAME_COUNT; i++) {
                const key = AssetKeys.GEM_TEXTURE(type, i);
                // Assuming gem files are named like 'black_gem_0.png', 'blue_gem_1.png' etc.
                // and located directly in the ASSETS_PATH folder.
                const path = `${assetsFullPath}${type}_gem_${i}.png`;
                this.load.image(key, path);
            }
        });

        // Load sounds if/when added
        // this.load.audio(AssetKeys.SOUND_MATCH, [`${assetsFullPath}sounds/match.ogg`, `${assetsFullPath}sounds/match.mp3`]);

        // Example: Load a missing asset to test error handling
        // this.load.image('nonexistent', `${assetsFullPath}nonexistent.png`);
    }

    private showLoadingProgress(): void {
        const { width, height } = this.cameras.main;
        const progressBar = this.add.graphics();
        const progressBox = this.add.graphics();
        progressBox.fillStyle(0x333333, 0.8); // Darker gray
        // Ensure box is centered and sized reasonably
        const boxWidth = width * 0.6;
        const boxHeight = 50;
        const boxX = (width - boxWidth) / 2;
        const boxY = (height - boxHeight) / 2;
        progressBox.fillRect(boxX, boxY, boxWidth, boxHeight);

        const loadingText = this.make.text({
            x: width / 2, y: boxY - 25, text: 'Loading...',
            style: { font: '24px Arial', color: '#ffffff' }
        }).setOrigin(0.5);

        const percentText = this.make.text({
            x: width / 2, y: boxY + boxHeight / 2, text: '0%',
            style: { font: '20px Arial', color: '#ffffff' }
        }).setOrigin(0.5);

        const assetText = this.make.text({
            x: width / 2, y: boxY + boxHeight + 25, text: '',
            style: { font: '16px Arial', color: '#dddddd', align: 'center', wordWrap: { width: width * 0.8 } }
        }).setOrigin(0.5);

        this.load.on('progress', (value: number) => {
            percentText.setText(`${Math.floor(value * 100)}%`);
            progressBar.clear();
            progressBar.fillStyle(0xeeeeee, 1); // Lighter gray bar
            // Adjust progress bar position and size relative to the box
            const barMargin = 10;
            const barHeight = boxHeight - barMargin * 2;
            const barWidth = (boxWidth - barMargin * 2) * value;
            progressBar.fillRect(boxX + barMargin, boxY + barMargin, barWidth, barHeight);
        });

        this.load.on('fileprogress', (file: Phaser.Loader.File) => {
            // Limit asset text length and show type
            const keyName = file.key.length > 40 ? file.key.substring(0, 37) + '...' : file.key;
             assetText.setText(`Loading ${file.type}: ${keyName}`);
             // console.log(`Loading ${file.type}: ${file.key} from ${file.url}`); // Debug loading path
        });

         this.load.on('loaderror', (file: Phaser.Loader.File) => {
             console.error(`Error loading asset: ${file.key} from ${file.url}`);
             assetText.setText(`Error loading: ${file.key}`).setColor('#ff0000');
             // Optionally stop the game or show an error message
         });

        this.load.on('complete', () => {
            progressBar.destroy();
            progressBox.destroy();
            loadingText.destroy();
            percentText.destroy();
            assetText.destroy();
            console.log("Preloader complete.");
            // Proceed only if no errors occurred (basic check)
            // Check if there are any files still being loaded
            if (!this.load.inflight || this.load.inflight.size === 0) {
                 this.create(); // Call create manually after ensuring completion
            } else {
                 console.error(`Asset loading incomplete. ${this.load.inflight.size} files still in flight.`);
                 // Display a persistent error message?
                 this.add.text(width / 2, height / 2, `Error loading assets.\nCheck console.`, { 
                     color: '#ff0000', 
                     fontSize: '20px', 
                     align: 'center' 
                 }).setOrigin(0.5);
            }
        });
    }

    // create() is now called manually from the 'complete' handler
    create(): void {
        console.log("Preloader: Starting MainMenu");
        // Add a small delay or fade before starting next scene (optional)
        this.time.delayedCall(100, () => {
             this.scene.start('MainMenu');
        });
    }
}

================
File: src/game/BackendPuzzle.ts
================
// src/game/BackendPuzzle.ts
import { ExplodeAndReplacePhase, ColumnReplacement, Match } from './ExplodeAndReplacePhase';
import { MoveAction } from './MoveAction';
import { GEM_TYPES, GemType } from './constants';

// Type for a gem in the puzzle
export interface Gem {
    gemType: GemType;
}

// Type for the puzzle grid
export type PuzzleGrid = (Gem | null)[][];

export class BackendPuzzle {
    private puzzleState: PuzzleGrid;
    private nextGemsToSpawn: GemType[] = [];
    private score: number = 0;
    private movesRemaining: number = 50; // Simple game over condition

    constructor(
        public readonly width: number,
        public readonly height: number
    ) {
        console.log(`BackendPuzzle: Constructor (width=${width}, height=${height})`);
        // Initial puzzle state will be random, can be influenced later
        this.puzzleState = this.getInitialPuzzleStateWithNoMatches(width, height);
        console.log("BackendPuzzle: Initial puzzleState created.");
    }

    /**
     * Regenerates the puzzle board with new random gems.
     * Called when user clicks on the map to start a new game.
     */
    regenerateBoard(): void {
        console.log("BackendPuzzle: Regenerating puzzle state with new random gems.");
        this.puzzleState = this.getInitialPuzzleStateWithNoMatches(this.width, this.height);
        this.score = 0;
        this.movesRemaining = 50;
    }

    getScore(): number {
        return this.score;
    }

    getMovesRemaining(): number {
        return this.movesRemaining;
    }

    isGameOver(): boolean {
        return this.movesRemaining <= 0;
    }

    getGridState(): PuzzleGrid {
        return this.puzzleState;
    }

    /**
     * Generates an initial grid state with no immediate matches.
     * Uses the algorithm from the Python match_three code.
     */
    private getInitialPuzzleStateWithNoMatches(width: number, height: number): PuzzleGrid {
        console.log("BackendPuzzle: getInitialPuzzleStateWithNoMatches called.");
        const grid: PuzzleGrid = [];

        // Initialize empty grid
        for (let x = 0; x < width; x++) {
            grid[x] = [];
        }

        // Fill the grid left-to-right, top-to-bottom
        for (let x = 0; x < width; x++) {
            for (let y = 0; y < height; y++) {
                // Start with all possible gem types
                let possibleGems = new Set(GEM_TYPES);

                // Check if placing a gem would create a vertical match of 3
                if (y >= 2) {
                    const gem1 = grid[x][y - 1]?.gemType;
                    const gem2 = grid[x][y - 2]?.gemType;
                    if (gem1 && gem2 && gem1 === gem2) {
                        // Remove this gem type from possible choices
                        possibleGems.delete(gem1);
                    }
                }

                // Check if placing a gem would create a horizontal match of 3
                if (x >= 2) {
                    const gem1 = grid[x - 1][y]?.gemType;
                    const gem2 = grid[x - 2][y]?.gemType;
                    if (gem1 && gem2 && gem1 === gem2) {
                        // Remove this gem type from possible choices
                        possibleGems.delete(gem1);
                    }
                }

                // Convert set to array and pick a random gem from remaining choices
                const possibleGemsArray = Array.from(possibleGems);
                const gemType = possibleGemsArray[Math.floor(Math.random() * possibleGemsArray.length)] as GemType;

                grid[x][y] = { gemType };
            }
        }
        console.log("BackendPuzzle: getInitialPuzzleStateWithNoMatches finished creating grid.");
        return grid;
    }

    getNextExplodeAndReplacePhase(actions: MoveAction[]): ExplodeAndReplacePhase {
        for (const action of actions) {
            this.applyMoveToGrid(this.puzzleState, action);
        }
        const matches = this.getMatches(this.puzzleState);
        const replacements: ColumnReplacement[] = [];
        
        if (matches.length > 0) {
            const explosionCounts: Record<number, number> = {};
            const explodedCoords = new Set<string>();
            matches.forEach(match => match.forEach(([x, y]) => explodedCoords.add(`${x},${y}`)));
            
            explodedCoords.forEach(coordStr => {
                const [xStr] = coordStr.split(',');
                const x = parseInt(xStr, 10);
                explosionCounts[x] = (explosionCounts[x] || 0) + 1;
            });
            
            for (let x = 0; x < this.width; x++) {
                const count = explosionCounts[x] || 0;
                if (count > 0) {
                    const typesForCol: GemType[] = [];
                    for (let i = 0; i < count; i++) {
                        typesForCol.push(this.getNextGemToSpawnType());
                    }
                    replacements.push([x, typesForCol]);
                }
            }
        }
        
        const phaseResult = new ExplodeAndReplacePhase(matches, replacements);
        if (!phaseResult.isNothingToDo()) {
            this.applyExplodeAndReplacePhase(phaseResult);
        }
        return phaseResult;
    }

    getMatchesFromHypotheticalMove(moveAction: MoveAction): Match[] {
        let hypotheticalState: PuzzleGrid;
        try {
            hypotheticalState = structuredClone(this.puzzleState);
        } catch (e) {
            console.warn("structuredClone not supported, using JSON workaround.");
            hypotheticalState = JSON.parse(JSON.stringify(this.puzzleState));
        }
        this.applyMoveToGrid(hypotheticalState, moveAction);
        return this.getMatches(hypotheticalState);
    }

    /**
     * Returns the type of the next gem to spawn randomly.
     * This is used when gems are falling in to replace matched ones.
     */
    private getNextGemToSpawnType(): GemType {
        if (this.nextGemsToSpawn.length > 0) {
            return this.nextGemsToSpawn.shift()!;
        }

        // Always return a random gem type
        return GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)];
    }

    addNextGemToSpawn(gemType: GemType): void {
        this.nextGemsToSpawn.push(gemType);
    }

    addNextGemsToSpawn(gemTypes: GemType[]): void {
        this.nextGemsToSpawn.push(...gemTypes);
    }

    reset(): void {
        // Generate a new random board
        this.puzzleState = this.getInitialPuzzleStateWithNoMatches(this.width, this.height);
        this.nextGemsToSpawn = [];
        console.log("BackendPuzzle reset: new random board generated.");
    }

    private applyMoveToGrid(grid: PuzzleGrid, moveAction: MoveAction): void {
        const { rowOrCol, index, amount } = moveAction;
        if (amount === 0) return;

        if (rowOrCol === 'row') {
            const width = this.width;
            const effectiveAmount = ((amount % width) + width) % width;
            if (effectiveAmount === 0) return;
            const y = index;
            if (y < 0 || y >= this.height) return;

            const currentRow: (Gem | null)[] = [];
            for (let x = 0; x < width; x++) {
                currentRow.push(grid[x]?.[y] ?? null);
            }
            if (currentRow.some(gem => gem === undefined)) {
                console.error(`Error reading row ${y} for move application.`);
                return;
            }
            const newRow = [...currentRow.slice(-effectiveAmount), ...currentRow.slice(0, width - effectiveAmount)];
            for (let x = 0; x < width; x++) {
                if (grid[x]) {
                    grid[x][y] = newRow[x];
                }
            }
        } else { // 'col'
            const height = this.height;
            const effectiveAmount = ((amount % height) + height) % height;
            if (effectiveAmount === 0) return;
            const x = index;
            if (x < 0 || x >= this.width || !grid[x]) return;
            const currentCol = grid[x];
            if (currentCol.some(gem => gem === undefined)) {
                console.error(`Error reading column ${x} for move application.`);
                return;
            }
            const newCol = [...currentCol.slice(height - effectiveAmount), ...currentCol.slice(0, height - effectiveAmount)];
            grid[x] = newCol;
        }
    }

    private getMatches(puzzleState: PuzzleGrid): Match[] {
        const matches: Match[] = [];
        if (!puzzleState || this.width === 0 || this.height === 0) return matches;
        
        const getGemType = (x: number, y: number): GemType | null => puzzleState[x]?.[y]?.gemType ?? null;

        // Check vertical matches
        for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height - 2; ) {
                const currentType = getGemType(x, y);
                if (!currentType) { y++; continue; }
                let matchLength = 1;
                while (y + matchLength < this.height && getGemType(x, y + matchLength) === currentType) {
                    matchLength++;
                }
                if (matchLength >= 3) {
                    const match: Match = [];
                    for (let i = 0; i < matchLength; i++) {
                        match.push([x, y + i]);
                    }
                    matches.push(match);
                }
                y += matchLength;
            }
        }
        
        // Check horizontal matches
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width - 2; ) {
                const currentType = getGemType(x, y);
                if (!currentType) { x++; continue; }
                let matchLength = 1;
                while (x + matchLength < this.width && getGemType(x + matchLength, y) === currentType) {
                    matchLength++;
                }
                if (matchLength >= 3) {
                    const match: Match = [];
                    for (let i = 0; i < matchLength; i++) {
                        match.push([x + i, y]);
                    }
                    matches.push(match);
                }
                x += matchLength;
            }
        }
        return matches;
    }

    private applyExplodeAndReplacePhase(phase: ExplodeAndReplacePhase): void {
        if (phase.isNothingToDo()) return;
        
        // Calculate score based on matched gems
        let totalMatched = 0;
        phase.matches.forEach(match => {
            totalMatched += match.length;
        });
        
        if (totalMatched > 0) {
            // Basic scoring: 10 points per gem, with bonus for larger matches
            const baseScore = totalMatched * 10;
            const bonus = totalMatched > 3 ? (totalMatched - 3) * 5 : 0;
            this.score += baseScore + bonus;
            
            // Decrement moves when a successful match is made
            this.movesRemaining--;
        }
        
        const explodeCoords = new Set<string>();
        phase.matches.forEach(match => match.forEach(coord => explodeCoords.add(`${coord[0]},${coord[1]}`)));
        const replacementsMap = new Map(phase.replacements);
        const newGrid: PuzzleGrid = [];
        
        for (let x = 0; x < this.width; x++) {
            newGrid[x] = [];
            const currentColumn = this.puzzleState[x] || [];
            const survivingGems = currentColumn.filter((gem, y) => !explodeCoords.has(`${x},${y}`));
            const newGemTypes = replacementsMap.get(x) || [];
            const newGems: Gem[] = newGemTypes.map(type => ({ gemType: type }));
            newGrid[x] = [...newGems, ...survivingGems];
            
            if (newGrid[x].length !== this.height) {
                console.error(`Backend Error: Column ${x} length mismatch after phase. Expected ${this.height}, got ${newGrid[x].length}. Fixing...`);
                while (newGrid[x].length < this.height) newGrid[x].push(null); // Pad with null
                if (newGrid[x].length > this.height) newGrid[x] = newGrid[x].slice(0, this.height); // Truncate
            }
        }
        this.puzzleState = newGrid;
    }

}

================
File: src/game/BoardView.ts
================
// src/game/BoardView.ts
// View: Manages the visual representation (Phaser Sprites) and animations.

import Phaser from 'phaser';
import {
    AssetKeys,
    TWEEN_DURATION_EXPLODE, TWEEN_DURATION_FALL_BASE, TWEEN_DURATION_FALL_PER_UNIT,
    TWEEN_DURATION_FALL_MAX, TWEEN_DURATION_SNAP, TWEEN_DURATION_LAYOUT_UPDATE,
    GemType, GEM_FRAME_COUNT
} from './constants';
import { MoveAction, MoveDirection } from './MoveAction';
import { Coordinate } from './ExplodeAndReplacePhase';
import { PuzzleGrid } from './BackendPuzzle';

interface BoardConfig {
    cols: number;
    rows: number;
    gemSize: number;
    boardOffset: { x: number; y: number };
}

interface SpritePosition {
    x: number;
    y: number;
}

interface AnimationTarget {
    sprite: Phaser.GameObjects.Sprite;
    targetGridY: number;
}

export class BoardView {
    private scene: Phaser.Scene;
    private gridCols: number;
    private gridRows: number;
    private gemSize: number;
    private boardOffset: { x: number; y: number };
    private gemsSprites: (Phaser.GameObjects.Sprite | null)[][] = []; // The 2D array [x][y] mirroring the logical grid
    private gemGroup: Phaser.GameObjects.Group; // Group for efficient management

    constructor(scene: Phaser.Scene, config: BoardConfig) {
        if (!scene || !(scene instanceof Phaser.Scene)) {
            throw new Error("BoardView requires a valid Phaser.Scene instance.");
        }
        this.scene = scene;
        this.gridCols = config.cols;
        this.gridRows = config.rows;
        this.gemSize = config.gemSize;
        this.boardOffset = config.boardOffset;
        this.gemGroup = this.scene.add.group();
        console.log("BoardView initialized");
    }

    // --- Public Methods (Called by Controller: Game.js) ---

    /** Creates the initial sprites based on the model state. */
    createBoard(initialPuzzleState: PuzzleGrid): void {
        console.log("BoardView: Creating board visuals...");
        // <<< ADD LOG HERE to inspect the incoming argument >>>
        console.log(">>> BoardView: Received initialPuzzleState:",
             initialPuzzleState === null ? 'null' :
             initialPuzzleState === undefined ? 'undefined' :
             Array.isArray(initialPuzzleState) ? `Array[${initialPuzzleState.length}][${initialPuzzleState[0]?.length ?? '?'}]` :
             typeof initialPuzzleState // Log type if not array/null/undefined
         );

        this.destroyBoard(); // Clear any previous board
        this.gemsSprites = [];

        if (!initialPuzzleState || !Array.isArray(initialPuzzleState) || initialPuzzleState.length !== this.gridCols) { // <<< MODIFIED CHECK: More robust
             console.error(`BoardView: Cannot create board. Invalid initialPuzzleState received (null, undefined, not array, or wrong width). Expected ${this.gridCols} columns. Exiting createBoard.`);
             return; // <<< It exits here if state is invalid
        }

        console.log("BoardView: Board visuals creation continuing..."); // Add log to see if it gets past the check

        for (let x = 0; x < this.gridCols; x++) {
            this.gemsSprites[x] = new Array(this.gridRows).fill(null);
             // Check if the column itself is a valid array and has the correct length
             if (!Array.isArray(initialPuzzleState[x]) || initialPuzzleState[x].length !== this.gridRows) {
                 console.error(`BoardView: Initial puzzle state column ${x} is invalid or has wrong height. Expected ${this.gridRows} rows.`);
                 // Decide how to handle this - skip column, fill with null, error out?
                 // For now, we'll just have nulls in this.gemsSprites[x]
                 continue; // Skip to the next column
             }
            for (let y = 0; y < this.gridRows; y++) {
                const gemData = initialPuzzleState[x][y];
                if (gemData && gemData.gemType) {
                    this.createSprite(x, y, gemData.gemType);
                } else {
                    // Optional: Log if a cell is unexpectedly null in the initial state
                    // console.log(`BoardView: No initial gem data at [${x}, ${y}]`);
                }
            }
        }
        console.log("BoardView: Board visuals created successfully."); // Modified log
    }

    /** Updates sprite positions and scales after resize/orientation change. */
    updateVisualLayout(newGemSize: number, newBoardOffset: { x: number; y: number }): void {
        console.log("BoardView: Updating visual layout.");
        this.gemSize = newGemSize;
        this.boardOffset = newBoardOffset;

        this.iterateSprites((sprite, x, y) => {
            const targetPos = this.getSpritePosition(x, y);
            const newScale = this.calculateSpriteScale(sprite);

            this.scene.tweens.killTweensOf(sprite); // Stop existing movement
            this.scene.tweens.add({
                targets: sprite,
                x: targetPos.x,
                y: targetPos.y,
                scale: newScale,
                duration: TWEEN_DURATION_LAYOUT_UPDATE,
                ease: 'Sine.easeInOut' // Smoother ease
            });
        });
    }

    /** Updates dimensions without animation (for use before board recreation). */
    updateDimensions(newGemSize: number, newBoardOffset: { x: number; y: number }): void {
        console.log("BoardView: Updating dimensions (no animation).");
        this.gemSize = newGemSize;
        this.boardOffset = newBoardOffset;
    }

    /** Visually moves sprites during drag, handling wrapping. */
    moveDraggingSprites(
        spritesToMove: Phaser.GameObjects.Sprite[],
        startVisualPositions: Array<{ x: number; y: number; gridX: number; gridY: number }>,
        deltaX: number,
        deltaY: number,
        direction: MoveDirection
    ): void {
        if (!spritesToMove || spritesToMove.length === 0 || !startVisualPositions) return;

        spritesToMove.forEach((sprite, i) => {
            if (!sprite || !sprite.active || !startVisualPositions[i]) return;

            const startPos = startVisualPositions[i]; // The initial *visual* position
            let targetX = startPos.x;
            let targetY = startPos.y;

            if (direction === 'row') {
                const totalBoardWidth = this.gridCols * this.gemSize;
                const minX = this.boardOffset.x - this.gemSize / 2; // Left edge of the wrap zone
                const maxX = minX + totalBoardWidth;                 // Right edge (exclusive) of the wrap zone
                targetX = startPos.x + deltaX;
                sprite.x = Phaser.Math.Wrap(targetX, minX, maxX); // Wrap visual position
            } else { // 'col'
                const totalBoardHeight = this.gridRows * this.gemSize;
                const minY = this.boardOffset.y - this.gemSize / 2; // Top edge
                const maxY = minY + totalBoardHeight;                // Bottom edge (exclusive)
                targetY = startPos.y + deltaY;
                sprite.y = Phaser.Math.Wrap(targetY, minY, maxY); // Wrap visual position
            }
        });
    }

    /** Instantly sets dragged sprites to their final grid positions. Assumes gemsSprites array is already updated. */
    snapDraggedGemsToFinalGridPositions(): void {
        console.log("BoardView: Snapping dragged gems visually.");
        this.iterateSprites((sprite, x, y) => {
            const targetPos = this.getSpritePosition(x, y);
            this.scene.tweens.killTweensOf(sprite);
            sprite.setPosition(targetPos.x, targetPos.y);
            sprite.setScale(this.calculateSpriteScale(sprite)); // Ensure correct scale
            // Ensure logical data matches visual array position
            sprite.setData('gridX', x);
            sprite.setData('gridY', y);
        });
    }

    /** Animates sprites back to their original start positions, sliding the row/column as a unit. */
    snapBack(
        spritesToSnap: Phaser.GameObjects.Sprite[],
        startPositions: Array<{ x: number; y: number; gridX: number; gridY: number }>,
        dragDirection: MoveDirection | undefined,
        totalDeltaX: number,
        totalDeltaY: number
    ): Promise<void> {
        console.log(`BoardView: Starting snap back for ${dragDirection || 'direct'}. DeltaX: ${totalDeltaX}, DeltaY: ${totalDeltaY}`);
        return new Promise<void>((resolve) => {
            if (!spritesToSnap || spritesToSnap.length === 0 ||
                !startPositions || startPositions.length === 0 ||
                spritesToSnap.length !== startPositions.length) {
                console.warn("BoardView: SnapBack called with invalid arguments.");
                resolve();
                return;
            }

            // If dragDirection is not provided, perform a direct snap to origin for each sprite.
            if (!dragDirection) {
                console.log("BoardView: SnapBack called without dragDirection. Performing direct snap to origin.");
                const directSnapPromises = spritesToSnap.map((sprite, i) => {
                    const startPosData = startPositions[i];
                    if (sprite && sprite.active && startPosData) {
                        return new Promise<void>((resolveDirectSnap) => {
                            // Ensure logical grid coordinates are set before tweening
                            sprite.setData('gridX', startPosData.gridX);
                            sprite.setData('gridY', startPosData.gridY);
                            this.scene.tweens.killTweensOf(sprite);
                            this.scene.tweens.add({
                                targets: sprite,
                                x: startPosData.x,
                                y: startPosData.y,
                                duration: TWEEN_DURATION_SNAP,
                                ease: 'Quad.easeOut',
                                onComplete: () => {
                                    sprite.setPosition(startPosData.x, startPosData.y);
                                    // Redundant setData if already set, but ensures final state
                                    sprite.setData('gridX', startPosData.gridX);
                                    sprite.setData('gridY', startPosData.gridY);
                                    resolveDirectSnap();
                                }
                            });
                        });
                    }
                    return Promise.resolve();
                });
                Promise.all(directSnapPromises).then(() => {
                    console.log("BoardView: Direct snap back complete.");
                    resolve();
                }).catch(error => {
                    console.error("BoardView: Error during direct snap back:", error);
                    resolve(); // Resolve anyway
                });
                return;
            }

            // Coordinated "slide" snap back logic using a proxy tween
            console.log(`BoardView: Performing coordinated slide snap back for ${dragDirection}.`);

            // Kill any existing tweens on the sprites themselves
            spritesToSnap.forEach(sprite => {
                if (sprite && sprite.active) {
                    this.scene.tweens.killTweensOf(sprite);
                }
            });
            
            let minWrap, maxWrap;
            const boardTotalSize = (dragDirection === 'row')
                ? this.gridCols * this.gemSize
                : this.gridRows * this.gemSize;

            if (dragDirection === 'row') {
                minWrap = this.boardOffset.x - this.gemSize / 2;
                maxWrap = minWrap + boardTotalSize;
            } else { // 'col'
                minWrap = this.boardOffset.y - this.gemSize / 2;
                maxWrap = minWrap + boardTotalSize;
            }

            const proxy = { value: 1 }; // 1 = full drag offset, 0 = original position

            this.scene.tweens.add({
                targets: proxy,
                value: 0,
                duration: TWEEN_DURATION_SNAP,
                ease: 'Quad.easeOut',
                onUpdate: () => {
                    spritesToSnap.forEach((sprite, i) => {
                        if (!sprite || !sprite.active) return;
                        const startPosData = startPositions[i]; // Original visual x/y when drag started

                        if (dragDirection === 'row') {
                            const currentEffectiveDeltaX = totalDeltaX * proxy.value;
                            const newVisualX = startPosData.x + currentEffectiveDeltaX;
                            sprite.x = Phaser.Math.Wrap(newVisualX, minWrap, maxWrap);
                            sprite.y = startPosData.y; // Row doesn't change Y
                        } else { // 'col'
                            const currentEffectiveDeltaY = totalDeltaY * proxy.value;
                            const newVisualY = startPosData.y + currentEffectiveDeltaY;
                            sprite.y = Phaser.Math.Wrap(newVisualY, minWrap, maxWrap);
                            sprite.x = startPosData.x; // Column doesn't change X
                        }
                    });
                },
                onComplete: () => {
                    spritesToSnap.forEach((sprite, i) => {
                        if (!sprite || !sprite.active) return;
                        const startPosData = startPositions[i];
                        sprite.setPosition(startPosData.x, startPosData.y);
                        sprite.setData('gridX', startPosData.gridX);
                        sprite.setData('gridY', startPosData.gridY);
                    });
                    console.log("BoardView: Coordinated slide snap back complete.");
                    resolve();
                }
            });
        });
    }

    /** Animates gem explosions. Removes sprites from grid and destroys them. */
    animateExplosions(matchCoords: Coordinate[]): Promise<void> {
        console.log(`BoardView: Animating ${matchCoords.length} explosions.`);
        return new Promise<void>((resolve) => {
            if (!matchCoords || matchCoords.length === 0) { resolve(); return; }

            const explosionPromises: Promise<void>[] = [];
            const explodedCoordsSet = new Set<string>(); // Prevent double animation

            matchCoords.forEach(([x, y]) => {
                const coordKey = `${x},${y}`;
                if (explodedCoordsSet.has(coordKey)) return;

                const sprite = this.getSpriteAt(x, y);
                if (sprite) {
                    explodedCoordsSet.add(coordKey);
                    this.gemsSprites[x][y] = null; // Remove reference immediately

                    explosionPromises.push(new Promise<void>((resolveExplosion) => {
                        this.scene.tweens.killTweensOf(sprite);
                        
                        // Get the gem type from sprite data
                        const gemType = sprite.getData('gemType') as GemType;
                        if (!gemType) {
                            console.warn(`BoardView: No gem type data for sprite at [${x}, ${y}]`);
                            this.safelyDestroySprite(sprite);
                            resolveExplosion();
                            return;
                        }

                        // Create frame animation for explosion
                        const frameRate = 30; // 30 FPS for explosion animation
                        const frameDuration = 1000 / frameRate; // Duration per frame in ms
                        const totalFrames = GEM_FRAME_COUNT; // 8 frames (0-7)
                        
                        let currentFrame = 0;
                        const explosionTimer = this.scene.time.addEvent({
                            delay: frameDuration,
                            callback: () => {
                                if (currentFrame < totalFrames) {
                                    // Update sprite texture to next frame
                                    const textureKey = AssetKeys.GEM_TEXTURE(gemType, currentFrame);
                                    if (this.scene.textures.exists(textureKey)) {
                                        sprite.setTexture(textureKey);
                                    }
                                    currentFrame++;
                                } else {
                                    // Animation complete, destroy sprite
                                    explosionTimer.destroy();
                                    this.safelyDestroySprite(sprite);
                                    resolveExplosion();
                                }
                            },
                            repeat: totalFrames
                        });
                    }));
                } else {
                    // This might happen if a cascade explodes something already animating explosion
                    // console.warn(`BoardView: Explosion requested for non-existent sprite at [${x}, ${y}]`);
                }
            });

            Promise.all(explosionPromises)
                .then(() => { console.log("BoardView: Explosions complete."); resolve(); })
                .catch(error => { console.error("BoardView: Error during explosions:", error); resolve(); });
        });
    }

    /** Animates existing gems falling and new gems entering. Updates gemsSprites array. */
    animateFalls(replacements: Array<[number, GemType[]]>, finalBackendState: PuzzleGrid): Promise<void> {
        console.log("BoardView: Animating falls...");
        return new Promise<void>((resolve) => {
            const fallPromises: Promise<void>[] = [];
            const newGrid: (Phaser.GameObjects.Sprite | null)[][] = []; // Stores the final configuration of sprites
            const spritesToAnimate: AnimationTarget[] = []; // { sprite, targetY }

            // 1. Initialize newGrid structure
            for (let x = 0; x < this.gridCols; x++) {
                newGrid[x] = new Array(this.gridRows).fill(null);
            }

            // 2. Place surviving sprites into their final slots in newGrid (bottom-up)
            for (let x = 0; x < this.gridCols; x++) {
                let targetY = this.gridRows - 1; // Start checking from the bottom row
                // Iterate current visual grid from bottom up
                for (let y = this.gridRows - 1; y >= 0; y--) {
                    const sprite = this.getSpriteAt(x, y);
                    if (sprite) {
                         // This sprite survived, find its target slot
                         if (targetY >= 0) {
                             newGrid[x][targetY] = sprite; // Place in new grid config
                             sprite.setData('gridX', x);   // Update logical coords stored on sprite
                             sprite.setData('gridY', targetY);
                             spritesToAnimate.push({ sprite, targetGridY: targetY });
                             targetY--; // Move to the next slot up
                         } else {
                              console.error(`BoardView Error: No slot for surviving sprite from [${x},${y}]`);
                              this.safelyDestroySprite(sprite);
                         }
                    }
                }
            }

            // 3. Create new sprites for replacements and place them in empty slots (top-down)
            const replacementMap = new Map(replacements); // colIndex -> [types]
            for (let x = 0; x < this.gridCols; x++) {
                const typesToSpawn = replacementMap.get(x) || [];
                // New gems fill the highest available slots (lowest Y index)
                for (let i = 0; i < typesToSpawn.length; i++) {
                    let targetY = -1;
                     // Find the first null slot from the top in the newGrid config
                    for(let searchY = 0; searchY < this.gridRows; searchY++){
                        if(!newGrid[x][searchY]){
                            targetY = searchY;
                            break;
                        }
                    }

                    if (targetY !== -1) {
                        const gemType = typesToSpawn[i];
                        // Calculate start position above the board
                        const startVisualY = this.boardOffset.y - (i + 1) * this.gemSize - this.gemSize / 2;
                        const sprite = this.createSprite(x, targetY, gemType, startVisualY);

                        if (sprite) {
                            newGrid[x][targetY] = sprite; // Place in new grid config
                            spritesToAnimate.push({ sprite, targetGridY: targetY });
                        } else {
                             console.error(`BoardView Error: Failed to create replacement sprite at [${x},${targetY}]`);
                        }
                    } else {
                        console.error(`BoardView Error: No empty slot found for replacement gem in column ${x}`);
                    }
                }
            }

            // 4. Update the main gemsSprites reference
            this.gemsSprites = newGrid;

            // 5. Animate all sprites (survivors and new) to their final visual positions
            spritesToAnimate.forEach(({ sprite, targetGridY }) => {
                if (!sprite || !sprite.active) return;

                const targetPos = this.getSpritePosition(sprite.getData('gridX'), targetGridY);
                const currentY = sprite.y;

                // Skip animation if already visually in the correct place
                if (Math.round(currentY) === Math.round(targetPos.y) && Math.round(sprite.x) === Math.round(targetPos.x) && sprite.alpha === 1) {
                    sprite.setScale(this.calculateSpriteScale(sprite)); // Ensure scale
                    return;
                }

                const fallDistance = Math.abs(currentY - targetPos.y);
                const duration = Phaser.Math.Clamp(
                    TWEEN_DURATION_FALL_BASE + fallDistance * TWEEN_DURATION_FALL_PER_UNIT,
                    TWEEN_DURATION_FALL_BASE, // Min duration
                    TWEEN_DURATION_FALL_MAX   // Max duration
                );

                fallPromises.push(new Promise<void>((resolveFall) => {
                    this.scene.tweens.killTweensOf(sprite);
                    this.scene.tweens.add({
                        targets: sprite,
                        x: targetPos.x,
                        y: targetPos.y,
                        alpha: 1, // Ensure visible
                        scale: this.calculateSpriteScale(sprite), // Ensure correct scale
                        duration: duration,
                        ease: 'Quad.easeOut', // 'Bounce.easeOut' or 'Cubic.easeOut' also good
                        onComplete: () => {
                            sprite.setPosition(targetPos.x, targetPos.y); // Final exact position
                            resolveFall();
                        }
                    });
                }));
            });

            if (fallPromises.length === 0) {
                console.log("BoardView: No fall animations needed.");
                resolve();
                return;
            }

            Promise.all(fallPromises)
                .then(() => { console.log("BoardView: Falls complete."); resolve(); })
                .catch(error => { console.error("BoardView: Error during falls:", error); resolve(); });
        });
    }

    /** Updates the internal gemsSprites array structure after a move. */
    updateGemsSpritesArrayAfterMove(moveAction: MoveAction): void {
        // console.log("BoardView: Updating gemsSprites array structure."); // Less verbose
        const tempSprites = [];
        const { rowOrCol, index, amount } = moveAction;

        if (rowOrCol === 'row') {
            const y = index;
            if (y < 0 || y >= this.gridRows) return;
            const width = this.gridCols;
            const effectiveAmount = ((amount % width) + width) % width;
            if (effectiveAmount === 0) return;

            for (let x = 0; x < width; x++) tempSprites.push(this.gemsSprites[x]?.[y]);
            const shifted = [...tempSprites.slice(-effectiveAmount), ...tempSprites.slice(0, width - effectiveAmount)];
            for (let x = 0; x < width; x++) {
                if (this.gemsSprites[x]) {
                    const sprite = shifted[x];
                    this.gemsSprites[x][y] = sprite;
                    if (sprite) { // Update logical position stored on sprite
                        sprite.setData('gridX', x);
                        sprite.setData('gridY', y);
                    }
                }
            }
        } else { // col
            const x = index;
            if (x < 0 || x >= this.gridCols || !this.gemsSprites[x]) return;
            const height = this.gridRows;
            const effectiveAmount = ((amount % height) + height) % height;
            if (effectiveAmount === 0) return;

            const originalCol = this.gemsSprites[x];
            for (let y = 0; y < height; y++) tempSprites.push(originalCol[y]);
            const shifted = [...tempSprites.slice(height - effectiveAmount), ...tempSprites.slice(0, height - effectiveAmount)];
            for (let y = 0; y < height; y++) {
                 const sprite = shifted[y];
                 this.gemsSprites[x][y] = sprite;
                 if (sprite) { // Update logical position stored on sprite
                     sprite.setData('gridX', x);
                     sprite.setData('gridY', y);
                 }
            }
        }
    }

    /** Destroys all sprites and clears the board representation. */
    destroyBoard(): void {
        console.log("BoardView: Destroying board visuals...");
        this.gemGroup.clear(true, true); // Destroy children and remove them from group
        this.gemsSprites = [];
    }

    // --- Internal Helper Methods ---

    /** Safely destroys a sprite (if active) and removes from group. */
    private safelyDestroySprite(sprite: Phaser.GameObjects.Sprite | null): void {
        if (sprite && sprite.active) {
            // console.log(`Safely destroying sprite type ${sprite.getData('gemType')} at [${sprite.getData('gridX')}, ${sprite.getData('gridY')}]`);
            this.scene.tweens.killTweensOf(sprite);
            this.gemGroup.remove(sprite, true, true);
        }
    }

    /** Creates a single sprite, adds to group, stores data, places in gemsSprites array. */
    private createSprite(gridX: number, gridY: number, gemType: GemType, startVisualY?: number): Phaser.GameObjects.Sprite | null {
        const textureKey = AssetKeys.GEM_TEXTURE(gemType, 0); // Default frame
        if (!this.scene.textures.exists(textureKey)) {
            console.error(`Texture missing: ${textureKey}`); return null;
        }

        const targetPos = this.getSpritePosition(gridX, gridY);
        const xPos = targetPos.x;
        const yPos = (startVisualY !== undefined) ? startVisualY : targetPos.y;

        // Add sprite via the group for automatic scene addition
        const sprite = this.gemGroup.create(xPos, yPos, textureKey);
        if (!sprite) { console.error(`Failed to create sprite ${textureKey}`); return null; }

        sprite.setOrigin(0.5);
        sprite.setData('gridX', gridX);
        sprite.setData('gridY', gridY);
        sprite.setData('gemType', gemType);
        sprite.setScale(this.calculateSpriteScale(sprite));
        sprite.setInteractive(); // Enable input detection ON the sprite (used by Scene)

        if (startVisualY !== undefined) {
            sprite.setAlpha(0); // Start invisible if spawning from above
        }

        // Store reference in the grid array (ensure column exists)
        if (!this.gemsSprites[gridX]) {
             console.warn(`BoardView: gemsSprites column ${gridX} was not initialized before createSprite. Initializing now.`);
             this.gemsSprites[gridX] = new Array(this.gridRows).fill(null);
        }
        // Only assign if the slot is within bounds (safety check)
        if(gridY >= 0 && gridY < this.gridRows) {
             this.gemsSprites[gridX][gridY] = sprite;
        } else {
             console.error(`BoardView Error: Attempted to assign sprite to invalid row ${gridY} in column ${gridX}.`);
             this.safelyDestroySprite(sprite); // Clean up the created sprite
             return null;
        }

        return sprite;
    }

    /** Gets the sprite at [x, y] if active, otherwise null. */
    getSpriteAt(x: number, y: number): Phaser.GameObjects.Sprite | null {
        const sprite = this.gemsSprites[x]?.[y];
        return (sprite && sprite.active) ? sprite : null;
    }

    /** Returns the 2D array of sprite references. */
    getGemsSprites(): (Phaser.GameObjects.Sprite | null)[][] {
        return this.gemsSprites;
    }

    /** Calculates the center visual coordinate for a grid cell. */
    private getSpritePosition(gridX: number, gridY: number): SpritePosition {
        return {
            x: Math.round(this.boardOffset.x + gridX * this.gemSize + this.gemSize / 2),
            y: Math.round(this.boardOffset.y + gridY * this.gemSize + this.gemSize / 2)
        };
    }

    /** Calculates the appropriate scale based on gemSize and texture width. */
    private calculateSpriteScale(sprite: Phaser.GameObjects.Sprite): number {
        if (!sprite || !sprite.width || sprite.width === 0) return 1;
        return (this.gemSize / sprite.width) * 0.9; // 90% of cell size
    }

    /** Helper to iterate over all active sprites in the grid. */
    private iterateSprites(callback: (sprite: Phaser.GameObjects.Sprite, x: number, y: number) => void): void {
        for (let x = 0; x < this.gemsSprites.length; x++) {
            if (!this.gemsSprites[x]) continue;
            for (let y = 0; y < this.gemsSprites[x].length; y++) {
                const sprite = this.gemsSprites[x][y];
                if (sprite && sprite.active) {
                    callback(sprite, x, y);
                }
            }
        }
    }

    /** Utility to sync sprite visual positions to their stored logical grid coords. */
    syncSpritesToGridPositions(): void {
         console.warn("BoardView: Attempting to sync sprites to logical grid positions.");
         this.iterateSprites((sprite, x, y) => {
              const logicalX = sprite.getData('gridX');
              const logicalY = sprite.getData('gridY');
              // Basic check: does the sprite's stored logical position match its array position?
              if (logicalX !== x || logicalY !== y) {
                   console.warn(`Sync Mismatch: Sprite at array pos [${x},${y}] has logical pos [${logicalX},${logicalY}]`);
                   // Optionally force visual snap based on stored logical position
                   // const targetPos = this.getSpritePosition(logicalX, logicalY);
                   // sprite.setPosition(targetPos.x, targetPos.y);
              } else {
                   // Ensure visual position matches array position
                   const targetPos = this.getSpritePosition(x, y);
                   if(Math.round(sprite.x) !== targetPos.x || Math.round(sprite.y) !== targetPos.y) {
                       console.warn(`Sync Visual Correction: Snapping sprite at [${x},${y}] to correct visual position.`);
                       this.scene.tweens.killTweensOf(sprite);
                       sprite.setPosition(targetPos.x, targetPos.y);
                   }
              }
              sprite.setScale(this.calculateSpriteScale(sprite));
              sprite.setAlpha(1); // Ensure visible
         });
    }
}

================
File: src/game/clueConfig.ts
================
import type { Species } from '@/types/database';

export enum GemCategory {
  CLASSIFICATION = 0,  // 🧬 Red gem
  HABITAT = 1,        // 🌳 Green gem
  GEOGRAPHIC = 2,     // 🗺️ Blue gem
  MORPHOLOGY = 3,     // 🐾 Orange gem
  BEHAVIOR = 5,       // 💨 White gem
  LIFE_CYCLE = 6,     // ⏳ Black gem
  CONSERVATION = 7,   // 🛡️ Yellow gem
  KEY_FACTS = 8,      // 🔮 Purple gem
}

export interface ClueConfigItem {
  color: string;                   // e.g. 'red'
  categoryName: string;            // e.g. 'Classification'
  icon: string;                    // e.g. '🧬'
  getClue: (s: Species) => string; // one function for this category
}

export interface CluePayload {
  category: GemCategory;
  heading: string;
  clue: string;
  speciesId: number;
  name: string;
  icon: string;
  color: string;
}

export const CLUE_CONFIG: Record<GemCategory, ClueConfigItem> = {
  [GemCategory.CLASSIFICATION]: {
    color: 'red',
    categoryName: 'Classification',
    icon: '🧬',
    getClue: (species: Species) => {
      // Try to return the most specific classification available
      if (species.genus) return `Genus: ${species.genus}`;
      if (species.family) return `Family: ${species.family}`;
      if (species.order_) return `Order: ${species.order_}`;
      if (species.class) return `Class: ${species.class}`;
      if (species.phylum) return `Phylum: ${species.phylum}`;
      if (species.kingdom) return `Kingdom: ${species.kingdom}`;
      if (species.tax_comm) return species.tax_comm;
      return '';
    },
  },
  [GemCategory.HABITAT]: {
    color: 'green',
    categoryName: 'Habitat',
    icon: '🌳',
    getClue: (species: Species) => {
      if (species.hab_desc) return species.hab_desc;
      
      const habitats: string[] = [];
      if (species.aquatic || species.freshwater) habitats.push('freshwater');
      if (species.terrestr || species.terrestria) habitats.push('terrestrial');
      if (species.marine) habitats.push('marine');
      
      if (habitats.length > 0) {
        return `Found in ${habitats.join(' and ')} habitats`;
      }
      
      if (species.hab_tags) return `Habitat: ${species.hab_tags}`;
      return '';
    },
  },
  [GemCategory.GEOGRAPHIC]: {
    color: 'blue',
    categoryName: 'Geographic & Habitat',
    icon: '🗺️',
    getClue: (species: Species) => {
      const clues: string[] = [];
      
      // Geographic info
      if (species.geo_desc) clues.push(species.geo_desc);
      else if (species.dist_comm) clues.push(species.dist_comm);
      else if (species.island) clues.push(`Found on islands`);
      else if (species.origin === 1) clues.push('Native to its range');
      
      // Habitat info
      if (species.hab_desc) clues.push(species.hab_desc);
      else {
        const habitats: string[] = [];
        if (species.aquatic || species.freshwater) habitats.push('freshwater');
        if (species.terrestr || species.terrestria) habitats.push('terrestrial');
        if (species.marine) habitats.push('marine');
        
        if (habitats.length > 0) {
          clues.push(`Found in ${habitats.join(' and ')} habitats`);
        } else if (species.hab_tags) {
          clues.push(`Habitat: ${species.hab_tags}`);
        }
      }
      
      return clues.join('. ');
    },
  },
  [GemCategory.MORPHOLOGY]: {
    color: 'orange',
    categoryName: 'Morphology',
    icon: '🐾',
    getClue: (species: Species) => {
      // Combine both color/pattern and size/shape information
      const morphologyInfo: string[] = [];
      
      // Add pattern information
      if (species.pattern) morphologyInfo.push(species.pattern);
      
      // Add color information
      const colors: string[] = [];
      if (species.color_prim) colors.push(species.color_prim);
      if (species.color_sec) colors.push(species.color_sec);
      if (colors.length > 0) {
        morphologyInfo.push(`Colors: ${colors.join(' and ')}`);
      }
      
      // Add shape description
      if (species.shape_desc) morphologyInfo.push(species.shape_desc);
      
      // Add size information
      if (species.size_min && species.size_max) {
        morphologyInfo.push(`Length: ${species.size_min}-${species.size_max} units`);
      } else if (species.size_max) {
        morphologyInfo.push(`Maximum length: ${species.size_max} units`);
      }
      
      if (species.weight_kg) {
        morphologyInfo.push(`Weight: ${species.weight_kg} kg`);
      }
      
      return morphologyInfo.join('; ');
    },
  },
  [GemCategory.BEHAVIOR]: {
    color: 'white',
    categoryName: 'Behavior & Diet',
    icon: '💨',
    getClue: (species: Species) => {
      const clues: string[] = [];
      
      // Behavior info
      if (species.behav_1) clues.push(species.behav_1);
      else if (species.behav_2) clues.push(species.behav_2);
      
      // Diet info
      if (species.diet_type) clues.push(`Diet type: ${species.diet_type}`);
      else if (species.diet_prey) clues.push(`Preys on: ${species.diet_prey}`);
      else if (species.diet_flora) clues.push(`Eats plants: ${species.diet_flora}`);
      
      return clues.join('. ');
    },
  },
  [GemCategory.LIFE_CYCLE]: {
    color: 'black',
    categoryName: 'Life Cycle',
    icon: '⏳',
    getClue: (species: Species) => {
      if (species.life_desc1) return species.life_desc1;
      if (species.life_desc2) return species.life_desc2;
      
      const lifeInfo: string[] = [];
      if (species.lifespan) lifeInfo.push(`Lifespan: ${species.lifespan}`);
      if (species.maturity) lifeInfo.push(`Maturity: ${species.maturity}`);
      if (species.repro_type) lifeInfo.push(`Reproduction: ${species.repro_type}`);
      if (species.clutch_sz) lifeInfo.push(`Clutch size: ${species.clutch_sz}`);
      
      return lifeInfo.join(', ');
    },
  },
  [GemCategory.CONSERVATION]: {
    color: 'yellow',
    categoryName: 'Conservation',
    icon: '🛡️',
    getClue: (species: Species) => {
      if (species.cons_text) return species.cons_text;
      if (species.cons_code || species.category) {
        return `Conservation status: ${species.cons_code || species.category}`;
      }
      if (species.threats) return `Threats: ${species.threats}`;
      return '';
    },
  },
  [GemCategory.KEY_FACTS]: {
    color: 'purple',
    categoryName: 'Key Facts',
    icon: '❗',
    getClue: (species: Species) => {
      if (species.key_fact1) return species.key_fact1;
      if (species.key_fact2) return species.key_fact2;
      if (species.key_fact3) return species.key_fact3;
      return '';
    },
  }
};

================
File: src/game/constants.ts
================
// src/game/constants.ts

// --- Grid Configuration ---
export const GRID_COLS = 7 as const;
export const GRID_ROWS = 8 as const;

// --- Gem Configuration ---
export const GEM_TYPES = ['black', 'blue', 'green', 'orange', 'red', 'white', 'yellow', 'purple'] as const;
export type GemType = typeof GEM_TYPES[number];

export const GEM_FRAME_COUNT = 8 as const; // Number of frames per gem type (for explosion animation, etc.)

// --- Paths ---
export const ASSETS_PATH = 'assets/' as const;

// --- Animation Durations (in milliseconds) ---
export const ANIMATION_DURATIONS = {
    SNAP: 250,           // Snap back/to grid after valid move (increased for smoother effect)
    EXPLODE: 200,        // Gem explosion animation
    FALL_BASE: 200,      // Base time for falling
    FALL_PER_UNIT: 0.4,  // Additional ms per pixel distance fallen (adjust for speed)
    FALL_MAX: 450,       // Maximum fall duration
    LAYOUT_UPDATE: 150,  // Resize/orientation change tween
} as const;

// Keep old names for backward compatibility during conversion
export const TWEEN_DURATION_SNAP = ANIMATION_DURATIONS.SNAP;
export const TWEEN_DURATION_EXPLODE = ANIMATION_DURATIONS.EXPLODE;
export const TWEEN_DURATION_FALL_BASE = ANIMATION_DURATIONS.FALL_BASE;
export const TWEEN_DURATION_FALL_PER_UNIT = ANIMATION_DURATIONS.FALL_PER_UNIT;
export const TWEEN_DURATION_FALL_MAX = ANIMATION_DURATIONS.FALL_MAX;
export const TWEEN_DURATION_LAYOUT_UPDATE = ANIMATION_DURATIONS.LAYOUT_UPDATE;

// --- Input Thresholds ---
export const INPUT_THRESHOLDS = {
    DRAG: 10,        // Pixels pointer must move before drag direction is locked
    MOVE: 0.3,       // Fraction of gem size dragged needed to register as a move
} as const;

// Keep old names for backward compatibility
export const DRAG_THRESHOLD = INPUT_THRESHOLDS.DRAG;
export const MOVE_THRESHOLD = INPUT_THRESHOLDS.MOVE;

// --- Asset Keys (Centralized Naming) ---
export const AssetKeys = {
    LOGO: 'logo',
    BACKGROUND: 'background',
    // Helper to get gem texture key (assuming frame 0 is the default idle state)
    GEM_TEXTURE: (type: GemType, frame: number = 0): string => `${type}_gem_${frame}`,
    // Add sound keys here when implemented
    // SOUND_MATCH: 'match_sound',
    // SOUND_FALL: 'fall_sound',
    // SOUND_SNAP: 'snap_sound',
    // SOUND_EXPLODE: 'explode_sound',
} as const;

// --- Habitat to Gem Mapping ---
export const HABITAT_GEM_MAP: Partial<Record<number, GemType>> = {
    // Forests (100-109) → Green
    100: 'green', 101: 'green', 102: 'green', 103: 'green', 104: 'green',
    105: 'green', 106: 'green', 107: 'green', 108: 'green', 109: 'green',
    
    // Savannas (200-202) → Orange
    200: 'orange', 201: 'orange', 202: 'orange',
    
    // Shrublands (300-308) → Black
    300: 'black', 301: 'black', 302: 'black', 303: 'black', 304: 'black',
    305: 'black', 306: 'black', 307: 'black', 308: 'black',
    
    // Grasslands (400-407) → White
    400: 'white', 401: 'white', 402: 'white', 403: 'white', 404: 'white',
    405: 'white', 406: 'white', 407: 'white',
    
    // Wetlands (500-518) → Blue
    500: 'blue', 501: 'blue', 502: 'blue', 503: 'blue', 504: 'blue',
    505: 'blue', 506: 'blue', 507: 'blue', 508: 'blue', 509: 'blue',
    510: 'blue', 511: 'blue', 512: 'blue', 513: 'blue', 514: 'blue',
    515: 'blue', 516: 'blue', 517: 'blue', 518: 'blue',
    
    // Urban/Artificial (1400-1406) → Red
    1400: 'red', 1401: 'red', 1402: 'red', 1403: 'red', 1404: 'red',
    1405: 'red', 1406: 'red',
    
    // Default for any unmapped habitat types
    0: 'white', // No data
    1700: 'white', // Unknown
} as const;

// --- Game States (Optional: For more complex state machines) ---
// export const GameState = {
//     LOADING: 'loading',
//     MENU: 'menu',
//     READY: 'ready',      // Ready for player input
//     PROCESSING: 'processing', // Handling move/matches/falls
//     GAME_OVER: 'gameOver'
// };

================
File: src/game/EventBus.ts
================
import Phaser from 'phaser';
import type { Species } from '@/types/database';
import type { RasterHabitatResult } from '@/lib/speciesService';
import type { CluePayload } from './clueConfig';

// Define all event types and their payloads
export interface EventPayloads {
  'current-scene-ready': Phaser.Scene;
  'cesium-location-selected': {
    lon: number;
    lat: number;
    habitats: string[];
    species: Species[];
    rasterHabitats: RasterHabitatResult[];
  };
  'game-score-updated': {
    score: number;
    movesRemaining: number;
  };
  'game-over': {
    finalScore: number;
    habitats: string[];
  };
  'clue-revealed': CluePayload;
  'new-game-started': {
    speciesName: string;
    speciesId: number;
    totalSpecies: number;
    currentIndex: number;
  };
  'game-reset': undefined;
  'no-species-found': {};
  'all-clues-revealed': {
    speciesId: number;
  };
  'all-species-completed': {
    totalSpecies: number;
  };
  'layout-changed': {
    mapMinimized: boolean;
  };
}

// Type-safe EventBus class
class TypedEventBus extends Phaser.Events.EventEmitter {
  emit<K extends keyof EventPayloads>(event: K, ...args: [EventPayloads[K]]): boolean {
    return super.emit(event, ...args);
  }

  on<K extends keyof EventPayloads>(
    event: K,
    fn: (arg: EventPayloads[K]) => void,
    context?: any
  ): this {
    return super.on(event, fn, context);
  }

  once<K extends keyof EventPayloads>(
    event: K,
    fn: (arg: EventPayloads[K]) => void,
    context?: any
  ): this {
    return super.once(event, fn, context);
  }

  off<K extends keyof EventPayloads>(
    event: K,
    fn?: (arg: EventPayloads[K]) => void,
    context?: any
  ): this {
    return super.off(event, fn, context);
  }

  removeListener<K extends keyof EventPayloads>(
    event: K,
    fn?: (arg: EventPayloads[K]) => void,
    context?: any
  ): this {
    return super.removeListener(event, fn, context);
  }
}

// Used to emit events between React components and Phaser scenes
// https://newdocs.phaser.io/docs/3.70.0/Phaser.Events.EventEmitter
export const EventBus = new TypedEventBus();

================
File: src/game/ExplodeAndReplacePhase.ts
================
// src/game/ExplodeAndReplacePhase.ts

import { GemType } from './constants';

export type Coordinate = [number, number]; // [x, y]
export type Match = Coordinate[]; // Array of coordinates that form a match
export type ColumnReplacement = [number, GemType[]]; // [columnIndex, array of gem types to spawn]

/**
 * Represents the result of applying moves: matches found and replacements needed.
 */
export class ExplodeAndReplacePhase {
    /**
     * Creates an ExplodeAndReplacePhase result.
     * @param matches - The coordinates of matched gems.
     * @param replacements - The new gems needed per column.
     */
    constructor(
        public readonly matches: Match[] = [],
        public readonly replacements: ColumnReplacement[] = []
    ) {}

    /**
     * Checks if any matches occurred in this phase.
     * @returns True if there were no matches.
     */
    isNothingToDo(): boolean {
        return this.matches.length === 0;
    }

    /**
     * Gets all unique coordinates from all matches
     */
    getAllMatchedCoordinates(): Set<string> {
        const coords = new Set<string>();
        this.matches.forEach(match => {
            match.forEach(([x, y]) => {
                coords.add(`${x},${y}`);
            });
        });
        return coords;
    }

    /**
     * Gets the total number of gems that will be replaced
     */
    getTotalReplacements(): number {
        return this.replacements.reduce((sum, [, gems]) => sum + gems.length, 0);
    }

    /**
     * Gets replacement gems for a specific column
     */
    getReplacementsForColumn(columnIndex: number): GemType[] {
        const replacement = this.replacements.find(([col]) => col === columnIndex);
        return replacement ? replacement[1] : [];
    }
}

================
File: src/game/gemCategoryMapping.ts
================
import type { Species } from '@/types/database';
import { GemType } from './constants';

export interface GemCategoryInfo {
  categoryName: string;
  icon: string; // Emoji or path to custom icon
}

export const gemCategoryMapping: Record<GemType, GemCategoryInfo> = {
  red: { categoryName: 'Classification', icon: '🧬' },
  green: { categoryName: 'Habitat', icon: '🌳' },
  blue: { categoryName: 'Geographic & Habitat', icon: '🗺️' }, // Now includes habitat info
  orange: { categoryName: 'Morphology', icon: '🐾' }, // Combines Color/Pattern and Size/Shape
  white: { categoryName: 'Behavior & Diet', icon: '💨' }, // Now includes diet info
  black: { categoryName: 'Life Cycle', icon: '⏳' },
  yellow: { categoryName: 'Conservation', icon: '🛡️' },
  purple: { categoryName: 'Key Facts', icon: '❗' },
};

export enum GemCategory {
  CLASSIFICATION = 0,  // 🧬 Red gem
  HABITAT = 1,        // 🌳 Green gem
  GEOGRAPHIC = 2,     // 🗺️ Blue gem (now includes habitat)
  MORPHOLOGY = 3,     // 🐾 Orange gem (combines Color/Pattern and Size/Shape)
  BEHAVIOR = 5,       // 💨 White gem (now includes diet)
  LIFE_CYCLE = 6,     // ⏳ Black gem
  CONSERVATION = 7,   // 🛡️ Yellow gem
  KEY_FACTS = 8,      // ❗ Purple gem
}

export interface ClueData {
  category: GemCategory;
  heading: string;
  clue: string;
  speciesId: number;
}

export class GemClueMapper {
  /**
   * Get a clue for a specific gem category from a species
   */
  static getClueForCategory(species: Species, category: GemCategory): ClueData | null {
    const clueData: ClueData = {
      category,
      heading: species.comm_name || species.sci_name || 'Unknown Species',
      clue: '',
      speciesId: species.ogc_fid
    };

    switch (category) {
      case GemCategory.CLASSIFICATION:
        clueData.clue = this.getClassificationClue(species);
        break;
      case GemCategory.HABITAT:
        clueData.clue = this.getHabitatClue(species);
        break;
      case GemCategory.GEOGRAPHIC:
        clueData.clue = this.getGeographicAndHabitatClue(species);
        break;
      case GemCategory.MORPHOLOGY:
        clueData.clue = this.getMorphologyClue(species);
        break;
      case GemCategory.BEHAVIOR:
        clueData.clue = this.getBehaviorAndDietClue(species);
        break;
      case GemCategory.LIFE_CYCLE:
        clueData.clue = this.getLifeCycleClue(species);
        break;
      case GemCategory.CONSERVATION:
        clueData.clue = this.getConservationClue(species);
        break;
      case GemCategory.KEY_FACTS:
        clueData.clue = this.getKeyFactsClue(species);
        break;
    }

    return clueData.clue ? clueData : null;
  }

  private static getClassificationClue(species: Species): string {
    // Try to return the most specific classification available
    if (species.genus) return `Genus: ${species.genus}`;
    if (species.family) return `Family: ${species.family}`;
    if (species.order_) return `Order: ${species.order_}`;
    if (species.class) return `Class: ${species.class}`;
    if (species.phylum) return `Phylum: ${species.phylum}`;
    if (species.kingdom) return `Kingdom: ${species.kingdom}`;
    if (species.tax_comm) return species.tax_comm;
    return '';
  }

  private static getHabitatClue(species: Species): string {
    if (species.hab_desc) return species.hab_desc;
    
    const habitats: string[] = [];
    if (species.aquatic || species.freshwater) habitats.push('freshwater');
    if (species.terrestr || species.terrestria) habitats.push('terrestrial');
    if (species.marine) habitats.push('marine');
    
    if (habitats.length > 0) {
      return `Found in ${habitats.join(' and ')} habitats`;
    }
    
    if (species.hab_tags) return `Habitat: ${species.hab_tags}`;
    return '';
  }

  private static getGeographicClue(species: Species): string {
    if (species.geo_desc) return species.geo_desc;
    if (species.dist_comm) return species.dist_comm;
    if (species.island) return `Found on islands`;
    if (species.origin === 1) return 'Native to its range';
    return '';
  }

  private static getGeographicAndHabitatClue(species: Species): string {
    const clues: string[] = [];
    
    // Geographic info
    if (species.geo_desc) clues.push(species.geo_desc);
    else if (species.dist_comm) clues.push(species.dist_comm);
    else if (species.island) clues.push(`Found on islands`);
    else if (species.origin === 1) clues.push('Native to its range');
    
    // Habitat info (moved from green)
    if (species.hab_desc) clues.push(species.hab_desc);
    else {
      const habitats: string[] = [];
      if (species.aquatic || species.freshwater) habitats.push('freshwater');
      if (species.terrestr || species.terrestria) habitats.push('terrestrial');
      if (species.marine) habitats.push('marine');
      
      if (habitats.length > 0) {
        clues.push(`Found in ${habitats.join(' and ')} habitats`);
      } else if (species.hab_tags) {
        clues.push(`Habitat: ${species.hab_tags}`);
      }
    }
    
    return clues.join('. ');
  }

  private static getMorphologyClue(species: Species): string {
    // Combine both color/pattern and size/shape information
    const morphologyInfo: string[] = [];
    
    // Add pattern information
    if (species.pattern) morphologyInfo.push(species.pattern);
    
    // Add color information
    const colors: string[] = [];
    if (species.color_prim) colors.push(species.color_prim);
    if (species.color_sec) colors.push(species.color_sec);
    if (colors.length > 0) {
      morphologyInfo.push(`Colors: ${colors.join(' and ')}`);
    }
    
    // Add shape description
    if (species.shape_desc) morphologyInfo.push(species.shape_desc);
    
    // Add size information
    if (species.size_min && species.size_max) {
      morphologyInfo.push(`Length: ${species.size_min}-${species.size_max} units`);
    } else if (species.size_max) {
      morphologyInfo.push(`Maximum length: ${species.size_max} units`);
    }
    
    if (species.weight_kg) {
      morphologyInfo.push(`Weight: ${species.weight_kg} kg`);
    }
    
    return morphologyInfo.join('; ');
  }

  // Keep these methods for backward compatibility if needed
  private static getColorPatternClue(species: Species): string {
    if (species.pattern) return species.pattern;
    
    const colors: string[] = [];
    if (species.color_prim) colors.push(species.color_prim);
    if (species.color_sec) colors.push(species.color_sec);
    
    if (colors.length > 0) {
      return `Colors: ${colors.join(' and ')}`;
    }
    return '';
  }

  private static getSizeShapeClue(species: Species): string {
    if (species.shape_desc) return species.shape_desc;
    
    const sizeInfo: string[] = [];
    if (species.size_min && species.size_max) {
      sizeInfo.push(`Length: ${species.size_min}-${species.size_max} units`);
    } else if (species.size_max) {
      sizeInfo.push(`Maximum length: ${species.size_max} units`);
    }
    
    if (species.weight_kg) {
      sizeInfo.push(`Weight: ${species.weight_kg} kg`);
    }
    
    return sizeInfo.join(', ');
  }

  private static getDietClue(species: Species): string {
    if (species.diet_type) return `Diet type: ${species.diet_type}`;
    if (species.diet_prey) return `Preys on: ${species.diet_prey}`;
    if (species.diet_flora) return `Eats plants: ${species.diet_flora}`;
    return '';
  }

  private static getBehaviorClue(species: Species): string {
    if (species.behav_1) return species.behav_1;
    if (species.behav_2) return species.behav_2;
    return '';
  }

  private static getBehaviorAndDietClue(species: Species): string {
    const clues: string[] = [];
    
    // Behavior info
    if (species.behav_1) clues.push(species.behav_1);
    else if (species.behav_2) clues.push(species.behav_2);
    
    // Diet info (moved from pink)
    if (species.diet_type) clues.push(`Diet type: ${species.diet_type}`);
    else if (species.diet_prey) clues.push(`Preys on: ${species.diet_prey}`);
    else if (species.diet_flora) clues.push(`Eats plants: ${species.diet_flora}`);
    
    return clues.join('. ');
  }

  private static getLifeCycleClue(species: Species): string {
    if (species.life_desc1) return species.life_desc1;
    if (species.life_desc2) return species.life_desc2;
    
    const lifeInfo: string[] = [];
    if (species.lifespan) lifeInfo.push(`Lifespan: ${species.lifespan}`);
    if (species.maturity) lifeInfo.push(`Maturity: ${species.maturity}`);
    if (species.repro_type) lifeInfo.push(`Reproduction: ${species.repro_type}`);
    if (species.clutch_sz) lifeInfo.push(`Clutch size: ${species.clutch_sz}`);
    
    return lifeInfo.join(', ');
  }

  private static getConservationClue(species: Species): string {
    if (species.cons_text) return species.cons_text;
    if (species.cons_code || species.category) {
      return `Conservation status: ${species.cons_code || species.category}`;
    }
    if (species.threats) return `Threats: ${species.threats}`;
    return '';
  }

  private static getKeyFactsClue(species: Species): string {
    if (species.key_fact1) return species.key_fact1;
    if (species.key_fact2) return species.key_fact2;
    if (species.key_fact3) return species.key_fact3;
    return '';
  }

  static getUniqueTraitClue(species: Species): string {
    if (species.key_fact1) return species.key_fact1;
    if (species.key_fact2) return species.key_fact2;
    if (species.key_fact3) return species.key_fact3;
    return '';
  }
}

================
File: src/game/main.ts
================
import { Boot } from './scenes/Boot';
import { Game } from './scenes/Game';
import { GameOver } from './scenes/GameOver';
import { MainMenu } from './scenes/MainMenu';
import Phaser from 'phaser';
import { Preloader } from './scenes/Preloader';

// Find out more information about the Game Config at:
// https://docs.phaser.io/api-documentation/typedef/types-core#gameconfig
const config: Phaser.Types.Core.GameConfig = {
    type: Phaser.AUTO, // AUTO selects WebGL if available, otherwise Canvas
    parent: 'game-container', // Matches the div id in index.html
    backgroundColor: '#1a1a2e', // Dark blue/purple background from webpack config
    scale: {
        mode: Phaser.Scale.RESIZE, // Adjust game size to fit window/container
        parent: 'game-container', // Ensure this matches the parent ID
        width: '100%',
        height: '100%',
        autoCenter: Phaser.Scale.CENTER_BOTH, // Center the canvas
        autoRound: true, // Round pixel values for potentially crisper rendering
    },
    input: {
        activePointers: 1, // Allow only one active touch/mouse pointer
        touch: {
            capture: true, // Prevent default touch actions (like scroll) on the canvas
        }
    },
    render: {
        antialias: true, // Smoother edges for non-pixel art
        pixelArt: false, // Set to true if using pixel art assets and want sharp scaling
        roundPixels: true // Helps prevent sub-pixel jitter
    },
    scene: [
        Boot,
        Preloader,
        MainMenu,
        Game,
        GameOver
    ]
};

const StartGame = (parent: string): Phaser.Game => {
    // Pass the updated config and the parent element ID
    return new Phaser.Game({ ...config, parent });
}

export default StartGame;

================
File: src/game/MoveAction.ts
================
// src/game/MoveAction.ts

export type MoveDirection = 'row' | 'col';

/**
 * Represents a player's action of moving a row or column.
 */
export class MoveAction {
    /**
     * Creates a MoveAction.
     * @param rowOrCol - Whether a row or column was moved.
     * @param index - The index of the row or column moved.
     * @param amount - The number of cells shifted (positive for right/down, negative for left/up).
     */
    constructor(
        public readonly rowOrCol: MoveDirection,
        public readonly index: number,
        public readonly amount: number
    ) {}

    /**
     * Checks if this move is horizontal (row move)
     */
    isHorizontal(): boolean {
        return this.rowOrCol === 'row';
    }

    /**
     * Checks if this move is vertical (column move)
     */
    isVertical(): boolean {
        return this.rowOrCol === 'col';
    }

    /**
     * Gets the absolute distance moved
     */
    getDistance(): number {
        return Math.abs(this.amount);
    }

    /**
     * Checks if move is to the right (for rows) or down (for columns)
     */
    isPositiveDirection(): boolean {
        return this.amount > 0;
    }

    /**
     * Returns a string representation of the move
     */
    toString(): string {
        const direction = this.amount > 0 
            ? (this.rowOrCol === 'row' ? 'right' : 'down')
            : (this.rowOrCol === 'row' ? 'left' : 'up');
        return `Move ${this.rowOrCol} ${this.index} ${direction} by ${Math.abs(this.amount)}`;
    }
}

================
File: src/lib/speciesService.ts
================
import { supabase } from './supabaseClient';
import type { Species } from '@/types/database';

export interface SpeciesQueryResult {
  species: Species[];
  count: number;
}

export interface RasterHabitatResult {
  habitat_type: string;
  percentage: number;
}

export const speciesService = {
  /**
   * Query species that intersect with a given point (longitude, latitude)
   */
  async getSpeciesAtPoint(longitude: number, latitude: number): Promise<SpeciesQueryResult> {
    try {
      // Try to use the RPC function if it exists
      // If not, fall back to a simple query for MVP
      try {
        const { data: rpcData, error: rpcError } = await supabase
          .rpc('get_species_at_point', { lon: longitude, lat: latitude });
        
        if (!rpcError && rpcData) {
          console.log(`Spatial query returned ${rpcData.length} species at (${longitude}, ${latitude})`);
          return {
            species: rpcData as Species[],
            count: rpcData.length
          };
        } else if (rpcError) {
          console.error('RPC error:', rpcError);
        }
      } catch (rpcErr) {
        console.log('RPC function not available, using fallback query', rpcErr);
      }
      
      // Fallback: fetch a subset of species for MVP
      const { data, error, count } = await supabase
        .from('icaa')
        .select('*', { count: 'exact' })
        .limit(10) // Limit to 10 species for MVP
        .order('ogc_fid', { ascending: true });

      if (error) {
        console.error('Error querying species:', error);
        return { species: [], count: 0 };
      }

      // TODO: In production, create a PostgreSQL function like:
      // CREATE OR REPLACE FUNCTION get_species_at_point(lon float, lat float)
      // RETURNS SETOF icaa AS $$
      // BEGIN
      //   RETURN QUERY
      //   SELECT * FROM icaa
      //   WHERE ST_Contains(wkb_geometry, ST_SetSRID(ST_MakePoint(lon, lat), 4326));
      // END;
      // $$ LANGUAGE plpgsql;
      //
      // Then call it with: supabase.rpc('get_species_at_point', { lon: longitude, lat: latitude })

      return {
        species: data || [],
        count: count || 0
      };
    } catch (error) {
      console.error('Error in getSpeciesAtPoint:', error);
      return { species: [], count: 0 };
    }
  },

  /**
   * Get species by their ogc_fid values
   */
  async getSpeciesByIds(ids: number[]): Promise<Species[]> {
    try {
      const { data, error } = await supabase
        .from('icaa')
        .select('*')
        .in('ogc_fid', ids)
        .order('ogc_fid', { ascending: true });

      if (error) {
        console.error('Error fetching species by IDs:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getSpeciesByIds:', error);
      return [];
    }
  },

  /**
   * Get habitat distribution within 10km of a point using raster data
   */
  async getRasterHabitatDistribution(longitude: number, latitude: number): Promise<RasterHabitatResult[]> {
    try {
      const { data, error } = await supabase
        .rpc('get_habitat_distribution_10km', { lon: longitude, lat: latitude });
      
      if (error) {
        console.error('Error querying raster habitat distribution:', error);
        return [];
      }

      console.log(`Raster habitat query returned ${data?.length || 0} habitat types at (${longitude}, ${latitude})`);
      return data || [];
    } catch (error) {
      console.error('Error in getRasterHabitatDistribution:', error);
      return [];
    }
  },

  /**
   * Render species polygons on Cesium (returns GeoJSON)
   */
  async getSpeciesGeoJSON(speciesIds: number[]): Promise<any> {
    try {
      // For MVP, we'll fetch the species data but not the actual geometry
      // The geometry rendering will be handled by the Cesium integration
      const species = await this.getSpeciesByIds(speciesIds);
      
      // Convert to basic GeoJSON structure
      return {
        type: 'FeatureCollection',
        features: species.map(sp => ({
          type: 'Feature',
          properties: {
            ogc_fid: sp.ogc_fid,
            comm_name: sp.comm_name,
            sci_name: sp.sci_name
          },
          geometry: null // Geometry will be handled separately
        }))
      };
    } catch (error) {
      console.error('Error in getSpeciesGeoJSON:', error);
      return { type: 'FeatureCollection', features: [] };
    }
  }
};

================
File: src/lib/supabaseClient.ts
================
import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables. Please check your .env.local file.');
}

// Create a single supabase client for browser-side operations
export const supabase = createBrowserClient<Database>(
  supabaseUrl,
  supabaseAnonKey
);

================
File: src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: src/pages/_app.tsx
================
import "@/styles/globals.css";
import type { AppProps } from "next/app";

export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}

================
File: src/pages/_document.tsx
================
import { Html, Head, Main, NextScript } from "next/document";

export default function Document() {
    return (
        <Html lang="en" className="dark">
            <Head>
                {/* Link to Cesium's widgets.css */}
                <link rel="stylesheet" href="/cesium/Widgets/widgets.css" />
            </Head>
            <body>
                <Main />
                <NextScript />
            </body>
        </Html>
    );
}

================
File: src/pages/highscores.tsx
================
import { useEffect, useState } from 'react';
import Head from 'next/head';
import Link from 'next/link';
import { supabase } from '@/lib/supabaseClient';
import type { HighScore } from '@/types/database';

export default function HighScoresPage() {
  const [scores, setScores] = useState<HighScore[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchScores();

    // Subscribe to real-time updates
    const channel = supabase
      .channel('high-scores')
      .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'high_scores' },
        (payload) => {
          console.log('New score added:', payload);
          fetchScores(); // Refetch when new score added
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, []);

  const fetchScores = async () => {
    try {
      const { data, error: supabaseError } = await supabase
        .from('high_scores')
        .select('*')
        .order('score', { ascending: false })
        .limit(50);

      if (supabaseError) throw supabaseError;
      setScores(data || []);
      setError(null);
    } catch (err: any) {
      setError(err.message);
      console.error('Error fetching scores:', err);
    } finally {
      setIsLoading(false);
    }
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
  };

  return (
    <>
      <Head>
        <title>High Scores - Match 3 Game</title>
        <meta name="description" content="View the top scores in our Match 3 game" />
        <link rel="icon" href="/favicon.png" />
      </Head>

      <main>
        <div>
          <h1>🏆 Top High Scores</h1>
          
          <div style={{ 
            maxWidth: '800px', 
            margin: '0 auto', 
            background: 'rgba(26, 26, 46, 0.9)', 
            padding: '2rem', 
            borderRadius: '12px',
            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.3)'
          }}>
            {isLoading && (
              <p style={{ textAlign: 'center', color: '#888' }}>Loading scores...</p>
            )}
            
            {error && (
              <p style={{ color: '#ff4444', textAlign: 'center' }}>
                Error fetching scores: {error}
              </p>
            )}
            
            {!isLoading && !error && scores.length === 0 && (
              <p style={{ textAlign: 'center', color: '#888' }}>
                No scores yet. Be the first to play!
              </p>
            )}
            
            {!isLoading && !error && scores.length > 0 && (
              <div style={{ overflowX: 'auto' }}>
                <table style={{ 
                  width: '100%', 
                  borderCollapse: 'collapse',
                  color: 'white'
                }}>
                  <thead>
                    <tr style={{ borderBottom: '2px solid #444' }}>
                      <th style={{ padding: '10px', textAlign: 'left' }}>Rank</th>
                      <th style={{ padding: '10px', textAlign: 'left' }}>Player</th>
                      <th style={{ padding: '10px', textAlign: 'right' }}>Score</th>
                      <th style={{ padding: '10px', textAlign: 'right' }}>Date</th>
                    </tr>
                  </thead>
                  <tbody>
                    {scores.map((entry, index) => (
                      <tr 
                        key={entry.id} 
                        style={{ 
                          borderBottom: '1px solid #333',
                          backgroundColor: index === 0 ? 'rgba(255, 215, 0, 0.1)' : 
                                         index === 1 ? 'rgba(192, 192, 192, 0.1)' : 
                                         index === 2 ? 'rgba(205, 127, 50, 0.1)' : 
                                         'transparent'
                        }}
                      >
                        <td style={{ padding: '10px' }}>
                          {index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `#${index + 1}`}
                        </td>
                        <td style={{ padding: '10px', fontWeight: index < 3 ? 'bold' : 'normal' }}>
                          {entry.username}
                        </td>
                        <td style={{ 
                          padding: '10px', 
                          textAlign: 'right', 
                          color: '#ffff00',
                          fontWeight: 'bold',
                          fontSize: '1.1rem'
                        }}>
                          {entry.score.toLocaleString()}
                        </td>
                        <td style={{ 
                          padding: '10px', 
                          textAlign: 'right',
                          color: '#888',
                          fontSize: '0.9rem'
                        }}>
                          {formatDate(entry.created_at)}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>

          <div style={{ textAlign: 'center', marginTop: '3rem' }}>
            <Link href="/" style={{ 
              color: '#00bcd4', 
              textDecoration: 'none', 
              fontSize: '1.2rem',
              padding: '10px 20px',
              border: '2px solid #00bcd4',
              borderRadius: '8px',
              display: 'inline-block',
              transition: 'all 0.3s'
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = '#00bcd4';
              e.currentTarget.style.color = '#000';
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = 'transparent';
              e.currentTarget.style.color = '#00bcd4';
            }}>
              ← Back to Game
            </Link>
          </div>
        </div>
      </main>
    </>
  );
}

================
File: src/pages/index.tsx
================
import Head from "next/head";
import { Inter } from "next/font/google";
import dynamic from "next/dynamic";

const inter = Inter({ subsets: ["latin"] });

// Dynamically import your new layout component
const MainAppLayoutWithNoSSR = dynamic(
    () => import("@/MainAppLayout"), // Adjust path if you placed it elsewhere
    { ssr: false } // Crucial for client-side only rendering
);

export default function Home() {
    return (
        <>
            <Head>
                <title>Phaser Cesium Next.js</title> {/* Update title */}
                <meta name="description" content="Phaser 3 and Cesium with Next.js" />
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/favicon.png" />
            </Head>
            <main className={inter.className}>
                <MainAppLayoutWithNoSSR />
            </main>
        </>
    );
}

================
File: src/styles/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Global reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 224 71.4% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 224 71.4% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 224 71.4% 4.1%;
    --primary: 220.9 39.3% 11%;
    --primary-foreground: 210 20% 98%;
    --secondary: 220 14.3% 95.9%;
    --secondary-foreground: 220.9 39.3% 11%;
    --muted: 220 14.3% 95.9%;
    --muted-foreground: 220 8.9% 46.1%;
    --accent: 220 14.3% 95.9%;
    --accent-foreground: 220.9 39.3% 11%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 20% 98%;
    --border: 220 13% 91%;
    --input: 220 13% 91%;
    --ring: 224 71.4% 4.1%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 224 71.4% 4.1%;
    --foreground: 210 20% 98%;
    --card: 224 71.4% 4.1%;
    --card-foreground: 210 20% 98%;
    --popover: 224 71.4% 4.1%;
    --popover-foreground: 210 20% 98%;
    --primary: 210 20% 98%;
    --primary-foreground: 220.9 39.3% 11%;
    --secondary: 215 27.9% 16.9%;
    --secondary-foreground: 210 20% 98%;
    --muted: 215 27.9% 16.9%;
    --muted-foreground: 217.9 10.6% 64.9%;
    --accent: 215 27.9% 16.9%;
    --accent-foreground: 210 20% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 20% 98%;
    --border: 215 27.9% 16.9%;
    --input: 215 27.9% 16.9%;
    --ring: 216 12.2% 83.9%;
  }
}

@layer base {
  * {
    border-color: hsl(var(--border));
  }
  body {
    background-color: hsl(var(--background));
    color: hsl(var(--foreground));
  }
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
}

body {
    color: rgba(255, 255, 255, 0.87);
    background-color: #000000; 
    font-family: Arial, Helvetica, sans-serif;
}

#app {
    width: 100%;
    height: 100vh;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* Next.js root container */
#__next {
    width: 100%;
    height: 100%;
}

.spritePosition {
    margin: 10px 0 0 10px;
    font-size: 0.8em;
}

.button {
    width: 140px;
    margin: 10px;
    padding: 10px;
    background-color: #000000;
    color: rgba(255, 255, 255, 0.87);
    border: 1px solid rgba(255, 255, 255, 0.87);
    cursor: pointer;
    transition: all 0.3s;

    &:hover {
        border: 1px solid #0ec3c9;
        color: #0ec3c9;
    }

    &:active {
        background-color: #0ec3c9;
    }

    /* Disabled styles */
    &:disabled {
        cursor: not-allowed;
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: rgba(255, 255, 255, 0.3);
    }
}

/* Spin animation for loading indicators */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

================
File: src/types/database.ts
================
export interface HighScore {
  id: string;
  username: string;
  score: number;
  created_at: string;
}

export interface Species {
  ogc_fid: number;
  comm_name?: string;
  sci_name?: string;
  
  // Classification fields
  genus?: string;
  family?: string;
  order_?: string;
  class?: string;
  phylum?: string;
  kingdom?: string;
  tax_comm?: string;
  
  // Habitat fields
  hab_desc?: string;
  aquatic?: boolean;
  freshwater?: boolean;
  terrestr?: boolean;
  terrestria?: boolean;
  marine?: boolean;
  hab_tags?: string;
  
  // Geographic fields
  geo_desc?: string;
  dist_comm?: string;
  island?: boolean;
  origin?: number;
  
  // Morphology fields
  pattern?: string;
  color_prim?: string;
  color_sec?: string;
  shape_desc?: string;
  size_min?: number;
  size_max?: number;
  weight_kg?: number;
  
  // Diet fields
  diet_type?: string;
  diet_prey?: string;
  diet_flora?: string;
  
  // Behavior fields
  behav_1?: string;
  behav_2?: string;
  
  // Life cycle fields
  life_desc1?: string;
  life_desc2?: string;
  lifespan?: string;
  maturity?: string;
  repro_type?: string;
  clutch_sz?: string;
  
  // Conservation fields
  cons_text?: string;
  cons_code?: string;
  category?: string;
  threats?: string;
  
  // Key facts fields
  key_fact1?: string;
  key_fact2?: string;
  key_fact3?: string;
  
  // Spatial geometry field (PostGIS)
  wkb_geometry?: any;
}

export interface Database {
  public: {
    Tables: {
      high_scores: {
        Row: HighScore;
        Insert: Omit<HighScore, 'id' | 'created_at'>;
        Update: Partial<Omit<HighScore, 'id' | 'created_at'>>;
      };
      icaa: {
        Row: Species;
        Insert: Omit<Species, 'ogc_fid'>;
        Update: Partial<Omit<Species, 'ogc_fid'>>;
      };
    };
    Views: {
      top_scores: {
        Row: HighScore & { rank: number };
      };
    };
  };
}

================
File: src/utils/config.ts
================
// src/utils/config.ts
// Configuration utility for dynamic Azure config loading

interface AppConfig {
  cogUrl: string;
  titilerBaseUrl: string;
  gameApiBaseUrl?: string;
}

let cachedConfig: AppConfig | null = null;

export async function getAppConfig(): Promise<AppConfig> {
  if (cachedConfig) return cachedConfig;

  // For Vercel deployment, always use environment variables
  // Dynamic config fetching is disabled to avoid build-time issues and CORS problems
  cachedConfig = {
    cogUrl: process.env.NEXT_PUBLIC_COG_URL || 'https://azurecog.blob.core.windows.net/cogtif/habitat_cog.tif',
    titilerBaseUrl: process.env.NEXT_PUBLIC_TITILER_BASE_URL || 'https://azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net',
    gameApiBaseUrl: process.env.NEXT_PUBLIC_GAME_API_BASE_URL || process.env.NEXT_PUBLIC_TITILER_BASE_URL || 'https://azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net'
  };

  console.log('App config loaded from environment variables:', {
    cogUrl: cachedConfig.cogUrl,
    titilerBaseUrl: cachedConfig.titilerBaseUrl,
    gameApiBaseUrl: cachedConfig.gameApiBaseUrl
  });

  return cachedConfig;
}

// Clear cached config (useful for testing or environment changes)
export function clearConfigCache(): void {
  cachedConfig = null;
}

// Helper to check if we're in production
export function isProduction(): boolean {
  return process.env.NODE_ENV === 'production';
}

// Get the appropriate API URL based on environment
export function getApiUrl(): string {
  return isProduction() 
    ? 'https://azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net'
    : process.env.NEXT_PUBLIC_TITILER_BASE_URL || 'https://azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net';
}

================
File: src/App.tsx.template-backup
================
import { useRef, useState } from 'react';
import { IRefPhaserGame, PhaserGame } from './PhaserGame';
import { MainMenu } from './game/scenes/MainMenu';

function App()
{
    // The sprite can only be moved in the MainMenu Scene
    const [canMoveSprite, setCanMoveSprite] = useState(true);

    //  References to the PhaserGame component (game and scene are exposed)
    const phaserRef = useRef<IRefPhaserGame | null>(null);
    const [spritePosition, setSpritePosition] = useState({ x: 0, y: 0 });

    const changeScene = () => {

        if(phaserRef.current)
        {     
            const scene = phaserRef.current.scene as MainMenu;
            
            if (scene)
            {
                scene.changeScene();
            }
        }
    }

    const moveSprite = () => {

        if(phaserRef.current)
        {

            const scene = phaserRef.current.scene as MainMenu;

            if (scene && scene.scene.key === 'MainMenu')
            {
                // Get the update logo position
                scene.moveLogo(({ x, y }) => {

                    setSpritePosition({ x, y });

                });
            }
        }

    }

    const addSprite = () => {

        if (phaserRef.current)
        {
            const scene = phaserRef.current.scene;

            if (scene)
            {
                // Add more stars
                const x = Phaser.Math.Between(64, scene.scale.width - 64);
                const y = Phaser.Math.Between(64, scene.scale.height - 64);
    
                //  `add.sprite` is a Phaser GameObjectFactory method and it returns a Sprite Game Object instance
                const star = scene.add.sprite(x, y, 'star');
    
                //  ... which you can then act upon. Here we create a Phaser Tween to fade the star sprite in and out.
                //  You could, of course, do this from within the Phaser Scene code, but this is just an example
                //  showing that Phaser objects and systems can be acted upon from outside of Phaser itself.
                scene.add.tween({
                    targets: star,
                    duration: 500 + Math.random() * 1000,
                    alpha: 0,
                    yoyo: true,
                    repeat: -1
                });
            }
        }
    }

    // Event emitted from the PhaserGame component
    const currentScene = (scene: Phaser.Scene) => {

        setCanMoveSprite(scene.scene.key !== 'MainMenu');
        
    }

    return (
        <div id="app">
            <PhaserGame ref={phaserRef} currentActiveScene={currentScene} />
            <div>
                <div>
                    <button className="button" onClick={changeScene}>Change Scene</button>
                </div>
                <div>
                    <button disabled={canMoveSprite} className="button" onClick={moveSprite}>Toggle Movement</button>
                </div>
                <div className="spritePosition">Sprite Position:
                    <pre>{`{\n  x: ${spritePosition.x}\n  y: ${spritePosition.y}\n}`}</pre>
                </div>
                <div>
                    <button className="button" onClick={addSprite}>Add New Sprite</button>
                </div>
            </div>
        </div>
    )
}

export default App

================
File: src/global.d.ts
================
declare var CESIUM_BASE_URL: string;

================
File: src/MainAppLayout.tsx
================
import { useRef, useEffect, useState } from 'react';
import { PhaserGame, IRefPhaserGame } from './PhaserGame'; // Your existing PhaserGame component
import CesiumMap from './components/CesiumMap';  // Import the new CesiumMap component
import { SpeciesPanel } from './components/SpeciesPanel'; // Import the SpeciesPanel component
import { EventBus } from './game/EventBus';      // If App.jsx itself needs to react to game events
import { Toaster } from 'sonner';

function MainAppLayout() {
    const phaserRef = useRef<IRefPhaserGame | null>(null); // Ref to access Phaser game instance and current scene
    const [cesiumMinimized, setCesiumMinimized] = useState(false);

    // Emit layout change event when cesium minimized state changes
    useEffect(() => {
        EventBus.emit('layout-changed', { mapMinimized: cesiumMinimized });
    }, [cesiumMinimized]);

    // This callback is for when PhaserGame signals that a scene is ready
    const handlePhaserSceneReady = (scene: Phaser.Scene) => {
        console.log('MainAppLayout: Phaser scene ready -', scene.scene.key);
        // You can store the scene or game instance if App.jsx needs to directly interact
        if (phaserRef.current) {
            phaserRef.current.scene = scene;
        }
    };

    // --- Layout Styling --- (Updated for vertical layout)
    const appStyle: React.CSSProperties = {
        display: 'flex',
        flexDirection: 'column', // Vertical stack: Cesium Map on top, Phaser Game below
        width: '100vw',
        height: '100vh',
        overflow: 'hidden'
    };
    const cesiumContainerStyle: React.CSSProperties = {
        width: '100%',
        height: cesiumMinimized ? '0%' : '30%', // Minimize completely or take 30% of screen
        minHeight: '0px',
        borderBottom: cesiumMinimized ? 'none' : '2px solid #555', // Hide border when minimized
        position: 'relative',
        transition: 'height 0.3s ease-in-out',
        overflow: 'hidden' // Hide content when minimized
    };
    const minimizeButtonStyle: React.CSSProperties = {
        position: cesiumMinimized ? 'fixed' : 'absolute',
        top: cesiumMinimized ?'10px': '45px',
        right: '10px',
        zIndex: 1000,
        padding: '5px 10px',
        backgroundColor: 'rgba(42, 42, 42, 0.8)',
        color: 'white',
        border: '1px solid #555',
        borderRadius: '4px',
        cursor: 'pointer',
        fontSize: '14px'
    };
    const phaserAndUiContainerStyle: React.CSSProperties = {
        flex: 1, // Take remaining space
        minHeight: '400px', // Ensure game area is usable
        display: 'flex',
        flexDirection: 'column', // Stack Phaser game above other UI
        width: '100%'
    };
    const phaserGameWrapperStyle: React.CSSProperties = {
        width: '100%',
        height: cesiumMinimized ? '60%' : 'calc(100% - 150px)', // 60% when minimized to leave 40% for clues
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
    };
    const gameUiPanelStyle: React.CSSProperties = {
        width: '100%',
        height: cesiumMinimized ? '40%' : '150px', // 40% when minimized, 150px normally
        padding: '10px',
        boxSizing: 'border-box',
        borderTop: '2px solid #555',
        overflowY: 'auto', // If UI content might exceed height
        backgroundColor: '#282c34', // Dark background for UI panel
        color: 'white',
        transition: 'height 0.3s ease-in-out'
    };

    useEffect(() => {
        // If you have any specific EventBus listeners from your original App.jsx, set them up here
        // and clean them up in the return function.
        // Example:
        // EventBus.on('some-event', handler);
        // return () => EventBus.off('some-event', handler);
    }, []);

    return (
        <div id="app-container" style={appStyle}>
            <div id="cesium-map-wrapper" style={cesiumContainerStyle}>
                <button 
                    style={minimizeButtonStyle}
                    onClick={() => setCesiumMinimized(!cesiumMinimized)}
                >
                    {cesiumMinimized ? '▼ Expand' : '▲ Minimize'}
                </button>
                <CesiumMap />
            </div>

            <div id="phaser-and-ui-wrapper" style={phaserAndUiContainerStyle}>
                <div id="phaser-game-wrapper" style={phaserGameWrapperStyle}>
                    <PhaserGame ref={phaserRef} currentActiveScene={handlePhaserSceneReady} />
                </div>

                <div id="game-ui-panel" style={gameUiPanelStyle}>
                    <SpeciesPanel />
                </div>
            </div>
            
            <Toaster
                position="bottom-right"
                richColors
                theme="dark"
                closeButton
                toastOptions={{
                    classNames: {
                        toast: "bg-slate-800 border-slate-700 text-slate-100",
                        title: "text-cyan-300",
                        description: "text-slate-300",
                        actionButton: "bg-slate-600 text-white hover:bg-slate-500",
                    },
                }}
            />
        </div>
    );
}

export default MainAppLayout;

================
File: src/PhaserGame.tsx
================
import { forwardRef, useEffect, useLayoutEffect, useRef } from 'react';
import StartGame from './game/main';
import { EventBus } from './game/EventBus';

export interface IRefPhaserGame
{
    game: Phaser.Game | null;
    scene: Phaser.Scene | null;
}

interface IProps
{
    currentActiveScene?: (scene_instance: Phaser.Scene) => void
}

export const PhaserGame = forwardRef<IRefPhaserGame, IProps>(function PhaserGame({ currentActiveScene }, ref)
{
    const game = useRef<Phaser.Game | null>(null!);

    useLayoutEffect(() =>
    {
        if (game.current === null)
        {

            game.current = StartGame("game-container");

            if (typeof ref === 'function')
            {
                ref({ game: game.current, scene: null });
            } else if (ref)
            {
                ref.current = { game: game.current, scene: null };
            }

        }

        return () =>
        {
            if (game.current)
            {
                game.current.destroy(true);
                if (game.current !== null)
                {
                    game.current = null;
                }
            }
        }
    }, [ref]);

    useEffect(() =>
    {
        EventBus.on('current-scene-ready', (scene_instance: Phaser.Scene) =>
        {
            if (currentActiveScene && typeof currentActiveScene === 'function')
            {

                currentActiveScene(scene_instance);

            }

            if (typeof ref === 'function')
            {

                ref({ game: game.current, scene: scene_instance });
            
            } else if (ref)
            {

                ref.current = { game: game.current, scene: scene_instance };

            }
            
        });
        return () =>
        {

            EventBus.removeListener('current-scene-ready');
        
        }
    }, [currentActiveScene, ref]);

    return (
        <div id="game-container" style={{ position: 'relative', zIndex: 1 }}></div>
    );

});

================
File: .editorconfig
================
# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

[*]
indent_style = space
indent_size = 4
end_of_line = crlf
charset = utf-8
trim_trailing_whitespace = false
insert_final_newline = false

================
File: .env.example
================
# =================================
# Supabase Configuration (Required)
# =================================
NEXT_PUBLIC_SUPABASE_URL=https://your-project-ref.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# =================================
# TiTiler Configuration (Required)
# =================================
NEXT_PUBLIC_TITILER_BASE_URL=https://azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net
NEXT_PUBLIC_COG_URL=https://azurecog.blob.core.windows.net/cogtif/habitat_cog.tif

# =================================
# Cesium Configuration (Required)
# =================================
NEXT_PUBLIC_CESIUM_ION_TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# =================================
# Optional Configuration
# =================================
NEXT_PUBLIC_GAME_API_BASE_URL=https://azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net

# =================================
# Development Only (Local)
# =================================
NODE_ENV=development
ANALYZE=false

================
File: .env.local.example
================
# Cesium Ion token - Get your token from https://cesium.com/ion/tokens
NEXT_PUBLIC_CESIUM_ION_TOKEN=your_cesium_ion_token_here

# Backend URLs - Azure TiTiler deployment
NEXT_PUBLIC_TITILER_BASE_URL=https://azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net
NEXT_PUBLIC_GAME_API_BASE_URL=https://azure-local-dfgagqgub7fhb5fv.eastus-01.azurewebsites.net
NEXT_PUBLIC_COG_URL=https://azurecog.blob.core.windows.net/cogtif/habitat_cog.tif

# For local development, use:
# NEXT_PUBLIC_TITILER_BASE_URL=http://localhost:8000
# NEXT_PUBLIC_GAME_API_BASE_URL=http://localhost:8000
# NEXT_PUBLIC_COG_URL=file:///path/to/your/local/habitat_cog.tif

# Supabase
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url_here
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here

================
File: .eslintrc.json
================
{
  "extends": "next/core-web-vitals"
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build
/dist

# misc
.DS_Store
*.pem
*.Zone.Identifier
*:Zone.Identifier

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# Cesium
/public/cesium
repomix-output-*.xml

# nextJS
supabase_nextjs.txt

# Claude
CLAUDE.md
CLUE_SYSTEM_GUIDE.mdx

# Repomix
repomix-output-*.xml

================
File: BOARD_POSITION_FIX.md
================
# Board Position Fix: Map Minimize Issue

## Problem Description
When minimizing the Cesium map, the game board would briefly move to the correct position at the top of the screen, but then immediately jump back down to the centered position. This happened specifically when a new location was selected from the map.

## Root Cause Analysis
The issue was in the `initializeBoardFromCesium` method in `Game.ts`:

1. **Line 222**: `this.boardView.updateVisualLayout(this.gemSize, this.boardOffset)` - This started animating existing sprites to their new positions
2. **Line 226**: `this.boardView.destroyBoard()` - This immediately destroyed all sprites mid-animation  
3. **Line 227**: `this.boardView.createBoard(...)` - This created new sprites at calculated positions

The result was:
- Sprites started animating to the top position (when map was minimized)
- Animation was interrupted by sprite destruction
- New sprites were created, making it appear the board "jumped back"

## Solution Implemented

### 1. Replaced `updateVisualLayout` with `updateDimensions`
```typescript
// OLD - caused animation that got interrupted
this.boardView.updateVisualLayout(this.gemSize, this.boardOffset);

// NEW - just updates internal dimensions
this.boardView.updateDimensions(this.gemSize, this.boardOffset);
```

### 2. Added `updateDimensions` method to BoardView
```typescript
/** Updates dimensions without animation (for use before board recreation). */
updateDimensions(newGemSize: number, newBoardOffset: { x: number; y: number }): void {
    console.log("BoardView: Updating dimensions (no animation).");
    this.gemSize = newGemSize;
    this.boardOffset = newBoardOffset;
}
```

## Why This Works

1. **No conflicting animations**: We no longer start animations that get immediately interrupted
2. **Correct positioning**: The BoardView has the updated dimensions before creating new sprites
3. **Clean separation**: 
   - `updateDimensions()` - for updating internal state before recreation
   - `updateVisualLayout()` - for animating existing sprites (used in resize scenarios)

## Testing the Fix

To verify the fix works:

1. Load the game
2. Click on a location on the Cesium map to initialize the board
3. Minimize the Cesium map - the board should move to the top and stay there
4. Select a new location on the map - the board should remain at the top
5. Expand the map again - the board should move back to center and stay there

## Files Modified

1. **`src/game/scenes/Game.ts`**: 
   - Changed `updateVisualLayout` to `updateDimensions` in `initializeBoardFromCesium`
   
2. **`src/game/BoardView.ts`**: 
   - Added `updateDimensions` method for non-animated dimension updates

The fix maintains all existing functionality while eliminating the visual jump when the board is recreated after map minimize/expand actions.

================
File: CLUE_BOARD_IMPLEMENTATION.md
================
# Clue Board Implementation Guide

## Overview

This document provides a comprehensive review of the new clue board implementation, detailing all changes made, the architecture, business logic integration, event bus communication, and UI components.

## Architecture Overview

The clue board system follows a clean separation of concerns:
- **Game Logic** (Phaser): Handles gem matching and clue generation
- **Event Bus**: Facilitates communication between Phaser and React
- **UI Components** (React): Displays clues and species information
- **Toast Notifications** (Sonner): Provides real-time feedback for discoveries

## Key Changes Made

### 1. Removed Menubar Component
- **Old**: Complex shadcn/ui menubar with Species, View, Navigate, and Help menus
- **New**: Clean, minimalist interface with just a legend button
- **Files Modified**: `src/components/SpeciesPanel.tsx`

### 2. Added Toast Notifications
- **Package Added**: `sonner` for modern toast notifications
- **Integration**: Added `<Toaster>` component to `MainAppLayout.tsx`
- **Behavior**: Clues appear as toast notifications when gems are matched

### 3. New Component Architecture
Created three new components to replace the old clue display:
- `SpeciesHeaderCard.tsx` - Compact header with species info and colored dot indicators
- `DenseClueGrid.tsx` - Space-efficient grid display of discovered clues
- `ClueSheet.tsx` - Detailed slide-out panel for reviewing all clues

### 4. Colored Dot Indicators
- Replaced emoji icons with small colored dots (2.5px diameter)
- Dots represent discovered clue categories using gem colors
- Hover tooltips show category names
- Inline display to maximize vertical space

## File Structure and Dependencies

### Core Components

#### `/src/components/SpeciesPanel.tsx`
Main container component that orchestrates the clue display system.

**Key Features:**
- Manages clue state and species information
- Listens to EventBus for game events
- Shows toast notifications for new clues
- Coordinates child components

**Event Listeners:**
```typescript
- 'clue-revealed': Adds new clue and shows toast
- 'new-game-started': Resets state for new species
- 'game-reset': Clears all clue data
- 'no-species-found': Shows empty state message
- 'all-clues-revealed': Shows completion toast
- 'all-species-completed': Shows final success message
```

#### `/src/components/SpeciesHeaderCard.tsx`
Displays species information and discovered clue indicators.

**Props:**
```typescript
interface SpeciesHeaderCardProps {
  speciesName: string;
  currentSpeciesIndex: number;
  totalSpecies: number;
  revealedClueCount: number;
  discoveredClues: Array<{
    name: string;
    color: string;
    icon: string;
  }>;
  onShowLegend: () => void;
}
```

**Features:**
- Shows current species name and progress
- Displays colored dots for discovered clues
- Legend button for viewing gem categories

#### `/src/components/DenseClueGrid.tsx`
Displays discovered clues in a compact, scrollable grid.

**Props:**
```typescript
interface DenseClueGridProps {
  clues: CluePayload[];
  hasSelectedSpecies: boolean;
}
```

**Features:**
- Space-efficient layout
- Color-coded left borders matching gem colors
- Responsive hover states
- Empty states for guidance

#### `/src/components/ClueSheet.tsx`
Provides detailed view of all discovered clues in a slide-out panel.

**Props:**
```typescript
interface ClueSheetProps {
  clues: CluePayload[];
  speciesName: string;
  hasSelectedSpecies: boolean;
}
```

**Features:**
- Full-screen slide-out sheet
- Scrollable clue list
- Detailed clue text display
- Accessible via "Field Notes" button

### Supporting UI Components

#### `/src/components/ui/sheet.tsx`
Radix UI-based slide-out panel component for the detailed clue view.

#### `/src/components/ui/scroll-area.tsx`
Custom scrollable area component for long clue lists.

#### `/src/components/ui/button.tsx`
Existing button component used for legend and field notes buttons.

### Modified Files

#### `/src/MainAppLayout.tsx`
**Changes:**
- Added `import { Toaster } from 'sonner'`
- Added Toaster component with dark theme configuration

#### `/src/components/GemLegendDialog.tsx`
No changes - maintains gem category legend functionality

## Business Logic Integration

### Event Bus Communication

The system uses the EventBus pattern to communicate between Phaser (game) and React (UI):

```typescript
// Game emits clue when gems match
EventBus.emit('clue-revealed', {
  category: GemCategory,
  heading: string,
  clue: string,
  speciesId: number,
  name: string,
  icon: string,
  color: string
});
```

### Data Flow

1. **Gem Match Detection** (Phaser)
   - Player matches 3+ gems
   - Game identifies gem color/type
   - Maps to clue category

2. **Clue Generation** (Game Logic)
   - Uses `clueConfig.ts` to generate clue
   - Creates CluePayload object
   - Emits via EventBus

3. **UI Update** (React)
   - SpeciesPanel receives event
   - Updates state arrays
   - Shows toast notification
   - Updates UI components

4. **Visual Feedback**
   - Toast appears with colored border
   - Colored dot added to header
   - Clue added to grid and sheet

## Color System

Consistent color mapping across all components:

```typescript
const colorMap: Record<string, string> = {
  'red': '#ef4444',     // Classification
  'green': '#22c55e',   // Habitat
  'blue': '#3b82f6',    // Geographic
  'orange': '#f97316',  // Morphology
  'white': '#e5e7eb',   // Behavior
  'black': '#1f2937',   // Life Cycle
  'yellow': '#eab308',  // Conservation
  'purple': '#a855f7'   // Key Facts
};
```

## State Management

### SpeciesPanel State
```typescript
const [clues, setClues] = useState<CluePayload[]>([]);
const [selectedSpeciesName, setSelectedSpeciesName] = useState<string>('');
const [selectedSpeciesId, setSelectedSpeciesId] = useState<number>(0);
const [totalSpecies, setTotalSpecies] = useState<number>(0);
const [currentSpeciesIndex, setCurrentSpeciesIndex] = useState<number>(0);
const [legendOpen, setLegendOpen] = useState<boolean>(false);
const [allCluesRevealed, setAllCluesRevealed] = useState<boolean>(false);
const [allSpeciesCompleted, setAllSpeciesCompleted] = useState<boolean>(false);
const [discoveredClues, setDiscoveredClues] = useState<Array<{
  name: string;
  color: string;
  icon: string;
}>>([]);
```

## User Experience Flow

1. **Initial State**
   - Empty clue grid with instructions
   - No species selected message

2. **Species Selection**
   - User clicks location on Cesium map
   - Species info appears in header
   - Clue grid becomes active

3. **Gem Matching**
   - Player matches gems in Phaser game
   - Toast notification appears
   - Colored dot added to header
   - Clue appears in grid

4. **Progress Tracking**
   - Header shows X/8 clues discovered
   - Colored dots indicate categories found
   - Field Notes button shows count

5. **Completion**
   - All clues revealed message
   - Auto-advance to next species
   - Final completion celebration

## Performance Optimizations

1. **Space Efficiency**
   - Removed menubar to maximize content area
   - Inline colored dots save vertical space
   - Compact padding throughout

2. **Visual Hierarchy**
   - Colored borders for quick category identification
   - Toast notifications for immediate feedback
   - Progressive disclosure with sheet component

3. **State Management**
   - Duplicate prevention in clue arrays
   - Efficient event listener cleanup
   - Memoized color mappings

## Styling and Theme

- **Color Scheme**: Dark theme with slate backgrounds
- **Accent Colors**: Cyan for highlights and active states
- **Typography**: System fonts with clear hierarchy
- **Spacing**: 6px gap between major sections
- **Borders**: Colored left borders for visual association

## Future Considerations

1. **Persistence**: Could add local storage for clue history
2. **Animations**: Smooth transitions for dot appearances
3. **Accessibility**: Enhanced keyboard navigation
4. **Mobile**: Responsive design for smaller screens
5. **Customization**: User preferences for toast duration/position

## Dependencies

- `sonner`: ^1.5.0 - Toast notifications
- `@radix-ui/react-dialog`: Existing - Dialog components
- `@radix-ui/react-scroll-area`: ^1.0.0 - Scroll areas
- `lucide-react`: Existing - Icon components
- `class-variance-authority`: Existing - Component variants

## Summary

The new clue board implementation provides a cleaner, more efficient interface while maintaining full functionality. The colored dot system maximizes space for clue content, toast notifications provide immediate feedback, and the modular component architecture ensures maintainability. The event-driven design maintains clean separation between game logic and UI, making the system extensible and testable.

================
File: CLUE_DISPLAY_COMPONENT_SPEC.md
================
# ClueDisplay Component Specification

## Component Overview
The ClueDisplay component is a Phaser 3 Rex UI-based tabbed interface that replaces the React ClueDisplay component. It displays species clues in a game-integrated format with anonymized species tabs and dynamic clue tables.

## Visual Design Requirements

### Species Tabs (Left Side)
- **Layout**: Vertical tabs on the left side of the component
- **Labels**: Anonymized as "SP1", "SP2", "SP3", etc. (Species 1 → SP1)
- **Styling**: Rounded left corners, consistent with game's brown color scheme
- **States**: Normal, hover, active, completed
- **Behavior**: Click to switch between species data

### Clue Table (Main Panel)
- **Layout**: Single-column grid table (converted from 2-column example)
- **Cells**: Dynamic height based on clue text length
- **Content**: Gem-colored indicator dot + clue text
- **Scrolling**: Vertical scrolling for multiple clues
- **Animation**: Smooth transitions when switching species

### Color Scheme
```typescript
const UI_COLORS = {
    MAIN: 0x4e342e,      // Primary UI background (brown)
    LIGHT: 0x7b5e57,     // Highlight/hover color (light brown)
    DARK: 0x260e04,      // Shadow/border color (dark brown)
    ACCENT: 0x4a90e2,    // Accent elements (blue)
    TEXT: 0xffffff,      // Primary text color (white)
    TEXT_SECONDARY: 0xe0e0e0  // Secondary text color (light gray)
};
```

## Data Structure Specifications

### Core Interfaces
```typescript
interface SpeciesClueData {
    speciesId: number;           // Unique species identifier
    speciesIndex: number;        // For SP1, SP2 numbering (1-based)
    speciesName: string;         // Original species name (for internal use)
    clues: ClueData[];          // Array of revealed clues
    isActive: boolean;          // Currently selected species
    isCompleted: boolean;       // All clues revealed for this species
    totalClues: number;         // Expected number of clues
}

interface ClueTableEntry {
    id: string;                 // Unique identifier for the clue
    gemColor: GemType;          // Color of the gem that revealed this clue
    gemColorHex: number;        // Hex color value for UI display
    clueText: string;           // The actual clue content
    category: GemCategory;      // Clue category (habitat, behavior, etc.)
    categoryIcon: string;       // Emoji icon for the category
    cellHeight: number;         // Calculated height for this cell
    timestamp: number;          // When this clue was revealed
}

interface ClueDisplayState {
    currentSpeciesId: number;           // Active species
    speciesData: Map<number, SpeciesClueData>;  // All species data
    totalSpecies: number;               // Total number of species at location
    allSpeciesCompleted: boolean;       // Game completion state
    isLoadingClue: boolean;            // Show loading state
}
```

### Gem Color Mapping
```typescript
const GEM_UI_COLORS: Record<GemType, number> = {
    red: 0xff4444,        // Slightly muted red
    green: 0x44ff44,      // Slightly muted green  
    blue: 0x4444ff,       // Slightly muted blue
    orange: 0xff8844,     // Orange
    white: 0xffffff,      // White
    black: 0x444444,      // Dark gray (instead of pure black)
    yellow: 0xffff44,     // Slightly muted yellow
    purple: 0xaa44ff      // Purple
};

// Map gem types to categories for proper color display
const getGemTypeForCategory = (category: GemCategory): GemType => {
    switch (category) {
        case GemCategory.CLASSIFICATION: return 'red';
        case GemCategory.HABITAT: return 'green';
        case GemCategory.GEOGRAPHIC: return 'blue';
        case GemCategory.MORPHOLOGY: return 'orange';
        case GemCategory.BEHAVIOR: return 'white';
        case GemCategory.LIFE_CYCLE: return 'black';
        case GemCategory.CONSERVATION: return 'yellow';
        case GemCategory.KEY_FACTS: return 'purple';
        default: return 'white';
    }
};
```

## Component Architecture

### Main Scene Class
```typescript
export class ClueDisplayScene extends Phaser.Scene {
    // UI Components
    private tabs!: RexTabs;
    private gridTable!: RexGridTable;
    private speciesButtons: RexLabel[] = [];
    
    // Data Management
    private speciesData: Map<number, SpeciesClueData> = new Map();
    private currentSpeciesId: number = 0;
    private totalSpecies: number = 0;
    
    // UI State
    private isInitialized: boolean = false;
    private loadingIndicator?: Phaser.GameObjects.Container;
    
    constructor() {
        super({ key: 'ClueDisplayScene' });
    }
    
    create() {
        this.setupEventListeners();
        this.createUI();
        this.initializeState();
    }
    
    // Core methods to be implemented
    private setupEventListeners(): void;
    private createUI(): void;
    private initializeState(): void;
    private handleClueRevealed(clueData: ClueData): void;
    private handleNewGame(gameData: any): void;
    private switchSpecies(speciesIndex: number): void;
    private updateClueTable(): void;
    private calculateCellHeight(text: string, width: number): number;
}
```

### UI Creation Methods
```typescript
private createUI(): void {
    this.tabs = this.rexUI.add.tabs({
        x: 400,
        y: 300,
        panel: this.createGridTable(),
        leftButtons: [], // Will be populated dynamically
        space: {
            leftButtonsOffset: 20,
            leftButton: 2
        }
    });
    
    this.tabs.layout();
    this.setupTabEvents();
}

private createGridTable(): RexGridTable {
    this.gridTable = this.rexUI.add.gridTable({
        background: this.rexUI.add.roundRectangle(0, 0, 20, 10, 10, UI_COLORS.MAIN),
        table: {
            width: 350,
            height: 450,
            cellWidth: 330,
            cellHeight: 1, // Will be set dynamically
            columns: 1,
            mask: { padding: 4 }
        },
        slider: {
            track: this.rexUI.add.roundRectangle(0, 0, 20, 10, 10, UI_COLORS.DARK),
            thumb: this.rexUI.add.roundRectangle(0, 0, 0, 0, 13, UI_COLORS.LIGHT)
        },
        createCellContainerCallback: this.createClueCell.bind(this)
    });
    
    this.setupGridTableEvents();
    return this.gridTable;
}
```

## Cell Configuration Specifications

### Dynamic Cell Height Calculation
```typescript
private calculateCellHeight(text: string, maxWidth: number): number {
    const PADDING = 20;
    const MIN_HEIGHT = 50;
    const MAX_HEIGHT = 150;
    const LINE_HEIGHT = 18;
    const CHARS_PER_LINE = Math.floor(maxWidth / 8); // Approximate
    
    const lines = Math.ceil(text.length / CHARS_PER_LINE);
    const textHeight = lines * LINE_HEIGHT;
    const totalHeight = textHeight + PADDING;
    
    return Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, totalHeight));
}
```

### Cell Creation Specification
```typescript
private createClueCell(cell: any): RexLabel {
    const scene = cell.scene;
    const width = cell.width;
    const item: ClueTableEntry = cell.item;
    const height = item.cellHeight;
    
    // Create colored gem indicator
    const gemIndicator = scene.rexUI.add.roundRectangle(
        0, 0, 24, 24, 12, item.gemColorHex
    ).setStrokeStyle(2, UI_COLORS.LIGHT);
    
    // Create text with proper wrapping
    const clueText = scene.add.text(0, 0, item.clueText, {
        fontSize: '14px',
        color: '#ffffff',
        wordWrap: { 
            width: width - 60,
            useAdvancedWrap: true 
        },
        lineSpacing: 2
    });
    
    // Create cell container
    return scene.rexUI.add.label({
        width: width,
        height: height,
        background: scene.rexUI.add.roundRectangle(0, 0, 20, 20, 8, UI_COLORS.MAIN)
            .setStrokeStyle(1, UI_COLORS.DARK)
            .setAlpha(0.9),
        icon: gemIndicator,
        text: clueText,
        space: {
            left: 15,
            right: 15,
            top: 10,
            bottom: 10,
            icon: 12
        },
        align: 'left'
    });
}
```

### Species Button Specification
```typescript
private createSpeciesButton(speciesIndex: number, isCompleted: boolean = false): RexLabel {
    const buttonText = `SP${speciesIndex}`;
    const backgroundColor = isCompleted ? UI_COLORS.ACCENT : UI_COLORS.DARK;
    const textColor = isCompleted ? '#ffffff' : '#cccccc';
    
    return this.rexUI.add.label({
        width: 70,
        height: 45,
        background: this.rexUI.add.roundRectangle(0, 0, 70, 45, {
            tl: 22,
            bl: 22,
            tr: 0,
            br: 0
        }, backgroundColor),
        text: this.add.text(0, 0, buttonText, {
            fontSize: '16px',
            fontWeight: 'bold',
            color: textColor
        }),
        space: { 
            left: 10,
            right: 10 
        }
    });
}
```

## Event Handling Specifications

### EventBus Integration
```typescript
private setupEventListeners(): void {
    // Incoming events from the game
    EventBus.on('clue-revealed', this.handleClueRevealed, this);
    EventBus.on('new-game-started', this.handleNewGame, this);
    EventBus.on('species-completed', this.handleSpeciesCompleted, this);
    EventBus.on('all-species-completed', this.handleAllSpeciesCompleted, this);
    EventBus.on('game-reset', this.handleGameReset, this);
    EventBus.on('no-species-found', this.handleNoSpeciesFound, this);
}

private handleClueRevealed(clueData: ClueData): void {
    const speciesData = this.speciesData.get(clueData.speciesId);
    if (!speciesData) return;
    
    // Create clue table entry
    const clueEntry: ClueTableEntry = {
        id: `${clueData.speciesId}_${clueData.category}_${Date.now()}`,
        gemColor: getGemTypeForCategory(clueData.category),
        gemColorHex: GEM_UI_COLORS[getGemTypeForCategory(clueData.category)],
        clueText: clueData.clue,
        category: clueData.category,
        categoryIcon: this.getCategoryIcon(clueData.category),
        cellHeight: this.calculateCellHeight(clueData.clue, 270),
        timestamp: Date.now()
    };
    
    // Add to species data and update UI
    speciesData.clues.push(clueData);
    this.updateClueTable();
    
    // Show loading state briefly
    this.showClueLoadingAnimation(clueEntry);
}
```

### Tab Interaction Handling
```typescript
private setupTabEvents(): void {
    this.tabs.on('button.click', (button: RexLabel, groupName: string, index: number) => {
        if (groupName === 'left') {
            this.switchSpecies(index + 1); // Convert 0-based to 1-based
            this.highlightActiveTab(button, index);
            
            // Emit event for other components
            EventBus.emit('species-tab-selected', {
                speciesIndex: index + 1,
                speciesId: this.getSpeciesIdFromIndex(index + 1)
            });
        }
    }, this);
}

private highlightActiveTab(activeButton: RexLabel, activeIndex: number): void {
    // Reset all buttons to normal state
    this.speciesButtons.forEach((button, index) => {
        const isActive = index === activeIndex;
        const isCompleted = this.isSpeciesCompleted(index + 1);
        
        const backgroundColor = isActive ? UI_COLORS.ACCENT : 
                              isCompleted ? UI_COLORS.LIGHT : UI_COLORS.DARK;
        
        button.getElement('background').setFillStyle(backgroundColor);
    });
}
```

## Animation Specifications

### Clue Loading Animation
```typescript
private showClueLoadingAnimation(clueEntry: ClueTableEntry): void {
    // Create temporary loading indicator
    const loadingContainer = this.add.container(400, 350);
    
    const loadingBg = this.add.rectangle(0, 0, 300, 60, UI_COLORS.ACCENT, 0.8)
        .setStrokeStyle(2, UI_COLORS.LIGHT);
    
    const loadingText = this.add.text(0, 0, 'Processing clue...', {
        fontSize: '14px',
        color: '#ffffff'
    }).setOrigin(0.5);
    
    const loadingSpinner = this.add.graphics()
        .lineStyle(3, UI_COLORS.LIGHT)
        .beginPath()
        .arc(0, 0, 12, 0, Math.PI * 1.5)
        .strokePath();
    
    loadingContainer.add([loadingBg, loadingText, loadingSpinner]);
    
    // Animate spinner
    this.tweens.add({
        targets: loadingSpinner,
        rotation: Math.PI * 2,
        duration: 1000,
        repeat: -1
    });
    
    // Remove after delay
    this.time.delayedCall(1500, () => {
        loadingContainer.destroy();
        this.updateClueTable();
    });
}
```

### Species Completion Animation
```typescript
private animateSpeciesCompletion(speciesIndex: number): void {
    const button = this.speciesButtons[speciesIndex - 1];
    if (!button) return;
    
    // Pulse animation
    this.tweens.add({
        targets: button,
        scaleX: 1.1,
        scaleY: 1.1,
        duration: 200,
        yoyo: true,
        repeat: 2,
        onComplete: () => {
            // Update button appearance
            button.getElement('background').setFillStyle(UI_COLORS.ACCENT);
            
            // Add completion indicator
            const checkmark = this.add.text(0, 0, '✓', {
                fontSize: '18px',
                color: '#ffffff'
            }).setOrigin(0.5);
            
            button.add(checkmark);
        }
    });
}
```

## Responsive Design Specifications

### Screen Size Adaptation
```typescript
private updateLayoutForScreenSize(): void {
    const gameWidth = this.scale.gameSize.width;
    const gameHeight = this.scale.gameSize.height;
    
    // Adjust component sizes based on screen size
    const isSmallScreen = gameWidth < 800 || gameHeight < 600;
    const tabsWidth = isSmallScreen ? gameWidth * 0.9 : 600;
    const tabsHeight = isSmallScreen ? gameHeight * 0.8 : 500;
    
    if (this.tabs) {
        this.tabs.setSize(tabsWidth, tabsHeight);
        this.tabs.layout();
    }
    
    // Adjust font sizes for readability
    const fontSize = isSmallScreen ? '12px' : '14px';
    this.updateTextSizes(fontSize);
}

private updateTextSizes(fontSize: string): void {
    // Update all text elements to new size
    this.children.list.forEach(child => {
        if (child instanceof Phaser.GameObjects.Text) {
            child.setFontSize(fontSize);
        }
    });
}
```

## Performance Optimization Specifications

### Memory Management
```typescript
shutdown(): void {
    // Clean up event listeners
    EventBus.off('clue-revealed', this.handleClueRevealed, this);
    EventBus.off('new-game-started', this.handleNewGame, this);
    EventBus.off('species-completed', this.handleSpeciesCompleted, this);
    EventBus.off('all-species-completed', this.handleAllSpeciesCompleted, this);
    EventBus.off('game-reset', this.handleGameReset, this);
    
    // Destroy UI components
    if (this.tabs) {
        this.tabs.destroy();
    }
    
    // Clear data structures
    this.speciesData.clear();
    this.speciesButtons.length = 0;
    
    super.shutdown();
}
```

### Efficient Cell Rendering
```typescript
private optimizeCellRendering(): void {
    // Only render visible cells to improve performance
    this.gridTable.on('cellvisible', (cell: any) => {
        if (!cell.container) {
            cell.container = this.createClueCell(cell);
        }
    });
    
    this.gridTable.on('cellinvisible', (cell: any) => {
        if (cell.container) {
            cell.container.setVisible(false);
        }
    });
}
```

## Testing Specifications

### Unit Test Requirements
```typescript
describe('ClueDisplayScene', () => {
    let scene: ClueDisplayScene;
    
    beforeEach(() => {
        scene = new ClueDisplayScene();
        // Mock Phaser scene initialization
    });
    
    test('should create species tabs dynamically', () => {
        scene.initializeWithSpeciesCount(3);
        expect(scene.speciesButtons.length).toBe(3);
    });
    
    test('should calculate cell height correctly', () => {
        const shortText = 'Short clue';
        const longText = 'This is a very long clue that should wrap to multiple lines and increase the cell height accordingly';
        
        const shortHeight = scene.calculateCellHeight(shortText, 300);
        const longHeight = scene.calculateCellHeight(longText, 300);
        
        expect(longHeight).toBeGreaterThan(shortHeight);
    });
    
    test('should handle clue revealed events', () => {
        const mockClue: ClueData = {
            category: GemCategory.HABITAT,
            heading: 'Test Species',
            clue: 'Lives in forests',
            speciesId: 1
        };
        
        scene.handleClueRevealed(mockClue);
        expect(scene.getSpeciesData(1).clues.length).toBe(1);
    });
});
```

### Integration Test Requirements
- EventBus communication with game scenes
- UI responsiveness across different screen sizes
- Proper cleanup when switching between scenes
- Data persistence during scene transitions

## Implementation Checklist

### Phase 1: Core Structure
- [ ] Create ClueDisplayScene class with proper inheritance
- [ ] Set up Rex UI plugin integration
- [ ] Implement basic tab layout structure
- [ ] Create species button generation system
- [ ] Set up grid table with single-column layout

### Phase 2: Data Integration  
- [ ] Implement EventBus event listeners
- [ ] Create clue data mapping and storage
- [ ] Add gem color coordination system
- [ ] Implement dynamic cell height calculation
- [ ] Set up species state management

### Phase 3: UI Implementation
- [ ] Create clue cell rendering with gem indicators
- [ ] Implement tab switching functionality
- [ ] Add loading states and animations
- [ ] Create completion status indicators
- [ ] Implement scrolling behavior

### Phase 4: Interaction & Animation
- [ ] Add click handlers for tabs and cells
- [ ] Implement smooth transitions between species
- [ ] Create clue reveal animations
- [ ] Add completion celebration effects
- [ ] Implement hover states and feedback

### Phase 5: Polish & Optimization
- [ ] Add responsive design for different screen sizes
- [ ] Optimize rendering performance
- [ ] Implement proper memory management
- [ ] Add error handling and edge cases
- [ ] Create comprehensive test suite

### Phase 6: Integration & Testing
- [ ] Replace React ClueDisplay component
- [ ] Update parent components to use Phaser scene
- [ ] Test cross-component communication
- [ ] Verify game flow integration
- [ ] Performance testing and optimization

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/styles/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}

================
File: DATABASE_USER_GUIDE.md
================
# Database User Guide

## Overview

This guide provides comprehensive documentation for the database architecture used in the Species Discovery Game, focusing on the `icaa` table structure, clue system dependencies, and guidelines for making database changes.

## Current Database Architecture

### Technology Stack
- **Database**: Supabase (PostgreSQL 15+ with PostGIS extension)
- **Connection**: Supabase JavaScript Client
- **Spatial Features**: PostGIS for geographic queries
- **Real-time**: Supabase subscriptions (high scores only)

### Database Tables

#### 1. `icaa` Table (Species Data)
Primary table containing all species information with 70+ fields.

**Key Identifiers:**
- `ogc_fid` (number) - Primary key, unique identifier for each species
- `comm_name` (string) - Common name
- `sci_name` (string) - Scientific name
- `tax_comm` (string) - Taxonomic common name

**Spatial Field:**
- `wkb_geometry` (PostGIS geometry) - Polygon/multipolygon defining species range

#### 2. `high_scores` Table
- `id` (uuid) - Primary key
- `username` (string) - Player name
- `score` (number) - Game score
- `created_at` (timestamp) - Score submission time

## ICAA Table Field Mappings

### Clue Category Dependencies

The clue system directly depends on specific database fields. Here's the complete mapping:

#### 1. Classification (Red Gems) 🧬
**Database Fields Used:**
- `genus` - Genus level classification
- `family` - Family level classification
- `order_` - Order level classification (note underscore)
- `class` - Class level classification
- `phylum` - Phylum level classification
- `kingdom` - Kingdom level classification
- `tax_comm` - Fallback taxonomic common name

**Clue Generation Logic:**
```typescript
// Returns most specific classification available
if (species.genus) return `Genus: ${species.genus}`;
if (species.family) return `Family: ${species.family}`;
// ... continues through hierarchy
```

#### 2. Habitat (Green Gems) 🌳
**Database Fields Used:**
- `hab_desc` - Primary habitat description
- `aquatic` (boolean) - Lives in water
- `freshwater` (boolean) - Freshwater habitat
- `terrestr` (boolean) - Terrestrial habitat
- `terrestria` (boolean) - Alternative terrestrial flag
- `marine` (boolean) - Marine habitat
- `hab_tags` - Habitat tags/keywords

**Special Case:** Green gems can also use raster habitat data from external TiTiler service.

#### 3. Geographic & Habitat (Blue Gems) 🗺️
**Database Fields Used:**
- `geo_desc` - Geographic description
- `dist_comm` - Distribution comments
- `island` (boolean) - Island species flag
- `origin` (number) - Origin type (1 = native)
- Plus all habitat fields listed above

#### 4. Morphology (Orange Gems) 🐾
**Database Fields Used:**
- `pattern` - Pattern description
- `color_prim` - Primary color
- `color_sec` - Secondary color
- `shape_desc` - Shape description
- `size_min` (number) - Minimum size
- `size_max` (number) - Maximum size
- `weight_kg` (number) - Weight in kilograms

#### 5. Behavior & Diet (White Gems) 💨
**Database Fields Used:**
- `behav_1` - Primary behavior description
- `behav_2` - Secondary behavior description
- `diet_type` - Type of diet
- `diet_prey` - Prey species
- `diet_flora` - Plant diet

#### 6. Life Cycle (Black Gems) ⏳
**Database Fields Used:**
- `life_desc1` - Primary life cycle description
- `life_desc2` - Secondary life cycle description
- `lifespan` - Lifespan information
- `maturity` - Age at maturity
- `repro_type` - Reproduction type
- `clutch_sz` - Clutch/litter size

#### 7. Conservation (Yellow Gems) 🛡️
**Database Fields Used:**
- `cons_text` - Conservation status text
- `cons_code` - Conservation code (IUCN)
- `category` - Conservation category
- `threats` - Known threats

#### 8. Key Facts (Purple Gems) 🔮
**Database Fields Used:**
- `key_fact1` - Primary key fact
- `key_fact2` - Secondary key fact
- `key_fact3` - Tertiary key fact

## Files Affected by Database Changes

When modifying the `icaa` table structure, the following files need to be updated:

### 1. Type Definitions
**File:** `/src/types/database.ts`
- Update the `Species` interface with new/modified fields
- Ensure TypeScript types match PostgreSQL column types

### 2. Clue Configuration
**File:** `/src/game/clueConfig.ts`
- Update `getClue()` functions if field names change
- Add logic for new fields in appropriate categories
- Modify clue generation logic as needed

### 3. Species Service
**File:** `/src/lib/speciesService.ts`
- Update queries if selecting specific fields
- Modify any field-specific logic

### 4. Database Functions (PostgreSQL)
- `get_species_at_point` - RPC function for spatial queries
- `get_habitat_distribution_10km` - Raster habitat analysis

## Guidelines for Database Changes

### Adding New Species

1. **Required Fields:**
   - `comm_name` or `sci_name` (at least one)
   - `wkb_geometry` (for location-based queries)
   - At least one field per clue category for complete gameplay

2. **Best Practices:**
   - Populate as many fields as possible
   - Use consistent formatting for taxonomic names
   - Ensure geometry is valid PostGIS format
   - Test spatial queries after adding

3. **SQL Example:**
```sql
INSERT INTO icaa (
  comm_name, sci_name, genus, family, 
  hab_desc, geo_desc, pattern, 
  diet_type, life_desc1, cons_text, key_fact1,
  wkb_geometry
) VALUES (
  'Example Species', 'Examplus specius', 'Examplus', 'Examplidae',
  'Forest habitats', 'Found in North America', 'Spotted pattern',
  'Omnivore', 'Lives 10-15 years', 'Least Concern', 'Unique feature',
  ST_GeomFromText('POLYGON((...)))', 4326)
);
```

### Modifying Clue Fields

1. **Adding New Fields:**
   - Add field to `Species` interface in `database.ts`
   - Determine appropriate clue category
   - Update corresponding `getClue()` function in `clueConfig.ts`
   - Run TypeScript checks: `npm run typecheck`

2. **Renaming Fields:**
   - Update field name in `Species` interface
   - Find/replace all usages in `clueConfig.ts`
   - Update any direct field references in components
   - Test clue generation thoroughly

3. **Removing Fields:**
   - Check if field is used in `clueConfig.ts`
   - Ensure clue category has alternative fields
   - Remove from `Species` interface
   - Test that clues still generate properly

### Example: Adding a New Field

To add a `migration_pattern` field:

1. **Database Migration:**
```sql
ALTER TABLE icaa ADD COLUMN migration_pattern TEXT;
```

2. **Update Type Definition:**
```typescript
// src/types/database.ts
export interface Species {
  // ... existing fields
  migration_pattern?: string;
}
```

3. **Update Clue Logic:**
```typescript
// src/game/clueConfig.ts
[GemCategory.BEHAVIOR]: {
  getClue: (species: Species) => {
    // ... existing logic
    if (species.migration_pattern) {
      behaviorInfo.push(`Migration: ${species.migration_pattern}`);
    }
    // ... rest of function
  }
}
```

## Spatial Queries and PostGIS

### Current Implementation
```sql
-- RPC function for species at point
CREATE OR REPLACE FUNCTION get_species_at_point(lon float, lat float)
RETURNS SETOF icaa AS $$
BEGIN
  RETURN QUERY
  SELECT * FROM icaa
  WHERE ST_Contains(wkb_geometry, ST_SetSRID(ST_MakePoint(lon, lat), 4326));
END;
$$ LANGUAGE plpgsql;
```

### Adding Spatial Indexes
```sql
-- Improve query performance
CREATE INDEX idx_icaa_geometry ON icaa USING GIST (wkb_geometry);
```

## Environment Variables

Database connection configured via:
- `NEXT_PUBLIC_SUPABASE_URL` - Supabase project URL
- `NEXT_PUBLIC_SUPABASE_ANON_KEY` - Anonymous/public key

## Common Issues and Solutions

### Issue: Clues Not Generating
**Cause:** Missing or null fields in database
**Solution:** Ensure species has at least one non-null field per category

### Issue: Species Not Found at Location
**Cause:** Invalid or missing geometry
**Solution:** Verify `wkb_geometry` is valid PostGIS geometry

### Issue: TypeScript Errors After Schema Change
**Cause:** Type definitions out of sync
**Solution:** Update `Species` interface to match database schema

## Future Considerations

### Database Optimization
1. Add indexes for frequently queried fields
2. Consider partitioning for large species datasets
3. Implement caching for species data

### Schema Evolution
1. Use database migrations for version control
2. Document all schema changes
3. Test backwards compatibility

### Performance Monitoring
1. Monitor query performance
2. Track spatial query efficiency
3. Optimize based on usage patterns

## Would Drizzle ORM Benefit This Project?

### Current State Analysis
- **Direct SQL**: Currently using Supabase client with minimal raw SQL
- **Type Safety**: Manual TypeScript interfaces
- **Migrations**: No formal migration system
- **Schema**: Defined only in TypeScript interfaces

### Benefits Drizzle Would Provide

1. **Schema as Code**
   - Define database schema in TypeScript
   - Single source of truth for types and database
   - Auto-generated types from schema

2. **Migration Management**
   ```typescript
   // Define schema changes in code
   export const icaa = pgTable('icaa', {
     ogc_fid: serial('ogc_fid').primaryKey(),
     comm_name: text('comm_name'),
     // ... all fields with proper types
   });
   ```

3. **Type-Safe Queries**
   ```typescript
   // Current approach (manual types)
   const { data } = await supabase.from('icaa').select('*');
   
   // With Drizzle (automatic type inference)
   const species = await db.select().from(icaa).where(eq(icaa.ogc_fid, 1));
   ```

4. **Migration Tracking**
   - Version control for database changes
   - Rollback capabilities
   - Team collaboration on schema changes

### Recommendation

**Yes, Drizzle ORM would benefit this project** for the following reasons:

1. **Growing Complexity**: With 70+ fields and plans to add more, manual type management becomes error-prone
2. **Schema Evolution**: You plan to modify clue fields and add species
3. **Type Safety**: Eliminate manual sync between database and TypeScript
4. **Migration History**: Track all database changes over time
5. **PostGIS Support**: Drizzle supports custom types for geometry

### Implementation Considerations

1. **Gradual Migration**: Can coexist with current Supabase client
2. **Learning Curve**: Minimal for TypeScript developers
3. **Initial Setup**: One-time effort to define schema
4. **Compatibility**: Works well with Supabase PostgreSQL

The investment in setting up Drizzle would pay dividends as you continue to evolve the database schema and add more complex queries.

================
File: GAME_REACTIVITY_GUIDE.md
================
# Game Display and UI Reactivity Guide

## Executive Summary: The Hybrid Architecture

The application uses a **hybrid architecture** combining React and Phaser for maximum flexibility:

- **React (with Next.js)**: Manages the overall page structure, UI components outside the game canvas (map, clue displays), and application lifecycle. Controls macro layout (e.g., map taking top 30% of screen).
- **Phaser**: Manages everything inside the `<canvas>` element including game board rendering, real-time input handling (dragging gems), and the core game loop.
- **EventBus**: Custom event emitter (`src/game/EventBus.ts`) acts as the central nervous system, enabling React and Phaser to communicate despite being separate worlds.

**Key Principle**: React handles browser window and DOM, Phaser handles game world. Reactivity achieved through React state management, CSS for layout, Phaser's internal scaling/game loop, and EventBus for cross-communication.

---

## 1. The EventBus: Central Communication Hub

The EventBus is critical for understanding application reactivity. It's a simple publish-subscribe system allowing decoupled communication.

### How It Works:
```typescript
// Emit an event
EventBus.emit('event-name', data);

// Listen for an event
EventBus.on('event-name', (data) => { ... });
```

### Key Reactive Flows:

| Event Name | Emitted By | Listened By | Purpose |
|------------|------------|-------------|---------|
| `cesium-location-selected` | `CesiumMap.tsx` (React) | `Game.ts` (Phaser) | React→Phaser: Start new board based on map click |
| `clue-revealed` | `Game.ts` (Phaser) | `ClueDisplay.tsx` (React) | Phaser→React: Display unlocked clue |
| `new-game-started` | `Game.ts` (Phaser) | `ClueDisplay.tsx` (React) | Phaser→React: Update species display |
| `current-scene-ready` | `Game.ts` (Phaser) | `PhaserGame.tsx` (React) | Phaser→React: Scene ready notification |

### Extension Pattern:
- **React aware of game event**: Emit from `Game.ts`, add listener in React component's `useEffect`
- **Game aware of React event**: Emit from React component, add listener in `Game.ts` create method

---

## 2. Screen Layout and Responsiveness (React/CSS Layer)

Overall screen layout controlled by React components and CSS, not Phaser.

### Current Implementation:
- **Component**: `src/MainAppLayout.tsx` (or similar) defines main containers
- **Mechanism**: CSS Flexbox/Grid for screen partitioning

```css
.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}
.map-container {
  flex: 0 0 30%; /* Fixed 30% height */
}
.game-container {
  flex: 1; /* Remaining space */
}
```

### Reactivity Flow:
1. Browser window resizes
2. CSS rules automatically adjust container sizes
3. CesiumMap and PhaserGame fill 100% of their containers
4. Components resize accordingly

---

## 3. Phaser Game World Reactivity

### A. Canvas Resizing Response

**Implementation in `Game.ts`:**

1. **Event Listener Setup**:
```typescript
// in create()
this.scale.on(Phaser.Scale.Events.RESIZE, this.handleResize, this);
```

2. **Resize Handler Chain**:
   - `handleResize()` → `calculateBoardDimensions()` → `boardView.updateVisualLayout()`

3. **Board Dimension Calculation**:
```typescript
calculateBoardDimensions() {
  const { width, height } = this.scale;
  
  // Calculate maximum gem size that fits
  const usableWidth = width * 0.95;
  const usableHeight = height * 0.90;
  
  const sizeFromWidth = Math.floor(usableWidth / GRID_COLS);
  const sizeFromHeight = Math.floor(usableHeight / GRID_ROWS);
  
  this.gemSize = Math.max(24, Math.min(sizeFromWidth, sizeFromHeight));
  
  // Center the board
  const boardWidth = GRID_COLS * this.gemSize;
  const boardHeight = GRID_ROWS * this.gemSize;
  
  this.boardOffset = {
    x: Math.round((width - boardWidth) / 2),
    y: Math.round((height - boardHeight) / 2)
  };
}
```

4. **Visual Update**:
   - `BoardView.updateVisualLayout()` animates gems to new positions using tweens
   - Prevents jarring jumps on resize

### B. Game State Reactivity (MVC Pattern)

**Model-View-Controller Implementation:**

1. **Controller (`Game.ts`)**:
   - Listens for input: `POINTER_DOWN`, `POINTER_MOVE`, `POINTER_UP`
   - Interprets drag gestures → `MoveAction`
   - Validates moves with Model before committing

2. **Model (`BackendPuzzle.ts`)**:
   - Pure data representation (`PuzzleGrid`)
   - `getMatchesFromHypotheticalMove()`: Validates moves without state change
   - Updates state and calculates results (`ExplodeAndReplacePhase`)

3. **View (`BoardView.ts`)**:
   - Pure rendering, no game logic
   - Executes animation commands: `animateExplosions()`, `animateFalls()`
   - Manages sprites and visual effects

**Reactive Game Loop:**
1. User input → 2. Controller interprets → 3. Controller consults Model
4. If valid, Controller updates Model → 5. Model returns results
6. Controller commands View → 7. View updates display → 8. Wait for next input

---

## 4. Gem Positioning System

**Coordinate System:**
- Grid: 8 rows × 7 columns (`GRID_ROWS` × `GRID_COLS`)
- Gem spacing: 10% margin (gems scaled to 90% of `gemSize`)

**Position Calculation (`BoardView.getSpritePosition()`)**:
```typescript
// Center of gem at (gridX, gridY)
x = boardOffset.x + gridX * gemSize + gemSize / 2
y = boardOffset.y + gridY * gemSize + gemSize / 2
```

**Space Between Gems**: `gemSize * 0.1` (due to 90% scaling)

---

## 5. Dynamic Layout Modification Example

### Implementing Map Minimize Feature:

**Step 1: Add State to React Parent**
```typescript
// MainAppLayout.tsx
const [isMapMinimized, setIsMapMinimized] = useState(false);

useEffect(() => {
  EventBus.emit('layout-changed', { mapMinimized: isMapMinimized });
}, [isMapMinimized]);
```

**Step 2: Conditional CSS**
```css
.app-container.map-minimized .map-container {
  flex-basis: 50px; /* Shrink map */
}

.app-container.map-minimized .clue-container {
  flex-basis: 40%; /* Expand clues */
}
```

**Step 3: Phaser Response**
```typescript
// Game.ts
private isMapMinimized: boolean = false;

create() {
  EventBus.on('layout-changed', this.handleLayoutChange, this);
}

private handleLayoutChange(data: { mapMinimized: boolean }) {
  this.isMapMinimized = data.mapMinimized;
  this.handleResize(); // Trigger recalculation
}
```

---

## 6. Extension Points

### Adding New UI Elements:
1. **React Component**: Create in `src/components/`
2. **Add to Layout**: Include in `MainAppLayout.tsx`
3. **EventBus Integration**: Add listeners/emitters as needed

### Modifying Game Rules:
- Edit `BackendPuzzle.ts` for logic changes
- Update `BoardView.ts` for visual changes
- Modify `Game.ts` for input handling

### Changing Animations:
- Tween properties in `BoardView.updateVisualLayout()`
- Explosion effects in `BoardView.animateExplosions()`
- Fall animations in `BoardView.animateFalls()`

### Layout Adjustments:
- CSS in layout component for macro changes
- `calculateBoardDimensions()` for board positioning
- `getSpritePosition()` for gem spacing

---

## 7. Important Configuration Variables

### CesiumMap.tsx:
- `TITILER_BASE_URL`, `COG_URL`: Backend service endpoints
- `HABITAT_RADIUS_METERS`, `SPECIES_RADIUS_METERS`: Query radii
- `viewerRef`: Resium Viewer reference

### Game.ts:
- `GRID_COLS`, `GRID_ROWS`: Board dimensions (7×8)
- `gemSize`: Dynamic pixel size per gem
- `boardOffset`: Board position offset
- `backendPuzzle`: Game logic instance
- `boardView`: Visual representation instance

### BoardView.ts:
- `gemsSprites`: 2D array of Phaser sprites
- Animation durations and easing functions

---

## 8. Performance Considerations

- **Batch Updates**: Group EventBus emissions when possible
- **Tween Optimization**: Limit concurrent animations
- **React Re-renders**: Use `React.memo` for heavy components
- **Phaser Updates**: Only update changed sprites

---

## 9. Debugging Tips

1. **EventBus Debugging**:
```typescript
EventBus.on('*', (event, data) => console.log('Event:', event, data));
```

2. **Layout Debugging**: Add colored borders to CSS containers

3. **Phaser Debugging**: Enable debug mode in game config

4. **State Tracking**: Use React DevTools and Redux DevTools (if applicable)

---

## 10. Common Pitfalls

1. **Forgetting EventBus Cleanup**: Always remove listeners in cleanup
2. **Direct DOM Manipulation**: Never modify Phaser's canvas container directly
3. **State Synchronization**: Ensure React and Phaser states stay aligned
4. **Resize Throttling**: Consider debouncing resize handlers for performance

This guide should provide a comprehensive understanding of the reactive system. The key is understanding the separation of concerns between React (DOM/layout) and Phaser (game world), with EventBus as the bridge between them.

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Phaser

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: log.js
================
const fs = require('fs');
const https = require('https');

const main = async () => {
    const args = process.argv.slice(2);
    const packageData = JSON.parse(fs.readFileSync('./package.json', 'utf8'));
    const event = args[0] || 'unknown';
    const phaserVersion = packageData.dependencies.phaser;

    const options = {
        hostname: 'gryzor.co',
        port: 443,
        path: `/v/${event}/${phaserVersion}/${packageData.name}`,
        method: 'GET'
    };

    try {
        const req = https.request(options, (res) => {
            res.on('data', () => {});
            res.on('end', () => {
                process.exit(0);
            });
        });

        req.on('error', (error) => {
            process.exit(1);
        });

        req.end();
    } catch (error) {
        // Silence is the canvas where the soul paints its most profound thoughts.
        process.exit(1);
    }
}

main();

================
File: MAP_MINIMIZE_IMPLEMENTATION.md
================
# Map Minimize Feature Implementation

## Overview
This implementation adds the ability to minimize the Cesium map, which triggers the following layout changes:
- The game board moves up to near the top of the screen (leaving just space for score/moves)
- The clue display expands from 150px to 40% of the screen height
- All transitions are smooth and animated

## Changes Made

### 1. MainAppLayout.tsx
- Added `useEffect` to emit 'layout-changed' event when `cesiumMinimized` state changes
- Modified `phaserGameWrapperStyle` to use 60% height when map is minimized (leaving 40% for clues)
- Modified `gameUiPanelStyle` to expand to 40% height when map is minimized
- Added smooth CSS transitions for height changes

### 2. Game.ts (Phaser Scene)
- Added `isMapMinimized` property to track layout state
- Added event listener for 'layout-changed' event in `create()` method
- Added `handleLayoutChange()` method to process layout changes
- Modified `calculateBoardDimensions()` to position board differently when map is minimized:
  - When minimized: Board positioned at TOP_UI_OFFSET (60px from top)
  - When normal: Board centered vertically as before
- Added cleanup for 'layout-changed' event in `shutdown()` method

### 3. EventBus.ts
- Added 'layout-changed' event type to `EventPayloads` interface with `mapMinimized: boolean` payload

## How It Works

1. **User clicks minimize button** in MainAppLayout.tsx
2. **React state updates** (`cesiumMinimized` toggles)
3. **useEffect fires** and emits 'layout-changed' event via EventBus
4. **CSS transitions trigger**:
   - Map container shrinks to 0% height
   - Game wrapper adjusts to 60% height
   - Clue panel expands to 40% height
5. **Phaser Game scene receives event** and:
   - Updates internal `isMapMinimized` flag
   - Calls `handleResize()` which recalculates board dimensions
   - Board animates to new position near top of canvas
6. **BoardView animates** all gems to their new positions smoothly

## Key Configuration Values

- **TOP_UI_OFFSET**: 60px - Space reserved at top for score/moves display
- **Map minimized height**: 0% (completely hidden)
- **Game area height when minimized**: 60% of container
- **Clue panel height when minimized**: 40% of container
- **Transition duration**: 0.3s ease-in-out

## Future Enhancements

1. **Persist minimize state**: Could save to localStorage
2. **Keyboard shortcut**: Add hotkey to toggle map (e.g., 'M' key)
3. **Different minimize modes**: 
   - Partial minimize (e.g., to 10% height showing mini-map)
   - Slide-out drawer animation
4. **Responsive breakpoints**: Different behavior on mobile vs desktop

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {
    // Static export configuration for Vercel
    output: 'export',
    distDir: 'dist',
    trailingSlash: false,
    
    // Image optimization (required for static export)
    images: {
        unoptimized: true
    },
    
    // Security headers
    poweredByHeader: false,
    
    // Compression and optimization
    compress: true,
    generateEtags: true,
    
    // Webpack configuration
    webpack: (config, { webpack, isServer }) => {
        // Define global Cesium variable
        config.plugins.push(
            new webpack.DefinePlugin({
                'CESIUM_BASE_URL': JSON.stringify('/cesium/')
            })
        );
        
        // Client-side optimizations
        if (!isServer) {
            config.resolve.fallback = {
                ...config.resolve.fallback,
                fs: false,
                path: false,
                crypto: false,
                stream: false,
                buffer: false,
                process: false
            };
        }
        
        return config;
    },
    
    // Headers for security and performance
    async headers() {
        return [
            {
                source: '/:path*',
                headers: [
                    {
                        key: 'X-Frame-Options',
                        value: 'DENY'
                    },
                    {
                        key: 'X-Content-Type-Options',
                        value: 'nosniff'
                    },
                    {
                        key: 'X-XSS-Protection',
                        value: '1; mode=block'
                    },
                    {
                        key: 'Referrer-Policy',
                        value: 'strict-origin-when-cross-origin'
                    }
                ]
            },
            {
                source: '/cesium/:path*',
                headers: [
                    {
                        key: 'Cache-Control',
                        value: 'public, max-age=31536000, immutable'
                    },
                    {
                        key: 'Access-Control-Allow-Origin',
                        value: '*'
                    }
                ]
            },
            {
                source: '/assets/:path*',
                headers: [
                    {
                        key: 'Cache-Control',
                        value: 'public, max-age=31536000, immutable'
                    }
                ]
            }
        ];
    }
};

export default nextConfig;

================
File: package.json
================
{
    "name": "template-nextjs",
    "version": "1.2.0",
    "description": "A Phaser 3 Next.js project template that demonstrates Next.js with React communication and uses Vite for bundling.",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/phaserjs/template-nextjs.git"
    },
    "author": "Phaser Studio <support@phaser.io> (https://phaser.io/)",
    "license": "MIT",
    "licenseUrl": "http://www.opensource.org/licenses/mit-license.php",
    "bugs": {
        "url": "https://github.com/phaserjs/template-nextjs/issues"
    },
    "homepage": "https://github.com/phaserjs/template-nextjs#readme",
    "keywords": [
        "phaser",
        "phaser3",
        "next",
        "nextjs",
        "vite",
        "typescript"
    ],
    "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
    },
    "scripts": {
        "dev": "next dev -p 8080",
        "dev-local": "node log.js dev & next dev -p 8080",
        "build": "npm run typecheck && next build",
        "build-local": "node log.js build & npm run typecheck && next build",
        "vercel-build": "npm run typecheck && next build",
        "serve": "npx serve dist -p 8080 -s",
        "start": "npm run build && npm run serve",
        "typecheck": "tsc --noEmit",
        "typecheck:watch": "tsc --noEmit --watch",
        "postinstall": "node scripts/copy-cesium-assets.js || symlink-dir node_modules/cesium/Build/Cesium public/cesium",
        "clean": "rm -rf .next dist public/cesium"
    },
    "dependencies": {
        "@radix-ui/react-dialog": "^1.1.14",
        "@radix-ui/react-menubar": "^1.1.15",
        "@radix-ui/react-scroll-area": "^1.2.9",
        "@radix-ui/react-separator": "^1.1.7",
        "@radix-ui/react-slot": "^1.2.3",
        "@supabase/ssr": "^0.6.1",
        "@supabase/supabase-js": "^2.49.10",
        "cesium": "^1.117.0",
        "class-variance-authority": "^0.7.1",
        "clsx": "^2.1.1",
        "lucide-react": "^0.525.0",
        "next": "15.3.1",
        "phaser": "^3.90.0",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "resium": "^1.17.2",
        "sonner": "^2.0.6",
        "tailwind-merge": "^3.3.1"
    },
    "devDependencies": {
        "@tailwindcss/postcss": "^4.1.11",
        "@types/node": "^20",
        "@types/react": "^18",
        "@types/react-dom": "^18",
        "autoprefixer": "^10.4.21",
        "postcss": "^8.5.6",
        "symlink-dir": "^5.2.1",
        "tailwindcss": "^4.1.11",
        "tailwindcss-animate": "^1.0.7",
        "typescript": "^5",
        "webpack": "^5.99.9"
    }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}

================
File: README.md
================
# Phaser Next.js Template

## 🚨 IMPORTANT - How to Run This Game 🚨

This project is configured as a **static export**. You MUST serve it as static files, NOT as a Next.js server app.

### ✅ Correct way to run:
```bash
# Build and serve static files
npm run serve
```

### ❌ DO NOT use:
- `npm run dev` - This starts Next.js dev server and will cause "_document.js not found" errors

---

This is a Phaser 3 project template that uses the Next.js framework. It includes a bridge for React to Phaser game communication, hot-reloading for quick development workflow and scripts to generate production-ready builds.

### Versions

This template has been updated for:

- [Phaser 3.90.0](https://github.com/phaserjs/phaser)
- [Next.js 15.3.1](https://github.com/vercel/next.js)
- [TypeScript 5](https://github.com/microsoft/TypeScript)

![screenshot](screenshot.png)

## Requirements

[Node.js](https://nodejs.org) is required to install dependencies and run scripts via `npm`.

## Available Commands

| Command | Description |
|---------|-------------|
| `npm install` | Install project dependencies |
| `npm run build` | Create a production build in the `dist` folder |
| `npm run serve` | **USE THIS TO RUN THE GAME** - Serves the static build on port 8080 |
| `npm run start` | Build and serve in one command |
| `npm run dev` | ⚠️ Development only - DO NOT use for running the game |
| `npm run dev-nolog` | Development server without analytics |
| `npm run build-nolog` | Build without analytics |

## Writing Code

After cloning the repo, run `npm install` from your project directory. Then, you can start the local development server by running `npm run dev`.

The local development server runs on `http://localhost:8080` by default. Please see the Next.js documentation if you wish to change this, or add SSL support.

Once the server is running you can edit any of the files in the `src` folder. Next.js will automatically recompile your code and then reload the browser.

## Template Project Structure

We have provided a default project structure to get you started. This is as follows:

| Path                          | Description                                                                 |
|-------------------------------|-----------------------------------------------------------------------------|
| `src/pages/_document.tsx`     | A basic Next.js component entry point. It is used to define the `<html>` and `<body>` tags and other globally shared UI. |
| `src`                         | Contains the Next.js client source code.                                   |
| `src/styles/globals.css`      | Some simple global CSS rules to help with page layout. You can enable Tailwind CSS here. |
| `src/page/_app.tsx`           | The main Next.js component.                                                |
| `src/App.tsx`                 | Middleware component used to run Phaser in client mode.                    |
| `src/PhaserGame.tsx`          | The React component that initializes the Phaser Game and serves as a bridge between React and Phaser. |
| `src/game/EventBus.ts`        | A simple event bus to communicate between React and Phaser.                |
| `src/game`                    | Contains the game source code.                                             |
| `src/game/main.tsx`           | The main **game** entry point. This contains the game configuration and starts the game. |
| `src/game/scenes/`            | The Phaser Scenes are in this folder.                                      |
| `public/favicon.png`          | The default favicon for the project.                                       |
| `public/assets`               | Contains the static assets used by the game.                               |


## React Bridge

The `PhaserGame.tsx` component is the bridge between React and Phaser. It initializes the Phaser game and passes events between the two.

To communicate between React and Phaser, you can use the **EventBus.js** file. This is a simple event bus that allows you to emit and listen for events from both React and Phaser.

```js
// In React
import { EventBus } from './EventBus';

// Emit an event
EventBus.emit('event-name', data);

// In Phaser
// Listen for an event
EventBus.on('event-name', (data) => {
    // Do something with the data
});
```

In addition to this, the `PhaserGame` component exposes the Phaser game instance along with the most recently active Phaser Scene using React forwardRef.

Once exposed, you can access them like any regular react reference.

## Phaser Scene Handling

In Phaser, the Scene is the lifeblood of your game. It is where you sprites, game logic and all of the Phaser systems live. You can also have multiple scenes running at the same time. This template provides a way to obtain the current active scene from React.

You can get the current Phaser Scene from the component event `"current-active-scene"`. In order to do this, you need to emit the event `"current-scene-ready"` from the Phaser Scene class. This event should be emitted when the scene is ready to be used. You can see this done in all of the Scenes in our template.

**Important**: When you add a new Scene to your game, make sure you expose to React by emitting the `"current-scene-ready"` event via the `EventBus`, like this:


```ts
class MyScene extends Phaser.Scene
{
    constructor ()
    {
        super('MyScene');
    }

    create ()
    {
        // Your Game Objects and logic here

        // At the end of create method:
        EventBus.emit('current-scene-ready', this);
    }
}
```

You don't have to emit this event if you don't need to access the specific scene from React. Also, you don't have to emit it at the end of `create`, you can emit it at any point. For example, should your Scene be waiting for a network request or API call to complete, it could emit the event once that data is ready.

### React Component Example

Here's an example of how to access Phaser data for use in a React Component:

```ts
import { useRef } from 'react';
import { IRefPhaserGame } from "./game/PhaserGame";

// In a parent component
const ReactComponent = () => {

    const phaserRef = useRef<IRefPhaserGame>(); // you can access to this ref from phaserRef.current

    const onCurrentActiveScene = (scene: Phaser.Scene) => {
    
        // This is invoked

    }

    return (
        ...
        <PhaserGame ref={phaserRef} currentActiveScene={onCurrentActiveScene} />
        ...
    );

}
```

In the code above, you can get a reference to the current Phaser Game instance and the current Scene by creating a reference with `useRef()` and assign to PhaserGame component.

From this state reference, the game instance is available via `phaserRef.current.game` and the most recently active Scene via `phaserRef.current.scene`.

The `onCurrentActiveScene` callback will also be invoked whenever the the Phaser Scene changes, as long as you emit the event via the EventBus, as outlined above.

## Handling Assets

To load your static games files such as audio files, images, videos, etc place them into the `public/assets` folder. Then you can use this path in the Loader calls within Phaser:

```js
preload ()
{
    //  This is an example of loading a static image
    //  from the public/assets folder:
    this.load.image('background', 'assets/bg.png');
}
```

When you issue the `npm run build` command, all static assets are automatically copied to the `dist/assets` folder.

## Deploying to Production

After you run the `npm run build` command, your code will be built into a single bundle and saved to the `dist` folder, along with any other assets your project imported, or stored in the public assets folder.

In order to deploy your game, you will need to upload *all* of the contents of the `dist` folder to a public facing web server.

## Customizing the Template

### Next.js

If you want to customize your build, such as adding plugin (i.e. for loading CSS or fonts), you can modify the `next.config.mjs` file for cross-project changes, or you can modify and/or create new configuration files and target them in specific npm tasks inside of `package.json`. Please see the [Next.js documentation](https://nextjs.org/docs) for more information.

## About log.js

If you inspect our node scripts you will see there is a file called `log.js`. This file makes a single silent API call to a domain called `gryzor.co`. This domain is owned by Phaser Studio Inc. The domain name is a homage to one of our favorite retro games.

We send the following 3 pieces of data to this API: The name of the template being used (vue, react, etc). If the build was 'dev' or 'prod' and finally the version of Phaser being used.

At no point is any personal data collected or sent. We don't know about your project files, device, browser or anything else. Feel free to inspect the `log.js` file to confirm this.

Why do we do this? Because being open source means we have no visible metrics about which of our templates are being used. We work hard to maintain a large and diverse set of templates for Phaser developers and this is our small anonymous way to determine if that work is actually paying off, or not. In short, it helps us ensure we're building the tools for you.

However, if you don't want to send any data, you can use these commands instead:

Dev:

```bash
npm run dev-nolog
```

Build:

```bash
npm run build-nolog
```

Or, to disable the log entirely, simply delete the file `log.js` and remove the call to it in the `scripts` section of `package.json`:

Before:

```json
"scripts": {
    "dev": "node log.js dev & dev-template-script",
    "build": "node log.js build & build-template-script"
},
```

After:

```json
"scripts": {
    "dev": "dev-template-script",
    "build": "build-template-script"
},
```

Either of these will stop `log.js` from running. If you do decide to do this, please could you at least join our Discord and tell us which template you're using! Or send us a quick email. Either will be super-helpful, thank you.

## Join the Phaser Community!

We love to see what developers like you create with Phaser! It really motivates us to keep improving. So please join our community and show-off your work 😄

**Visit:** The [Phaser website](https://phaser.io) and follow on [Phaser Twitter](https://twitter.com/phaser_)<br />
**Play:** Some of the amazing games [#madewithphaser](https://twitter.com/search?q=%23madewithphaser&src=typed_query&f=live)<br />
**Learn:** [API Docs](https://newdocs.phaser.io), [Support Forum](https://phaser.discourse.group/) and [StackOverflow](https://stackoverflow.com/questions/tagged/phaser-framework)<br />
**Discord:** Join us on [Discord](https://discord.gg/phaser)<br />
**Code:** 2000+ [Examples](https://labs.phaser.io)<br />
**Read:** The [Phaser World](https://phaser.io/community/newsletter) Newsletter<br />

Created by [Phaser Studio](mailto:support@phaser.io). Powered by coffee, anime, pixels and love.

The Phaser logo and characters are &copy; 2011 - 2025 Phaser Studio Inc.

All rights reserved.

================
File: SHADCN_IMPLEMENTATION_GUIDE.md
================
# shadcn/ui Implementation Guide for Phaser-React Integration

## Overview

This guide documents the successful implementation of shadcn/ui components in a Phaser 3 + Next.js game project, with specific focus on creating UI overlays that properly render above the game canvas and integrate with game business logic via EventBus.

## Table of Contents

1. [Project Architecture](#project-architecture)
2. [Implementation Steps](#implementation-steps)
3. [Key Learnings](#key-learnings)
4. [Component Communication](#component-communication)
5. [Z-Index Management](#z-index-management)
6. [Future Implementation Guidelines](#future-implementation-guidelines)

## Project Architecture

### Technology Stack
- **Game Engine**: Phaser 3.90.0
- **Framework**: Next.js 15.3.1 with React 18
- **UI Library**: shadcn/ui with Radix UI primitives
- **CSS Framework**: Tailwind CSS v4 with PostCSS
- **State Management**: EventBus pattern for React-Phaser communication

### Key Components Created

1. **SpeciesPanel** (`src/components/SpeciesPanel.tsx`)
   - Replaces the original ClueDisplay component
   - Features a shadcn Menubar header with dropdown menus
   - Maintains all original game logic and EventBus integration

2. **GemLegendDialog** (`src/components/GemLegendDialog.tsx`)
   - Modal dialog showing gem-to-category mappings
   - Properly overlays the Phaser game canvas
   - Uses shadcn Dialog component with custom styling

## Implementation Steps

### 1. Foundation Setup

#### Dependencies Installation
```bash
# Core Tailwind and PostCSS dependencies
npm install -D tailwindcss postcss autoprefixer @tailwindcss/postcss tailwindcss-animate

# shadcn/ui utilities and dependencies
npm install class-variance-authority clsx tailwind-merge lucide-react

# Radix UI primitives
npm install @radix-ui/react-menubar @radix-ui/react-dialog @radix-ui/react-separator @radix-ui/react-slot
```

#### Configuration Files

**tailwind.config.js**
```javascript
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
    './app/**/*.{js,ts,jsx,tsx}',
    './src/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        // ... other color definitions
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
```

**postcss.config.js** (Tailwind v4 compatible)
```javascript
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
```

**components.json**
```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/styles/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
```

### 2. CSS Integration

#### Global Styles Setup
```css
/* src/styles/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Global reset for full-screen display */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

@layer base {
  :root {
    /* Light theme variables */
    --background: 0 0% 100%;
    --foreground: 224 71.4% 4.1%;
    /* ... other variables */
  }

  .dark {
    /* Dark theme variables */
    --background: 224 71.4% 4.1%;
    --foreground: 210 20% 98%;
    /* ... other variables */
  }
}

/* Ensure full viewport coverage */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

#__next {
  width: 100%;
  height: 100%;
}
```

#### Dark Mode Setup
```tsx
// src/pages/_document.tsx
<Html lang="en" className="dark">
```

### 3. Component Installation

```bash
# Install shadcn components
npx shadcn@latest add menubar dialog button card separator
```

## Key Learnings

### 1. Z-Index Management for Phaser Overlays

**Problem**: Dialog components appeared behind the Phaser game canvas.

**Solution**: Implement explicit z-index hierarchy:

```tsx
// PhaserGame.tsx - Set game container z-index
<div id="game-container" style={{ position: 'relative', zIndex: 1 }}></div>

// dialog.tsx - Set high z-index for overlays
className={cn(
  "fixed inset-0 z-[9999] bg-black/90", // Overlay
  className
)}

// Dialog content even higher
className={cn(
  "fixed top-[50%] left-[50%] z-[10000]", // Content
  className
)}
```

### 2. React forwardRef Requirements

**Problem**: Warning about function components not accepting refs.

**Solution**: Use React.forwardRef for Radix UI primitive wrappers:

```tsx
const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    // ... rest of component
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName
```

### 3. Tailwind v4 Compatibility

**Problem**: PostCSS configuration errors with Tailwind v4.

**Solution**: Use `@tailwindcss/postcss` instead of direct `tailwindcss`:

```javascript
// postcss.config.js
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {}, // Not 'tailwindcss'
    autoprefixer: {},
  },
}
```

### 4. Asset Path Resolution

**Problem**: Gem images returned 404 errors.

**Solution**: Match actual file naming convention:

```tsx
// Incorrect
src={`/assets/gems/gem${gemId}.png`}

// Correct - matches actual file structure
src={`/assets/${gemId}_gem_0.png`}
```

## Component Communication

### EventBus Integration Pattern

The SpeciesPanel maintains all original ClueDisplay functionality through EventBus:

```tsx
useEffect(() => {
  // Listen for game events
  const handleClueRevealed = (clueData: ClueData) => {
    setIsLoadingClue(true);
    setTimeout(() => {
      setClues(prev => [...prev, clueData]);
      setIsLoadingClue(false);
    }, 500);
  };

  const handleNewGame = (data: { 
    speciesName: string; 
    speciesId: number; 
    totalSpecies: number; 
    currentIndex: number 
  }) => {
    setClues([]);
    setSelectedSpeciesName(data.speciesName);
    // ... update other state
  };

  // Register listeners
  EventBus.on('clue-revealed', handleClueRevealed);
  EventBus.on('new-game-started', handleNewGame);
  // ... other listeners

  // Cleanup
  return () => {
    EventBus.off('clue-revealed', handleClueRevealed);
    EventBus.off('new-game-started', handleNewGame);
    // ... remove other listeners
  };
}, []);
```

### Data Flow
1. **Phaser → React**: Game emits events via EventBus
2. **React State**: Components update local state based on events
3. **UI Update**: shadcn components render based on state
4. **User Interaction**: Menu actions can emit events back to Phaser

## Z-Index Management

### Layering Strategy

```
Layer 0 (z-index: auto): Document flow
Layer 1 (z-index: 1): Phaser game canvas
Layer 50 (z-index: 50): Standard UI elements
Layer 1000 (z-index: 1000): Cesium minimize button
Layer 9999 (z-index: 9999): Modal overlays
Layer 10000 (z-index: 10000): Modal content
```

### Best Practices

1. **Always set explicit z-index** on game containers
2. **Use high z-index values** for modal overlays (9999+)
3. **Portal components** render at document body level
4. **Test overlay behavior** with game running

## Future Implementation Guidelines

### Adding New shadcn Components

1. **Install via CLI**:
   ```bash
   npx shadcn@latest add [component-name]
   ```

2. **Check for forwardRef requirements** if using with primitives

3. **Apply dark theme classes** for game consistency:
   ```tsx
   className="bg-black/95 border-gray-700"
   ```

4. **Set appropriate z-index** for overlays:
   ```tsx
   className="z-[9999]" // For overlays
   className="z-[10000]" // For overlay content
   ```

### Creating Game-Integrated Components

1. **Import EventBus**:
   ```tsx
   import { EventBus } from '../game/EventBus';
   ```

2. **Set up listeners in useEffect**:
   ```tsx
   useEffect(() => {
     const handler = (data) => { /* handle event */ };
     EventBus.on('event-name', handler);
     return () => EventBus.off('event-name', handler);
   }, []);
   ```

3. **Preserve existing game logic** when refactoring

4. **Test responsive behavior** at different viewport sizes

### Menubar Implementation Pattern

```tsx
<Menubar className="rounded-none border-b border-gray-700">
  <MenubarMenu>
    <MenubarTrigger>Menu Title</MenubarTrigger>
    <MenubarContent>
      <MenubarItem onClick={handleAction}>
        Action Label <MenubarShortcut>⌘K</MenubarShortcut>
      </MenubarItem>
      <MenubarSeparator />
      <MenubarItem disabled>Disabled Item</MenubarItem>
    </MenubarContent>
  </MenubarMenu>
</Menubar>
```

### Dialog Implementation Pattern

```tsx
<Dialog open={open} onOpenChange={setOpen}>
  <DialogContent className="bg-black/95 border-gray-700">
    <DialogHeader>
      <DialogTitle>Title</DialogTitle>
      <DialogDescription>Description</DialogDescription>
    </DialogHeader>
    {/* Content */}
  </DialogContent>
</Dialog>
```

## Troubleshooting

### Common Issues and Solutions

1. **Components not visible over game**
   - Check z-index values
   - Ensure portal components are used
   - Verify game container has lower z-index

2. **Styling not applied**
   - Check Tailwind content paths in config
   - Verify PostCSS configuration
   - Ensure CSS file imports are correct

3. **TypeScript errors**
   - Run `npm run typecheck` to identify issues
   - Check component prop types match usage
   - Verify all imports are correct

4. **Asset loading failures**
   - Verify file paths match actual structure
   - Check public directory structure
   - Ensure assets are in correct location

## Conclusion

This implementation successfully integrates shadcn/ui with a Phaser game, providing:
- Modern UI components that overlay the game canvas
- Seamless communication between React UI and Phaser game logic
- Responsive design that adapts to viewport changes
- Dark theme consistency with game aesthetics

The pattern established here can be extended to add more UI components while maintaining game functionality and visual coherence.

================
File: supabase_location_query_function.sql
================
-- Enhanced location query function for Supabase
-- Combines habitat and species data queries into a single RPC function
-- Run this in your Supabase SQL Editor

CREATE OR REPLACE FUNCTION query_location_info(
  lon float,
  lat float
) RETURNS json AS $$
DECLARE
  habitat_values integer[];
  species_names text[];
  result json;
BEGIN
  -- Create point geometry from coordinates
  DECLARE
    point_geom geometry := ST_SetSRID(ST_MakePoint(lon, lat), 4326);
    point_geog geography := point_geom::geography;
    buffer_1km geography := ST_Buffer(point_geog, 1000);
    buffer_10km geography := ST_Buffer(point_geog, 10000);
  BEGIN
    
    -- Query 1: Get habitat values within 1km
    -- Note: This assumes you have a habitat table with geometry columns
    -- If you only have raster data, you'll need to adapt this query
    BEGIN
      SELECT array_agg(DISTINCT habitat_code) INTO habitat_values
      FROM (
        -- Example query - adjust table/column names as needed
        -- If you have habitat polygons:
        SELECT habitat_type as habitat_code 
        FROM habitat_polygons 
        WHERE ST_Intersects(geom::geography, buffer_1km)
        
        UNION
        
        -- If you want to include some sample habitat codes for testing:
        SELECT unnest(ARRAY[100, 101, 200, 300]) as habitat_code
        WHERE EXISTS (SELECT 1) -- Always include for testing
        
        LIMIT 10
      ) habitat_data;
    EXCEPTION WHEN OTHERS THEN
      -- If habitat table doesn't exist, use sample data
      habitat_values := ARRAY[100, 101, 200, 300];
    END;
    
    -- Query 2: Get species within 10km using existing species table
    BEGIN
      SELECT array_agg(DISTINCT COALESCE(sci_name, comm_name, 'Unknown Species')) INTO species_names
      FROM icaa 
      WHERE ST_Intersects(wkb_geometry::geography, buffer_10km)
      LIMIT 50; -- Limit to prevent too much data
    EXCEPTION WHEN OTHERS THEN
      -- If query fails, return empty array
      species_names := ARRAY[]::text[];
    END;
    
    -- Build result JSON
    result := json_build_object(
      'habitats', COALESCE(habitat_values, ARRAY[]::integer[]),
      'species', COALESCE(species_names, ARRAY[]::text[]),
      'coordinates', json_build_object('lon', lon, 'lat', lat),
      'query_info', json_build_object(
        'habitat_buffer_km', 1,
        'species_buffer_km', 10,
        'habitat_count', array_length(habitat_values, 1),
        'species_count', array_length(species_names, 1)
      )
    );
    
    RETURN result;
  END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION query_location_info TO anon;
GRANT EXECUTE ON FUNCTION query_location_info TO authenticated;

-- Test the function (optional)
-- SELECT query_location_info(-95.3698, 29.7604);

-- Create a simpler version that works with your current data structure
CREATE OR REPLACE FUNCTION query_location_simple(
  lon float,
  lat float
) RETURNS json AS $$
DECLARE
  species_data json;
  habitat_codes integer[];
BEGIN
  -- Get species data using existing function
  SELECT json_agg(
    json_build_object(
      'sci_name', sci_name,
      'comm_name', comm_name,
      'ogc_fid', ogc_fid,
      'hab_desc', hab_desc,
      'aquatic', aquatic,
      'freshwater', freshwater,
      'terrestr', terrestr,
      'marine', marine
    )
  ) INTO species_data
  FROM get_species_at_point(lon, lat);
  
  -- For now, return sample habitat codes
  -- Later you can replace this with actual habitat queries
  habitat_codes := ARRAY[100, 101, 200, 300, 500];
  
  RETURN json_build_object(
    'habitats', habitat_codes,
    'species', COALESCE(species_data, '[]'::json),
    'debug', json_build_object(
      'coordinates', json_build_object('lon', lon, 'lat', lat),
      'source', 'query_location_simple function'
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions for simple version
GRANT EXECUTE ON FUNCTION query_location_simple TO anon;
GRANT EXECUTE ON FUNCTION query_location_simple TO authenticated;

-- Example usage:
-- SELECT query_location_simple(-95.3698, 29.7604);

================
File: supabase_spatial_function.sql
================
-- Create a function to query species at a specific point
-- This function should be run in the Supabase SQL editor

CREATE OR REPLACE FUNCTION get_species_at_point(lon float, lat float)
RETURNS SETOF icaa AS $$
BEGIN
  RETURN QUERY
  SELECT * FROM icaa
  WHERE ST_Contains(wkb_geometry, ST_SetSRID(ST_MakePoint(lon, lat), 4326))
  ORDER BY ogc_fid ASC;
END;
$$ LANGUAGE plpgsql;

-- Grant permissions to the function
GRANT EXECUTE ON FUNCTION get_species_at_point TO anon;
GRANT EXECUTE ON FUNCTION get_species_at_point TO authenticated;

-- Example usage:
-- SELECT * FROM get_species_at_point(-122.4194, 37.7749);

================
File: supabase-mcp-config.json
================
{
  "mcpServers": {
    "supabase": {
      "command": "wsl",
      "args": [
        "npx",
        "-y",
        "@supabase/mcp-server-supabase@latest",
        "--read-only",
        "--project-ref=YOUR_PROJECT_REF_HERE"
      ],
      "env": {
        "SUPABASE_ACCESS_TOKEN": "sbp_c823392d2e51102aa70a4dbe34d2c9c2c1bcd9be"
      }
    }
  }
}

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
    './app/**/*.{js,ts,jsx,tsx}',
    './src/**/*.{js,ts,jsx,tsx}',
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "strictPropertyInitialization": false,
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "target": "ES2017"
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}

================
File: UI_DISPLAY_SYSTEM_REFERENCE.md
================
# UI Display System Reference Guide

## Overview
This document provides a comprehensive reference for the reactive UI display system, including all functions, variables, configuration values, and interaction patterns needed to understand and modify the display behavior.

---

## Architecture Components

### 1. React Layout Layer (`src/MainAppLayout.tsx`)

#### State Variables
```typescript
const [cesiumMinimized, setCesiumMinimized] = useState(false);
const phaserRef = useRef<IRefPhaserGame | null>(null);
```

#### Key Style Objects
```typescript
const appStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    width: '100vw',
    height: '100vh',
    overflow: 'hidden'
};

const cesiumContainerStyle: React.CSSProperties = {
    width: '100%',
    height: cesiumMinimized ? '0%' : '30%',
    minHeight: '0px',
    borderBottom: cesiumMinimized ? 'none' : '2px solid #555',
    position: 'relative',
    transition: 'height 0.3s ease-in-out',
    overflow: 'hidden'
};

const phaserGameWrapperStyle: React.CSSProperties = {
    width: '100%',
    height: cesiumMinimized ? '60%' : 'calc(100% - 150px)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
};

const gameUiPanelStyle: React.CSSProperties = {
    width: '100%',
    height: cesiumMinimized ? '40%' : '150px',
    padding: '10px',
    boxSizing: 'border-box',
    borderTop: '2px solid #555',
    overflowY: 'auto',
    backgroundColor: '#282c34',
    color: 'white',
    transition: 'height 0.3s ease-in-out'
};
```

#### Reactive Functions
```typescript
// Emits layout change event when state changes
useEffect(() => {
    EventBus.emit('layout-changed', { mapMinimized: cesiumMinimized });
}, [cesiumMinimized]);

// Handles Phaser scene ready callback
const handlePhaserSceneReady = (scene: Phaser.Scene) => {
    console.log('MainAppLayout: Phaser scene ready -', scene.scene.key);
    if (phaserRef.current) {
        phaserRef.current.scene = scene;
    }
};
```

### 2. Phaser Game Layer (`src/game/scenes/Game.ts`)

#### Core Layout Variables
```typescript
private gemSize: number = 64;                    // Size of each gem in pixels
private boardOffset: BoardOffset = { x: 0, y: 0 }; // Top-left position of board
private isMapMinimized: boolean = false;         // Layout state
```

#### UI Text Elements
```typescript
private statusText: Phaser.GameObjects.Text | null = null;  // Center status messages
private scoreText: Phaser.GameObjects.Text | null = null;   // Top-left score display
private movesText: Phaser.GameObjects.Text | null = null;   // Top-right moves display
```

#### Layout Constants
```typescript
const TOP_UI_OFFSET = 60;  // Space reserved at top for score/moves (pixels)
const GRID_COLS = 7;       // Number of columns in gem grid
const GRID_ROWS = 8;       // Number of rows in gem grid
```

#### Key Calculation Functions

##### `calculateBoardDimensions()`
**Purpose**: Calculates gem size and board position based on current screen size and layout state.

```typescript
private calculateBoardDimensions(): void {
    const { width, height } = this.scale;
    if (width <= 0 || height <= 0) {
        console.warn("Invalid scale dimensions.");
        return;
    }
    
    // Define constants for UI space
    const TOP_UI_OFFSET = 60; // Space for score/moves text at top
    
    const usableWidth = width * 0.95;
    
    // When map is minimized, use more vertical space but leave room at top for UI
    const usableHeight = this.isMapMinimized 
        ? height - TOP_UI_OFFSET - 20  // Almost full height minus top UI
        : height * 0.90;               // Original logic
    
    const sizeFromWidth = Math.floor(usableWidth / GRID_COLS);
    const sizeFromHeight = Math.floor(usableHeight / GRID_ROWS);
    this.gemSize = Math.max(24, Math.min(sizeFromWidth, sizeFromHeight));
    const boardWidth = GRID_COLS * this.gemSize;
    const boardHeight = GRID_ROWS * this.gemSize;
    
    // X offset is still centered
    const boardOffsetX = Math.round((width - boardWidth) / 2);
    
    // Y offset changes based on map minimized state
    const boardOffsetY = this.isMapMinimized
        ? TOP_UI_OFFSET  // Position right below top UI when map minimized
        : Math.round((height - boardHeight) / 2); // Center vertically normally
    
    this.boardOffset = {
        x: boardOffsetX,
        y: boardOffsetY
    };
}
```

##### `handleLayoutChange()`
**Purpose**: Responds to layout state changes from React layer.

```typescript
private handleLayoutChange(data: { mapMinimized: boolean }): void {
    console.log(`Game Scene: Layout changed - Map minimized = ${data.mapMinimized}`);
    this.isMapMinimized = data.mapMinimized;
    
    // Trigger a resize/recalculation to update board position
    this.handleResize();
}
```

##### `handleResize()`
**Purpose**: Handles window/canvas resize events and updates all UI elements.

```typescript
private handleResize(): void {
    console.log("Game Scene: Resize detected.");
    const { width, height } = this.scale;
    this.calculateBoardDimensions();
    
    if (this.statusText && this.statusText.active) {
        this.statusText.setPosition(width / 2, height / 2);
        const textStyle = this.statusText.style;
        if (textStyle && typeof textStyle.setWordWrapWidth === 'function') {
            textStyle.setWordWrapWidth(width * 0.8);
        }
    }
    
    // Update UI positions
    if (this.movesText) {
        this.movesText.setPosition(width - 20, 20);
    }
    
    if (this.boardView) {
        this.boardView.updateVisualLayout(this.gemSize, this.boardOffset);
    }
}
```

#### Event Listener Setup
```typescript
// In create() method
this.scale.on(Phaser.Scale.Events.RESIZE, this.handleResize, this);
EventBus.on('cesium-location-selected', this.initializeBoardFromCesium, this);
EventBus.on('layout-changed', this.handleLayoutChange, this);
```

#### Event Cleanup
```typescript
// In shutdown() method
EventBus.off('cesium-location-selected', this.initializeBoardFromCesium, this);
EventBus.off('layout-changed', this.handleLayoutChange, this);
this.scale.off(Phaser.Scale.Events.RESIZE, this.handleResize, this);
```

### 3. Board View Layer (`src/game/BoardView.ts`)

#### Core Properties
```typescript
private scene: Phaser.Scene;
private gridCols: number;                        // Number of columns
private gridRows: number;                        // Number of rows  
private gemSize: number;                         // Size of each gem
private boardOffset: { x: number; y: number };  // Board position
private gemsSprites: (Phaser.GameObjects.Sprite | null)[][]; // 2D sprite array
private gemGroup: Phaser.GameObjects.Group;     // Sprite group for management
```

#### Position Calculation Functions

##### `getSpritePosition()`
**Purpose**: Calculates the exact pixel position for a gem at given grid coordinates.

```typescript
private getSpritePosition(gridX: number, gridY: number): { x: number; y: number } {
    return {
        x: this.boardOffset.x + gridX * this.gemSize + this.gemSize / 2,
        y: this.boardOffset.y + gridY * this.gemSize + this.gemSize / 2
    };
}
```

##### `calculateSpriteScale()`
**Purpose**: Determines the scale factor for gem sprites (90% of gem size for spacing).

```typescript
private calculateSpriteScale(sprite: Phaser.GameObjects.Sprite): number {
    if (!sprite.texture || !sprite.frame) {
        console.warn("BoardView: Sprite missing texture or frame for scale calculation.");
        return 0.9; // Fallback
    }
    const frameWidth = sprite.frame.width;
    const frameHeight = sprite.frame.height;
    const maxFrameDimension = Math.max(frameWidth, frameHeight);
    return (this.gemSize * 0.9) / maxFrameDimension; // 90% to create spacing
}
```

#### Animation Functions

##### `updateVisualLayout()`
**Purpose**: Smoothly animates existing sprites to new positions/scales.

```typescript
updateVisualLayout(newGemSize: number, newBoardOffset: { x: number; y: number }): void {
    console.log("BoardView: Updating visual layout.");
    this.gemSize = newGemSize;
    this.boardOffset = newBoardOffset;

    this.iterateSprites((sprite, x, y) => {
        const targetPos = this.getSpritePosition(x, y);
        const newScale = this.calculateSpriteScale(sprite);

        this.scene.tweens.killTweensOf(sprite); // Stop existing movement
        this.scene.tweens.add({
            targets: sprite,
            x: targetPos.x,
            y: targetPos.y,
            scale: newScale,
            duration: TWEEN_DURATION_LAYOUT_UPDATE,
            ease: 'Sine.easeInOut'
        });
    });
}
```

##### `updateDimensions()`
**Purpose**: Updates internal dimensions without animation (for board recreation scenarios).

```typescript
updateDimensions(newGemSize: number, newBoardOffset: { x: number; y: number }): void {
    console.log("BoardView: Updating dimensions (no animation).");
    this.gemSize = newGemSize;
    this.boardOffset = newBoardOffset;
}
```

### 4. EventBus Communication (`src/game/EventBus.ts`)

#### Event Definitions
```typescript
export interface EventPayloads {
    'current-scene-ready': Phaser.Scene;
    'cesium-location-selected': {
        lon: number;
        lat: number;
        habitats: string[];
        species: Species[];
        rasterHabitats: RasterHabitatResult[];
    };
    'layout-changed': {
        mapMinimized: boolean;
    };
    'clue-revealed': {
        category: number;
        heading: string;
        clue: string;
        speciesId: number;
    };
    // ... other events
}
```

#### Communication Patterns
```typescript
// React → Phaser
EventBus.emit('layout-changed', { mapMinimized: cesiumMinimized });

// Phaser → React  
EventBus.emit('clue-revealed', clueData);

// Listening for events
EventBus.on('layout-changed', this.handleLayoutChange, this);
```

---

## Configuration Values

### Layout Breakpoints
```typescript
// Default layout (map visible)
MAP_HEIGHT = '30%'
GAME_HEIGHT = 'calc(100% - 150px)'
CLUE_HEIGHT = '150px'

// Minimized layout (map hidden)
MAP_HEIGHT = '0%'
GAME_HEIGHT = '60%'
CLUE_HEIGHT = '40%'
```

### Animation Timings
```typescript
// CSS transitions
LAYOUT_TRANSITION = '0.3s ease-in-out'

// Phaser tweens (from constants.ts)
TWEEN_DURATION_LAYOUT_UPDATE = 300  // milliseconds
TWEEN_DURATION_EXPLODE = 200
TWEEN_DURATION_FALL_BASE = 150
TWEEN_DURATION_SNAP = 100
```

### Board Spacing
```typescript
GEM_SCALE_FACTOR = 0.9          // Gems are 90% of cell size
GEM_SPACING = gemSize * 0.1     // 10% margin around each gem
BOARD_MARGIN_X = width * 0.05   // 5% margin on sides
BOARD_MARGIN_Y = height * 0.10  // 10% margin top/bottom (normal mode)
```

### UI Positioning
```typescript
TOP_UI_OFFSET = 60              // Space for score/moves at top
SCORE_POSITION = { x: 20, y: 20 }
MOVES_POSITION = { x: width - 20, y: 20 }
STATUS_POSITION = { x: width / 2, y: height / 2 }
```

---

## Responsive Behavior Patterns

### 1. Window Resize
**Trigger**: Browser window size change
**Flow**:
1. Phaser detects resize → `Phaser.Scale.Events.RESIZE`
2. `handleResize()` called
3. `calculateBoardDimensions()` recalculates layout
4. `updateVisualLayout()` animates gems to new positions

### 2. Map Minimize/Expand
**Trigger**: User clicks minimize button
**Flow**:
1. React state change → `setCesiumMinimized(!cesiumMinimized)`
2. CSS transitions start for container heights
3. `useEffect` triggers → `EventBus.emit('layout-changed')`
4. Phaser receives event → `handleLayoutChange()`
5. `handleResize()` recalculates board position
6. Gems animate to new positions

### 3. Board Recreation
**Trigger**: New location selected from map
**Flow**:
1. `initializeBoardFromCesium()` called
2. `calculateBoardDimensions()` updates layout
3. `updateDimensions()` updates BoardView (no animation)
4. Old board destroyed → `destroyBoard()`
5. New board created → `createBoard()` at correct positions

---

## Debugging Reference

### Console Logs to Monitor
```typescript
"Game Scene: Layout changed - Map minimized = true/false"
"Game Scene: Resize detected."
"BoardView: Updating visual layout."
"BoardView: Updating dimensions (no animation)."
"Game Scene: Board initialized with random gems."
```

### CSS Debug Classes
```css
/* Add colored borders to visualize containers */
.app-container { border: 2px solid red; }
.cesium-container { border: 2px solid blue; }
.phaser-container { border: 2px solid green; }
.game-ui-panel { border: 2px solid yellow; }
```

### EventBus Debug
```typescript
// Monitor all events
EventBus.on('*', (event, data) => console.log('Event:', event, data));
```

---

## Extension Points

### Adding New Layout States
1. Add state to `MainAppLayout.tsx`
2. Create CSS styles for new state
3. Add event type to `EventPayloads`
4. Handle event in `Game.ts`
5. Update `calculateBoardDimensions()` logic

### Modifying Animations
- **Layout transitions**: Modify CSS `transition` properties
- **Gem movements**: Adjust `TWEEN_DURATION_*` constants
- **Easing functions**: Change `ease` property in tween configs

### Responsive Breakpoints
```typescript
// Add mobile-specific behavior
const isMobile = width < 768;
const boardMargin = isMobile ? 0.02 : 0.05;
```

### Performance Optimization
- Use `React.memo` for heavy components
- Debounce resize handlers
- Pool Phaser sprites for frequent creation/destruction
- Batch EventBus emissions

---

## Common Issues and Solutions

### Issue: Board jumps after recreation
**Solution**: Use `updateDimensions()` instead of `updateVisualLayout()` before board recreation

### Issue: Animations conflict
**Solution**: Always call `this.scene.tweens.killTweensOf(sprite)` before new animations

### Issue: Layout doesn't update
**Solution**: Ensure EventBus listeners are properly set up and cleaned up

### Issue: Performance problems
**Solution**: Limit concurrent tweens, use sprite pooling, debounce resize events

This reference should provide everything needed to understand, debug, and extend the UI display system.

================
File: vercel.json
================
{
  "buildCommand": "npm run vercel-build",
  "outputDirectory": "dist",
  "framework": null
}
